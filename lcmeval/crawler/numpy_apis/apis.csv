api_name,description,parameters,examples
numpy.bitwise_and,Compute the bit-wise AND of two arrays element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Only integer and boolean types are handled.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Result.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.bitwise_and(13, 17)
1
>>> np.bitwise_and(14, 13)
12
>>> np.binary_repr(12)
'1100'
>>> np.bitwise_and([14,3], 13)
array([12,  1])
>>> np.bitwise_and([11,7], [4,25])
array([0, 1])
>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))
array([ 2,  4, 16])
>>> np.bitwise_and([True, True], [False, True])
array([False,  True])
>>> x1 = np.array([2, 5, 255])
>>> x2 = np.array([3, 14, 16])
>>> x1 & x2
array([ 2,  4, 16])"
numpy.bitwise_or,Compute the bit-wise OR of two arrays element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Only integer and boolean types are handled.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Result.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.bitwise_or(13, 16)
29
>>> np.binary_repr(29)
'11101'
>>> np.bitwise_or(32, 2)
34
>>> np.bitwise_or([33, 4], 1)
array([33,  5])
>>> np.bitwise_or([33, 4], [1, 2])
array([33,  6])
>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))
array([  6,   5, 255])
>>> np.array([2, 5, 255]) | np.array([4, 4, 4])
array([  6,   5, 255])
>>> np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),
...               np.array([4, 4, 4, 2147483647], dtype=np.int32))
array([         6,          5,        255, 2147483647], dtype=int32)
>>> np.bitwise_or([True, True], [False, True])
array([ True,  True])
>>> x1 = np.array([2, 5, 255])
>>> x2 = np.array([4, 4, 4])
>>> x1 | x2
array([  6,   5, 255])"
numpy.bitwise_xor,Compute the bit-wise XOR of two arrays element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Only integer and boolean types are handled.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Result.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.bitwise_xor(13, 17)
28
>>> np.binary_repr(28)
'11100'
>>> np.bitwise_xor(31, 5)
26
>>> np.bitwise_xor([31,3], 5)
array([26,  6])
>>> np.bitwise_xor([31,3], [5,6])
array([26,  5])
>>> np.bitwise_xor([True, True], [False, True])
array([ True, False])
>>> x1 = np.array([True, True])
>>> x2 = np.array([False, True])
>>> x1 ^ x2
array([ True, False])"
numpy.invert,"Compute bit-wise inversion, or bit-wise NOT, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Only integer and boolean types are handled.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Result.This is a scalar if x is a scalar.'}]}]",">>> np.bitwise_not is np.invert
True
>>> import numpy as np
>>> x = np.invert(np.array(13, dtype=np.uint8))
>>> x
np.uint8(242)
>>> np.binary_repr(x, width=8)
'11110010'
>>> x = np.invert(np.array(13, dtype=np.uint16))
>>> x
np.uint16(65522)
>>> np.binary_repr(x, width=16)
'1111111111110010'
>>> np.invert(np.array([13], dtype=np.int8))
array([-14], dtype=int8)
>>> np.binary_repr(-14, width=8)
'11110010'
>>> np.invert(np.array([True, False]))
array([False,  True])
>>> x1 = np.array([True, False])
>>> ~x1
array([False,  True])"
numpy.bitwise_invert,"Compute bit-wise inversion, or bit-wise NOT, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Only integer and boolean types are handled.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Result.This is a scalar if x is a scalar.'}]}]",">>> np.bitwise_not is np.invert
True
>>> import numpy as np
>>> x = np.invert(np.array(13, dtype=np.uint8))
>>> x
np.uint8(242)
>>> np.binary_repr(x, width=8)
'11110010'
>>> x = np.invert(np.array(13, dtype=np.uint16))
>>> x
np.uint16(65522)
>>> np.binary_repr(x, width=16)
'1111111111110010'
>>> np.invert(np.array([13], dtype=np.int8))
array([-14], dtype=int8)
>>> np.binary_repr(-14, width=8)
'11110010'
>>> np.invert(np.array([True, False]))
array([False,  True])
>>> x1 = np.array([True, False])
>>> ~x1
array([False,  True])"
numpy.left_shift,Shift the bits of an integer to the left.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like of integer type', 'description': 'Input values.'}, {'name': 'x2', 'type': 'array_like of integer type', 'description': 'Number of zeros to append to x1. Has to be non-negative.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'array of integer type', 'description': 'Return x1 with bits shifted x2 times to the left.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.binary_repr(5)
'101'
>>> np.left_shift(5, 2)
20
>>> np.binary_repr(20)
'10100'
>>> np.left_shift(5, [1,2,3])
array([10, 20, 40])
>>> a = np.left_shift(np.uint8(255), np.int64(1))  # Expect 254
>>> print(a, type(a)) # Unexpected result due to upcasting
510 <class 'numpy.int64'>
>>> b = np.left_shift(np.uint8(255), np.uint8(1))
>>> print(b, type(b))
254 <class 'numpy.uint8'>
>>> x1 = 5
>>> x2 = np.array([1, 2, 3])
>>> x1 << x2
array([10, 20, 40])"
numpy.bitwise_left_shift,Shift the bits of an integer to the left.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like of integer type', 'description': 'Input values.'}, {'name': 'x2', 'type': 'array_like of integer type', 'description': 'Number of zeros to append to x1. Has to be non-negative.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'array of integer type', 'description': 'Return x1 with bits shifted x2 times to the left.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.binary_repr(5)
'101'
>>> np.left_shift(5, 2)
20
>>> np.binary_repr(20)
'10100'
>>> np.left_shift(5, [1,2,3])
array([10, 20, 40])
>>> a = np.left_shift(np.uint8(255), np.int64(1))  # Expect 254
>>> print(a, type(a)) # Unexpected result due to upcasting
510 <class 'numpy.int64'>
>>> b = np.left_shift(np.uint8(255), np.uint8(1))
>>> print(b, type(b))
254 <class 'numpy.uint8'>
>>> x1 = 5
>>> x2 = np.array([1, 2, 3])
>>> x1 << x2
array([10, 20, 40])"
numpy.right_shift,Shift the bits of an integer to the right.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like, int', 'description': 'Input values.'}, {'name': 'x2', 'type': 'array_like, int', 'description': 'Number of bits to remove at the right of x1.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray, int', 'description': 'Return x1 with bits shifted x2 times to the right.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.binary_repr(10)
'1010'
>>> np.right_shift(10, 1)
5
>>> np.binary_repr(5)
'101'
>>> np.right_shift(10, [1,2,3])
array([5, 2, 1])
>>> x1 = 10
>>> x2 = np.array([1,2,3])
>>> x1 >> x2
array([5, 2, 1])"
numpy.bitwise_right_shift,Shift the bits of an integer to the right.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like, int', 'description': 'Input values.'}, {'name': 'x2', 'type': 'array_like, int', 'description': 'Number of bits to remove at the right of x1.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray, int', 'description': 'Return x1 with bits shifted x2 times to the right.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.binary_repr(10)
'1010'
>>> np.right_shift(10, 1)
5
>>> np.binary_repr(5)
'101'
>>> np.right_shift(10, [1,2,3])
array([5, 2, 1])
>>> x1 = 10
>>> x2 = np.array([1,2,3])
>>> x1 >> x2
array([5, 2, 1])"
numpy.packbits,Packs the elements of a binary-valued array into bits in a uint8 array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'An array of integers or booleans whose elements should be packed tobits.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The dimension over which bit-packing is done.None implies packing the flattened array.'}, {'name': 'bitorder', 'type': '{‘big’, ‘little’}, optional', 'description': 'The order of the input bits. ‘big’ will mimic bin(val),[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011, ‘little’ willreverse the order so [1, 1, 0, 0, 0, 0, 0, 0] => 3.Defaults to ‘big’.'}]}, {'Returns': [{'name': 'packed', 'type': 'ndarray', 'description': 'Array of type uint8 whose elements represent bits corresponding to thelogical (0 or nonzero) value of the input elements. The shape ofpacked has the same number of dimensions as the input (unless axisis None, in which case the output is 1-D).'}]}]",">>> import numpy as np
>>> a = np.array([[[1,0,1],
...                [0,1,0]],
...               [[1,1,0],
...                [0,0,1]]])
>>> b = np.packbits(a, axis=-1)
>>> b
array([[[160],
        [ 64]],
       [[192],
        [ 32]]], dtype=uint8)"
numpy.unpackbits,Unpacks elements of a uint8 array into a binary-valued output array.,"[{'Parameters': [{'name': 'a', 'type': 'ndarray, uint8 type', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The dimension over which bit-unpacking is done.None implies unpacking the flattened array.'}, {'name': 'count', 'type': 'int or None, optional', 'description': 'The number of elements to unpack along axis, provided as a wayof undoing the effect of packing a size that is not a multipleof eight. A non-negative number means to only unpack countbits. A negative number means to trim off that many bits fromthe end. None means to unpack the entire array (thedefault). Counts larger than the available number of bits willadd zero padding to the output. Negative counts must notexceed the available number of bits.'}, {'name': 'bitorder', 'type': '{‘big’, ‘little’}, optional', 'description': 'The order of the returned bits. ‘big’ will mimic bin(val),3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1], ‘little’ will reversethe order to [1, 1, 0, 0, 0, 0, 0, 0].Defaults to ‘big’.'}]}, {'Returns': [{'name': 'unpacked', 'type': 'ndarray, uint8 type', 'description': 'The elements are binary-valued (0 or 1).'}]}]",">>> import numpy as np
>>> a = np.array([[2], [7], [23]], dtype=np.uint8)
>>> a
array([[ 2],
       [ 7],
       [23]], dtype=uint8)
>>> b = np.unpackbits(a, axis=1)
>>> b
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
>>> c = np.unpackbits(a, axis=1, count=-3)
>>> c
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0]], dtype=uint8)
>>> p = np.packbits(b, axis=0)
>>> np.unpackbits(p, axis=0)
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
>>> np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))
True"
numpy.binary_repr,Return the binary representation of the input number as a string.,"[{'Parameters': [{'name': 'num', 'type': 'int', 'description': 'Only an integer decimal number can be used.'}, {'name': 'width', 'type': 'int, optional', 'description': 'The length of the returned string if num is positive, or the lengthof the two’s complement if num is negative, provided that width isat least a sufficient number of bits for num to be represented inthe designated form. If the width value is insufficient, an error israised.'}]}, {'Returns': [{'name': 'bin', 'type': 'str', 'description': 'Binary representation of num or two’s complement of num.'}]}]",">>> import numpy as np
>>> np.binary_repr(3)
'11'
>>> np.binary_repr(-3)
'-11'
>>> np.binary_repr(3, width=4)
'0011'
>>> np.binary_repr(-3, width=3)
'101'
>>> np.binary_repr(-3, width=5)
'11101'"
numpy.ptp,Range of values (maximum - minimum) along an axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis along which to find the peaks.  By default, flatten thearray.  axis may be negative, inwhich case it counts from the last to the first axis.If this is a tuple of ints, a reduction is performed on multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'array_like', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected output,but the type of the output values will be cast if necessary.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the ptp method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}]}, {'Returns': [{'name': 'ptp', 'type': 'ndarray or scalar', 'description': 'The range of a given array - scalar if array is one-dimensionalor a new array holding the result along the given axis'}]}]",">>> import numpy as np
>>> x = np.array([[4, 9, 2, 10],
...               [6, 9, 7, 12]])
>>> np.ptp(x, axis=1)
array([8, 6])
>>> np.ptp(x, axis=0)
array([2, 0, 5, 2])
>>> np.ptp(x)
10
>>> y = np.array([[1, 127],
...               [0, 127],
...               [-1, 127],
...               [-2, 127]], dtype=np.int8)
>>> np.ptp(y, axis=1)
array([ 126,  127, -128, -127], dtype=int8)
>>> np.ptp(y, axis=1).view(np.uint8)
array([126, 127, 128, 129], dtype=uint8)"
numpy.percentile,Compute the q-th percentile of the data along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like of real numbers', 'description': 'Input array or object that can be converted to an array.'}, {'name': 'q', 'type': 'array_like of float', 'description': 'Percentage or sequence of percentages for the percentiles to compute.Values must be between 0 and 100 inclusive.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the percentiles are computed. Thedefault is to compute the percentile(s) along a flattenedversion of the array.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected output,but the type (of the output) will be cast if necessary.'}, {'name': 'overwrite_input', 'type': 'bool, optional', 'description': 'If True, then allow the input array a to be modified by intermediatecalculations, to save memory. In this case, the contents of the inputa after this function completes is undefined.'}, {'name': 'method', 'type': 'str, optional', 'description': 'This parameter specifies the method to use for estimating thepercentile.  There are many different methods, some unique to NumPy.See the notes for explanation.  The options sorted by their R typeas summarized in the H&F paper [1] are:‘inverted_cdf’‘averaged_inverted_cdf’‘closest_observation’‘interpolated_inverted_cdf’‘hazen’‘weibull’‘linear’  (default)‘median_unbiased’‘normal_unbiased’The first three methods are discontinuous.  NumPy further defines thefollowing discontinuous variations of the default ‘linear’ (7.) option:‘lower’‘higher’,‘midpoint’‘nearest’Changed in version 1.22.0: This argument was previously called “interpolation” and onlyoffered the “linear” default and last four options.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are left inthe result as dimensions with size one. With this option, theresult will broadcast correctly against the original array a.weightsarray_like, optionalAn array of weights associated with the values in a. Each value ina contributes to the percentile according to its associated weight.The weights array can either be 1-D (in which case its length must bethe size of a along the given axis) or of the same shape as a.If weights=None, then all data in a are assumed to have aweight equal to one.Only method=”inverted_cdf” supports weights.See the notes for more details.New in version 2.0.0.'}, {'name': 'weightsarray_like, optional', 'type': 'array_like, optional', 'description': 'An array of weights associated with the values in a. Each value ina contributes to the percentile according to its associated weight.The weights array can either be 1-D (in which case its length must bethe size of a along the given axis) or of the same shape as a.If weights=None, then all data in a are assumed to have aweight equal to one.Only method=”inverted_cdf” supports weights.See the notes for more details.New in version 2.0.0.'}, {'name': 'interpolation', 'type': 'str, optional', 'description': 'Deprecated name for the method keyword argument.Deprecated since version 1.22.0.'}]}, {'Returns': [{'name': 'percentile', 'type': 'scalar or ndarray', 'description': 'If q is a single percentile and axis=None, then the resultis a scalar. If multiple percentiles are given, first axis ofthe result corresponds to the percentiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.'}]}]",">>> import numpy as np
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.percentile(a, 50)
3.5
>>> np.percentile(a, 50, axis=0)
array([6.5, 4.5, 2.5])
>>> np.percentile(a, 50, axis=1)
array([7.,  2.])
>>> np.percentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.percentile(a, 50, axis=0)
>>> out = np.zeros_like(m)
>>> np.percentile(a, 50, axis=0, out=out)
array([6.5, 4.5, 2.5])
>>> m
array([6.5, 4.5, 2.5])
>>> b = a.copy()
>>> np.percentile(b, 50, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a == b)"
numpy.nanpercentile,"Compute the qth percentile of the data along the specified axis,
while ignoring nan values.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array or object that can be converted to an array, containingnan values to be ignored.'}, {'name': 'q', 'type': 'array_like of float', 'description': 'Percentile or sequence of percentiles to compute, which must bebetween 0 and 100 inclusive.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the percentiles are computed. The defaultis to compute the percentile(s) along a flattened version of thearray.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It must havethe same shape and buffer length as the expected output, but thetype (of the output) will be cast if necessary.'}, {'name': 'overwrite_input', 'type': 'bool, optional', 'description': 'If True, then allow the input array a to be modified byintermediate calculations, to save memory. In this case, thecontents of the input a after this function completes isundefined.'}, {'name': 'method', 'type': 'str, optional', 'description': 'This parameter specifies the method to use for estimating thepercentile.  There are many different methods, some unique to NumPy.See the notes for explanation.  The options sorted by their R typeas summarized in the H&F paper [1] are:‘inverted_cdf’‘averaged_inverted_cdf’‘closest_observation’‘interpolated_inverted_cdf’‘hazen’‘weibull’‘linear’  (default)‘median_unbiased’‘normal_unbiased’The first three methods are discontinuous.  NumPy further defines thefollowing discontinuous variations of the default ‘linear’ (7.) option:‘lower’‘higher’,‘midpoint’‘nearest’Changed in version 1.22.0: This argument was previously called “interpolation” and onlyoffered the “linear” default and last four options.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are left inthe result as dimensions with size one. With this option, theresult will broadcast correctly against the original array a.If this is anything but the default value it will be passedthrough (in the special case of an empty array) to themean function of the underlying array.  If the array isa sub-class and mean does not have the kwarg keepdims thiswill raise a RuntimeError.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'An array of weights associated with the values in a. Each value ina contributes to the percentile according to its associated weight.The weights array can either be 1-D (in which case its length must bethe size of a along the given axis) or of the same shape as a.If weights=None, then all data in a are assumed to have aweight equal to one.Only method=”inverted_cdf” supports weights.New in version 2.0.0.'}, {'name': 'interpolation', 'type': 'str, optional', 'description': 'Deprecated name for the method keyword argument.Deprecated since version 1.22.0.'}]}, {'Returns': [{'name': 'percentile', 'type': 'scalar or ndarray', 'description': 'If q is a single percentile and axis=None, then the resultis a scalar. If multiple percentiles are given, first axis ofthe result corresponds to the percentiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.'}]}]",">>> import numpy as np
>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
>>> a[0][1] = np.nan
>>> a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
>>> np.percentile(a, 50)
np.float64(nan)
>>> np.nanpercentile(a, 50)
3.0
>>> np.nanpercentile(a, 50, axis=0)
array([6.5, 2. , 2.5])
>>> np.nanpercentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.nanpercentile(a, 50, axis=0)
>>> out = np.zeros_like(m)
>>> np.nanpercentile(a, 50, axis=0, out=out)
array([6.5, 2. , 2.5])
>>> m
array([6.5,  2. ,  2.5])
>>> b = a.copy()
>>> np.nanpercentile(b, 50, axis=1, overwrite_input=True)
array([7., 2.])
>>> assert not np.all(a==b)"
numpy.quantile,Compute the q-th quantile of the data along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like of real numbers', 'description': 'Input array or object that can be converted to an array.'}, {'name': 'q', 'type': 'array_like of float', 'description': 'Probability or sequence of probabilities of the quantiles to compute.Values must be between 0 and 1 inclusive.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the quantiles are computed. The default isto compute the quantile(s) along a flattened version of the array.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It must havethe same shape and buffer length as the expected output, but thetype (of the output) will be cast if necessary.'}, {'name': 'overwrite_input', 'type': 'bool, optional', 'description': 'If True, then allow the input array a to be modified byintermediate calculations, to save memory. In this case, thecontents of the input a after this function completes isundefined.'}, {'name': 'method', 'type': 'str, optional', 'description': 'This parameter specifies the method to use for estimating thequantile.  There are many different methods, some unique to NumPy.The recommended options, numbered as they appear in [1], are:‘inverted_cdf’‘averaged_inverted_cdf’‘closest_observation’‘interpolated_inverted_cdf’‘hazen’‘weibull’‘linear’  (default)‘median_unbiased’‘normal_unbiased’The first three methods are discontinuous. For backward compatibilitywith previous versions of NumPy, the following discontinuous variationsof the default ‘linear’ (7.) option are available:‘lower’‘higher’,‘midpoint’‘nearest’See Notes for details.Changed in version 1.22.0: This argument was previously called “interpolation” and onlyoffered the “linear” default and last four options.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are left inthe result as dimensions with size one. With this option, theresult will broadcast correctly against the original array a.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'An array of weights associated with the values in a. Each value ina contributes to the quantile according to its associated weight.The weights array can either be 1-D (in which case its length must bethe size of a along the given axis) or of the same shape as a.If weights=None, then all data in a are assumed to have aweight equal to one.Only method=”inverted_cdf” supports weights.See the notes for more details.New in version 2.0.0.'}, {'name': 'interpolation', 'type': 'str, optional', 'description': 'Deprecated name for the method keyword argument.Deprecated since version 1.22.0.'}]}, {'Returns': [{'name': 'quantile', 'type': 'scalar or ndarray', 'description': 'If q is a single probability and axis=None, then the resultis a scalar. If multiple probability levels are given, first axisof the result corresponds to the quantiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.'}]}]",">>> import numpy as np
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.quantile(a, 0.5)
3.5
>>> np.quantile(a, 0.5, axis=0)
array([6.5, 4.5, 2.5])
>>> np.quantile(a, 0.5, axis=1)
array([7.,  2.])
>>> np.quantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.quantile(a, 0.5, axis=0)
>>> out = np.zeros_like(m)
>>> np.quantile(a, 0.5, axis=0, out=out)
array([6.5, 4.5, 2.5])
>>> m
array([6.5, 4.5, 2.5])
>>> b = a.copy()
>>> np.quantile(b, 0.5, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a == b)"
numpy.nanquantile,"Compute the qth quantile of the data along the specified axis,
while ignoring nan values.
Returns the qth quantile(s) of the array elements.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array or object that can be converted to an array, containingnan values to be ignored'}, {'name': 'q', 'type': 'array_like of float', 'description': 'Probability or sequence of probabilities for the quantiles to compute.Values must be between 0 and 1 inclusive.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the quantiles are computed. Thedefault is to compute the quantile(s) along a flattenedversion of the array.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected output,but the type (of the output) will be cast if necessary.'}, {'name': 'overwrite_input', 'type': 'bool, optional', 'description': 'If True, then allow the input array a to be modified by intermediatecalculations, to save memory. In this case, the contents of the inputa after this function completes is undefined.'}, {'name': 'method', 'type': 'str, optional', 'description': 'This parameter specifies the method to use for estimating thequantile.  There are many different methods, some unique to NumPy.See the notes for explanation.  The options sorted by their R typeas summarized in the H&F paper [1] are:‘inverted_cdf’‘averaged_inverted_cdf’‘closest_observation’‘interpolated_inverted_cdf’‘hazen’‘weibull’‘linear’  (default)‘median_unbiased’‘normal_unbiased’The first three methods are discontinuous.  NumPy further defines thefollowing discontinuous variations of the default ‘linear’ (7.) option:‘lower’‘higher’,‘midpoint’‘nearest’Changed in version 1.22.0: This argument was previously called “interpolation” and onlyoffered the “linear” default and last four options.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are left inthe result as dimensions with size one. With this option, theresult will broadcast correctly against the original array a.If this is anything but the default value it will be passedthrough (in the special case of an empty array) to themean function of the underlying array.  If the array isa sub-class and mean does not have the kwarg keepdims thiswill raise a RuntimeError.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'An array of weights associated with the values in a. Each value ina contributes to the quantile according to its associated weight.The weights array can either be 1-D (in which case its length must bethe size of a along the given axis) or of the same shape as a.If weights=None, then all data in a are assumed to have aweight equal to one.Only method=”inverted_cdf” supports weights.New in version 2.0.0.'}, {'name': 'interpolation', 'type': 'str, optional', 'description': 'Deprecated name for the method keyword argument.Deprecated since version 1.22.0.'}]}, {'Returns': [{'name': 'quantile', 'type': 'scalar or ndarray', 'description': 'If q is a single probability and axis=None, then the resultis a scalar. If multiple probability levels are given, first axis ofthe result corresponds to the quantiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.'}]}]",">>> import numpy as np
>>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
>>> a[0][1] = np.nan
>>> a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
>>> np.quantile(a, 0.5)
np.float64(nan)
>>> np.nanquantile(a, 0.5)
3.0
>>> np.nanquantile(a, 0.5, axis=0)
array([6.5, 2. , 2.5])
>>> np.nanquantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.nanquantile(a, 0.5, axis=0)
>>> out = np.zeros_like(m)
>>> np.nanquantile(a, 0.5, axis=0, out=out)
array([6.5, 2. , 2.5])
>>> m
array([6.5,  2. ,  2.5])
>>> b = a.copy()
>>> np.nanquantile(b, 0.5, axis=1, overwrite_input=True)
array([7., 2.])
>>> assert not np.all(a==b)"
numpy.median,Compute the median along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array or object that can be converted to an array.'}, {'name': 'axis', 'type': '{int, sequence of int, None}, optional', 'description': 'Axis or axes along which the medians are computed. The default,axis=None, will compute the median along a flattened version ofthe array. If a sequence of axes, the array is first flattenedalong the given axes, then the median is computed along theresulting flattened axis.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected output,but the type (of the output) will be cast if necessary.'}, {'name': 'overwrite_input', 'type': 'bool, optional', 'description': 'If True, then allow use of memory of input array a forcalculations. The input array will be modified by the call tomedian. This will save memory when you do not need to preservethe contents of the input array. Treat the input as undefined,but it will probably be fully or partially sorted. Default isFalse. If overwrite_input is True and a is not already anndarray, an error will be raised.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original arr.'}]}, {'Returns': [{'name': 'median', 'type': 'ndarray', 'description': 'A new array holding the result. If the input contains integersor floats smaller than float64, then the output data-type isnp.float64.  Otherwise, the data-type of the output is thesame as that of the input. If out is specified, that array isreturned instead.'}]}]",">>> import numpy as np
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.median(a)
np.float64(3.5)
>>> np.median(a, axis=0)
array([6.5, 4.5, 2.5])
>>> np.median(a, axis=1)
array([7.,  2.])
>>> np.median(a, axis=(0, 1))
np.float64(3.5)
>>> m = np.median(a, axis=0)
>>> out = np.zeros_like(m)
>>> np.median(a, axis=0, out=m)
array([6.5,  4.5,  2.5])
>>> m
array([6.5,  4.5,  2.5])
>>> b = a.copy()
>>> np.median(b, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a==b)
>>> b = a.copy()
>>> np.median(b, axis=None, overwrite_input=True)
np.float64(3.5)
>>> assert not np.all(a==b)"
numpy.average,Compute the weighted average along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing data to be averaged. If a is not an array, aconversion is attempted.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which to average a.  The default,axis=None, will average over all of the elements of the input array.If axis is negative it counts from the last to the first axis.If axis is a tuple of ints, averaging is performed on all of the axesspecified in the tuple instead of a single axis or all the axes asbefore.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'An array of weights associated with the values in a. Each value ina contributes to the average according to its associated weight.The array of weights must be the same shape as a if no axis isspecified, otherwise the weights must have dimensions and shapeconsistent with a along the specified axis.If weights=None, then all data in a are assumed to have aweight equal to one.The calculation is:avg = sum(a * weights) / sum(weights)where the sum is over all included elements.The only constraint on the values of weights is that sum(weights)must not be 0.'}, {'name': 'returned', 'type': 'bool, optional', 'description': 'Default is False. If True, the tuple (average, sum_of_weights)is returned, otherwise only the average is returned.If weights=None, sum_of_weights is equivalent to the number ofelements over which the average is taken.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.Note: keepdims will not work with instances of numpy.matrixor other classes whose methods do not support keepdims.New in version 1.23.0.'}]}, {'Returns': [{'name': 'retval, [sum_of_weights]', 'type': 'array_type or double', 'description': 'Return the average along the specified axis. When returned is True,return a tuple with the average as the first element and the sumof the weights as the second element. sum_of_weights is of thesame type as retval. The result dtype follows a general pattern.If weights is None, the result dtype will be that of a , or float64if a is integral. Otherwise, if weights is not None and a is non-integral, the result type will be the type of lowest precision capable ofrepresenting values of both a and weights. If a happens to beintegral, the previous rules still applies but the result dtype willat least be float64.'}]}, {'Raises': [{'name': 'ZeroDivisionError', 'type': None, 'description': 'When all weights along axis are zero. See numpy.ma.average for aversion robust to this type of error.'}, {'name': 'TypeError', 'type': None, 'description': 'When weights does not have the same shape as a, and axis=None.'}, {'name': 'ValueError', 'type': None, 'description': 'When weights does not have dimensions and shape consistent with aalong specified axis.'}]}]",">>> import numpy as np
>>> data = np.arange(1, 5)
>>> data
array([1, 2, 3, 4])
>>> np.average(data)
2.5
>>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))
4.0
>>> data = np.arange(6).reshape((3, 2))
>>> data
array([[0, 1],
       [2, 3],
       [4, 5]])
>>> np.average(data, axis=1, weights=[1./4, 3./4])
array([0.75, 2.75, 4.75])
>>> np.average(data, weights=[1./4, 3./4])
Traceback (most recent call last):
    ...
TypeError: Axis must be specified when shapes of a and weights differ.
>>> np.average(data, axis=1, keepdims=True)
array([[0.5],
       [2.5],
       [4.5]])
>>> data = np.arange(8).reshape((2, 2, 2))
>>> data
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> np.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])
array([3.4, 4.4])
>>> np.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])
Traceback (most recent call last):
    ...
ValueError: Shape of weights must be consistent
with shape of a along specified axis."
numpy.mean,Compute the arithmetic mean along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose mean is desired. If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which the means are computed. The default is tocompute the mean of the flattened array.If this is a tuple of ints, a mean is performed over multiple axes,instead of a single axis or all the axes as before.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Type to use in computing the mean.  For integer inputs, the defaultis float64; for floating point inputs, it is the same as theinput dtype.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  The defaultis None; if provided, it must have the same shape as theexpected output, but the type will be cast if necessary.See Output type determination for more details.See Output type determination for more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the mean method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the mean. See reduce for details.New in version 1.20.0.'}]}, {'Returns': [{'name': 'm', 'type': 'ndarray, see dtype parameter above', 'description': 'If out=None, returns a new array containing the mean values,otherwise a reference to the output array is returned.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> np.mean(a)
2.5
>>> np.mean(a, axis=0)
array([2., 3.])
>>> np.mean(a, axis=1)
array([1.5, 3.5])
>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.mean(a)
np.float32(0.54999924)
>>> np.mean(a, dtype=np.float64)
0.55000000074505806 # may vary
>>> b = np.array([1, 3], dtype=""timedelta64[D]"")
>>> np.mean(b)
np.timedelta64(2,'D')
>>> a = np.array([[5, 9, 13], [14, 10, 12], [11, 15, 19]])
>>> np.mean(a)
12.0
>>> np.mean(a, where=[[True], [False], [False]])
9.0"
numpy.std,Compute the standard deviation along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Calculate the standard deviation of these values.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which the standard deviation is computed. Thedefault is to compute the standard deviation of the flattened array.If this is a tuple of ints, a standard deviation is performed overmultiple axes, instead of a single axis or all the axes as before.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type to use in computing the standard deviation. For arrays ofinteger type the default is float64, for arrays of float types it isthe same as the array type.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It must havethe same shape as the expected output but the type (of the calculatedvalues) will be cast if necessary.See Output type determination for more details.'}, {'name': 'ddof', 'type': '{int, float}, optional', 'description': 'Means Delta Degrees of Freedom.  The divisor used in calculationsis N - ddof, where N represents the number of elements.By default ddof is zero. See Notes for details about use of ddof.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the std method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the standard deviation.See reduce for details.New in version 1.20.0.'}, {'name': 'mean', 'type': 'array_like, optional', 'description': 'Provide the mean to prevent its recalculation. The mean should havea shape as if it was calculated with keepdims=True.The axis for the calculation of the mean should be the same as used inthe call to this std function.New in version 2.0.0.'}, {'name': 'correction', 'type': '{int, float}, optional', 'description': 'Array API compatible name for the ddof parameter. Only one of themcan be provided at the same time.New in version 2.0.0.'}]}, {'Returns': [{'name': 'standard_deviation', 'type': 'ndarray, see dtype parameter above.', 'description': 'If out is None, return a new array containing the standard deviation,otherwise return a reference to the output array.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> np.std(a)
1.1180339887498949 # may vary
>>> np.std(a, axis=0)
array([1.,  1.])
>>> np.std(a, axis=1)
array([0.5,  0.5])
>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.std(a)
np.float32(0.45000005)
>>> np.std(a, dtype=np.float64)
0.44999999925494177 # may vary
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> np.std(a)
2.614064523559687 # may vary
>>> np.std(a, where=[[True], [True], [False]])
2.0
>>> import numpy as np
>>> from timeit import timeit
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> mean = np.mean(a, axis=1, keepdims=True)
>>>
>>> g = globals()
>>> n = 10000
>>> t1 = timeit(""std = np.std(a, axis=1, mean=mean)"", globals=g, number=n)
>>> t2 = timeit(""std = np.std(a, axis=1)"", globals=g, number=n)
>>> print(f'Percentage execution time saved {100*(t2-t1)/t2:.0f}%')

Percentage execution time saved 30%"
numpy.var,Compute the variance along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose variance is desired.  If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which the variance is computed.  The default is tocompute the variance of the flattened array.If this is a tuple of ints, a variance is performed over multiple axes,instead of a single axis or all the axes as before.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Type to use in computing the variance.  For arrays of integer typethe default is float64; for arrays of float types it is the same asthe array type.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  It must havethe same shape as the expected output, but the type is cast ifnecessary.'}, {'name': 'ddof', 'type': '{int, float}, optional', 'description': '“Delta Degrees of Freedom”: the divisor used in the calculation isN - ddof, where N represents the number of elements. Bydefault ddof is zero. See notes for details about use of ddof.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the var method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the variance. See reduce fordetails.New in version 1.20.0.'}, {'name': 'mean', 'type': 'array like, optional', 'description': 'Provide the mean to prevent its recalculation. The mean should havea shape as if it was calculated with keepdims=True.The axis for the calculation of the mean should be the same as used inthe call to this var function.New in version 2.0.0.'}, {'name': 'correction', 'type': '{int, float}, optional', 'description': 'Array API compatible name for the ddof parameter. Only one of themcan be provided at the same time.New in version 2.0.0.'}]}, {'Returns': [{'name': 'variance', 'type': 'ndarray, see dtype parameter above', 'description': 'If out=None, returns a new array containing the variance;otherwise, a reference to the output array is returned.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])
>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
np.float32(0.20250003)
>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> np.var(a)
6.833333333333333 # may vary
>>> np.var(a, where=[[True], [True], [False]])
4.0
>>> import numpy as np
>>> from timeit import timeit
>>>
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> mean = np.mean(a, axis=1, keepdims=True)
>>>
>>> g = globals()
>>> n = 10000
>>> t1 = timeit(""var = np.var(a, axis=1, mean=mean)"", globals=g, number=n)
>>> t2 = timeit(""var = np.var(a, axis=1)"", globals=g, number=n)
>>> print(f'Percentage execution time saved {100*(t2-t1)/t2:.0f}%')

Percentage execution time saved 32%"
numpy.nanmedian,"Compute the median along the specified axis, while ignoring NaNs.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array or object that can be converted to an array.'}, {'name': 'axis', 'type': '{int, sequence of int, None}, optional', 'description': 'Axis or axes along which the medians are computed. The defaultis to compute the median along a flattened version of the array.A sequence of axes is supported since version 1.9.0.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected output,but the type (of the output) will be cast if necessary.'}, {'name': 'overwrite_input', 'type': 'bool, optional', 'description': 'If True, then allow use of memory of input array a forcalculations. The input array will be modified by the call tomedian. This will save memory when you do not need to preservethe contents of the input array. Treat the input as undefined,but it will probably be fully or partially sorted. Default isFalse. If overwrite_input is True and a is not already anndarray, an error will be raised.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.If this is anything but the default value it will be passedthrough (in the special case of an empty array) to themean function of the underlying array.  If the array isa sub-class and mean does not have the kwarg keepdims thiswill raise a RuntimeError.'}]}, {'Returns': [{'name': 'median', 'type': 'ndarray', 'description': 'A new array holding the result. If the input contains integersor floats smaller than float64, then the output data-type isnp.float64.  Otherwise, the data-type of the output is thesame as that of the input. If out is specified, that array isreturned instead.'}]}]",">>> import numpy as np
>>> a = np.array([[10.0, 7, 4], [3, 2, 1]])
>>> a[0, 1] = np.nan
>>> a
array([[10., nan,  4.],
       [ 3.,  2.,  1.]])
>>> np.median(a)
np.float64(nan)
>>> np.nanmedian(a)
3.0
>>> np.nanmedian(a, axis=0)
array([6.5, 2. , 2.5])
>>> np.median(a, axis=1)
array([nan,  2.])
>>> b = a.copy()
>>> np.nanmedian(b, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a==b)
>>> b = a.copy()
>>> np.nanmedian(b, axis=None, overwrite_input=True)
3.0
>>> assert not np.all(a==b)"
numpy.nanmean,"Compute the arithmetic mean along the specified axis, ignoring NaNs.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose mean is desired. If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the means are computed. The default is to computethe mean of the flattened array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Type to use in computing the mean.  For integer inputs, the defaultis float64; for inexact inputs, it is the same as the inputdtype.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  The defaultis None; if provided, it must have the same shape as theexpected output, but the type will be cast if necessary.See Output type determination for more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.If the value is anything but the default, thenkeepdims will be passed through to the mean or sum methodsof sub-classes of ndarray.  If the sub-classes methodsdoes not implement keepdims any exceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the mean. See reduce for details.New in version 1.22.0.'}]}, {'Returns': [{'name': 'm', 'type': 'ndarray, see dtype parameter above', 'description': 'If out=None, returns a new array containing the mean values,otherwise a reference to the output array is returned. Nan isreturned for slices that contain only NaNs.'}]}]",">>> import numpy as np
>>> a = np.array([[1, np.nan], [3, 4]])
>>> np.nanmean(a)
2.6666666666666665
>>> np.nanmean(a, axis=0)
array([2.,  4.])
>>> np.nanmean(a, axis=1)
array([1.,  3.5]) # may vary"
numpy.nanstd,"Compute the standard deviation along the specified axis, while
ignoring NaNs.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Calculate the standard deviation of the non-NaN values.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the standard deviation is computed. The default isto compute the standard deviation of the flattened array.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type to use in computing the standard deviation. For arrays ofinteger type the default is float64, for arrays of float types itis the same as the array type.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It must havethe same shape as the expected output but the type (of thecalculated values) will be cast if necessary.'}, {'name': 'ddof', 'type': '{int, float}, optional', 'description': 'Means Delta Degrees of Freedom.  The divisor used in calculationsis N - ddof, where N represents the number of non-NaNelements.  By default ddof is zero.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.If this value is anything but the default it is passed throughas-is to the relevant functions of the sub-classes.  If thesefunctions do not have a keepdims kwarg, a RuntimeError willbe raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the standard deviation.See reduce for details.New in version 1.22.0.'}, {'name': 'mean', 'type': 'array_like, optional', 'description': 'Provide the mean to prevent its recalculation. The mean should havea shape as if it was calculated with keepdims=True.The axis for the calculation of the mean should be the same as used inthe call to this std function.New in version 2.0.0.'}, {'name': 'correction', 'type': '{int, float}, optional', 'description': 'Array API compatible name for the ddof parameter. Only one of themcan be provided at the same time.New in version 2.0.0.'}]}, {'Returns': [{'name': 'standard_deviation', 'type': 'ndarray, see dtype parameter above.', 'description': 'If out is None, return a new array containing the standarddeviation, otherwise return a reference to the output array. Ifddof is >= the number of non-NaN elements in a slice or the slicecontains only NaNs, then the result for that slice is NaN.'}]}]",">>> import numpy as np
>>> a = np.array([[1, np.nan], [3, 4]])
>>> np.nanstd(a)
1.247219128924647
>>> np.nanstd(a, axis=0)
array([1., 0.])
>>> np.nanstd(a, axis=1)
array([0.,  0.5]) # may vary"
numpy.nanvar,"Compute the variance along the specified axis, while ignoring NaNs.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose variance is desired.  If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the variance is computed.  The default is to computethe variance of the flattened array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Type to use in computing the variance.  For arrays of integer typethe default is float64; for arrays of float types it is the same asthe array type.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  It must havethe same shape as the expected output, but the type is cast ifnecessary.'}, {'name': 'ddof', 'type': '{int, float}, optional', 'description': '“Delta Degrees of Freedom”: the divisor used in the calculation isN - ddof, where N represents the number of non-NaNelements. By default ddof is zero.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the variance. See reduce fordetails.New in version 1.22.0.'}, {'name': 'mean', 'type': 'array_like, optional', 'description': 'Provide the mean to prevent its recalculation. The mean should havea shape as if it was calculated with keepdims=True.The axis for the calculation of the mean should be the same as used inthe call to this var function.New in version 2.0.0.'}, {'name': 'correction', 'type': '{int, float}, optional', 'description': 'Array API compatible name for the ddof parameter. Only one of themcan be provided at the same time.New in version 2.0.0.'}]}, {'Returns': [{'name': 'variance', 'type': 'ndarray, see dtype parameter above', 'description': 'If out is None, return a new array containing the variance,otherwise return a reference to the output array. If ddof is >= thenumber of non-NaN elements in a slice or the slice contains onlyNaNs, then the result for that slice is NaN.'}]}]",">>> import numpy as np
>>> a = np.array([[1, np.nan], [3, 4]])
>>> np.nanvar(a)
1.5555555555555554
>>> np.nanvar(a, axis=0)
array([1.,  0.])
>>> np.nanvar(a, axis=1)
array([0.,  0.25])  # may vary"
numpy.corrcoef,Return Pearson product-moment correlation coefficients.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'A 1-D or 2-D array containing multiple variables and observations.Each row of x represents a variable, and each column a singleobservation of all those variables. Also see rowvar below.'}, {'name': 'y', 'type': 'array_like, optional', 'description': 'An additional set of variables and observations. y has the sameshape as x.'}, {'name': 'rowvar', 'type': 'bool, optional', 'description': 'If rowvar is True (default), then each row represents avariable, with observations in the columns. Otherwise, the relationshipis transposed: each column represents a variable, while the rowscontain observations.'}, {'name': 'bias', 'type': '_NoValue, optional', 'description': 'Has no effect, do not use.Deprecated since version 1.10.0.'}, {'name': 'ddof', 'type': '_NoValue, optional', 'description': 'Has no effect, do not use.Deprecated since version 1.10.0.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the result. By default, the return data-type will haveat least numpy.float64 precision.New in version 1.20.'}]}, {'Returns': [{'name': 'R', 'type': 'ndarray', 'description': 'The correlation coefficient matrix of the variables.'}]}]",">>> import numpy as np
>>> import numpy as np
>>> rng = np.random.default_rng(seed=42)
>>> xarr = rng.random((3, 3))
>>> xarr
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
>>> R1 = np.corrcoef(xarr)
>>> R1
array([[ 1.        ,  0.99256089, -0.68080986],
       [ 0.99256089,  1.        , -0.76492172],
       [-0.68080986, -0.76492172,  1.        ]])
>>> yarr = rng.random((3, 3))
>>> yarr
array([[0.45038594, 0.37079802, 0.92676499],
       [0.64386512, 0.82276161, 0.4434142 ],
       [0.22723872, 0.55458479, 0.06381726]])
>>> R2 = np.corrcoef(xarr, yarr)
>>> R2
array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,
        -0.99004057],
       [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,
        -0.99981569],
       [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,
         0.77714685],
       [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,
        -0.83571711],
       [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,
         0.97517215],
       [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,
         1.        ]])
>>> R3 = np.corrcoef(xarr, yarr, rowvar=False)
>>> R3
array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,
         0.22423734],
       [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,
        -0.44069024],
       [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,
         0.75137473],
       [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,
         0.47536961],
       [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,
        -0.46666491],
       [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,
         1.        ]])"
numpy.correlate,Cross-correlation of two 1-dimensional sequences.,"[{'Parameters': [{'name': 'a, v', 'type': 'array_like', 'description': 'Input sequences.'}, {'name': 'mode', 'type': '{‘valid’, ‘same’, ‘full’}, optional', 'description': 'Refer to the convolve docstring.  Note that the defaultis ‘valid’, unlike convolve, which uses ‘full’.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Discrete cross-correlation of a and v.'}]}]",">>> import numpy as np
>>> np.correlate([1, 2, 3], [0, 1, 0.5])
array([3.5])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], ""same"")
array([2. ,  3.5,  3. ])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], ""full"")
array([0.5,  2. ,  3.5,  3. ,  0. ])
>>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])
>>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])"
numpy.cov,"Estimate a covariance matrix, given data and weights.","[{'Parameters': [{'name': 'm', 'type': 'array_like', 'description': 'A 1-D or 2-D array containing multiple variables and observations.Each row of m represents a variable, and each column a singleobservation of all those variables. Also see rowvar below.'}, {'name': 'y', 'type': 'array_like, optional', 'description': 'An additional set of variables and observations. y has the same formas that of m.'}, {'name': 'rowvar', 'type': 'bool, optional', 'description': 'If rowvar is True (default), then each row represents avariable, with observations in the columns. Otherwise, the relationshipis transposed: each column represents a variable, while the rowscontain observations.'}, {'name': 'bias', 'type': 'bool, optional', 'description': 'Default normalization (False) is by (N - 1), where N is thenumber of observations given (unbiased estimate). If bias is True,then normalization is by N. These values can be overridden by usingthe keyword ddof in numpy versions >= 1.5.'}, {'name': 'ddof', 'type': 'int, optional', 'description': 'If not None the default value implied by bias is overridden.Note that ddof=1 will return the unbiased estimate, even if bothfweights and aweights are specified, and ddof=0 will returnthe simple average. See the notes for the details. The default valueis None.'}, {'name': 'fweights', 'type': 'array_like, int, optional', 'description': '1-D array of integer frequency weights; the number of times eachobservation vector should be repeated.'}, {'name': 'aweights', 'type': 'array_like, optional', 'description': '1-D array of observation vector weights. These relative weights aretypically large for observations considered “important” and smaller forobservations considered less “important”. If ddof=0 the array ofweights can be used to assign probabilities to observation vectors.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the result. By default, the return data-type will haveat least numpy.float64 precision.New in version 1.20.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The covariance matrix of the variables.'}]}]",">>> import numpy as np
>>> x = np.array([[0, 2], [1, 1], [2, 0]]).T
>>> x
array([[0, 1, 2],
       [2, 1, 0]])
>>> np.cov(x)
array([[ 1., -1.],
       [-1.,  1.]])
>>> x = [-2.1, -1,  4.3]
>>> y = [3,  1.1,  0.12]
>>> X = np.stack((x, y), axis=0)
>>> np.cov(X)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
>>> np.cov(x, y)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
>>> np.cov(x)
array(11.71)"
numpy.histogram,Compute the histogram of a dataset.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data. The histogram is computed over the flattened array.'}, {'name': 'bins', 'type': 'int or sequence of scalars or str, optional', 'description': 'If bins is an int, it defines the number of equal-widthbins in the given range (10, by default). If bins is asequence, it defines a monotonically increasing array of bin edges,including the rightmost edge, allowing for non-uniform bin widths.If bins is a string, it defines the method used to calculate theoptimal bin width, as defined by histogram_bin_edges.'}, {'name': 'range', 'type': '(float, float), optional', 'description': 'The lower and upper range of the bins.  If not provided, rangeis simply (a.min(), a.max()).  Values outside the range areignored. The first element of the range must be less than orequal to the second. range affects the automatic bincomputation as well. While bin width is computed to be optimalbased on the actual data within range, the bin count will fillthe entire range including portions containing no data.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'An array of weights, of the same shape as a.  Each value ina only contributes its associated weight towards the bin count(instead of 1). If density is True, the weights arenormalized, so that the integral of the density over the rangeremains 1.Please note that the dtype of weights will also become thedtype of the returned accumulator (hist), so it must belarge enough to hold accumulated values as well.'}, {'name': 'density', 'type': 'bool, optional', 'description': 'If False, the result will contain the number of samples ineach bin. If True, the result is the value of theprobability density function at the bin, normalized such thatthe integral over the range is 1. Note that the sum of thehistogram values will not be equal to 1 unless bins of unitywidth are chosen; it is not a probability mass function.'}]}, {'Returns': [{'name': 'hist', 'type': 'array', 'description': 'The values of the histogram. See density and weights for adescription of the possible semantics.  If weights are given,hist.dtype will be taken from weights.'}, {'name': 'bin_edges', 'type': 'array of dtype float', 'description': 'Return the bin edges (length(hist)+1).'}]}]",">>> import numpy as np
>>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])
(array([0, 2, 1]), array([0, 1, 2, 3]))
>>> np.histogram(np.arange(4), bins=np.arange(5), density=True)
(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))
>>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
(array([1, 4, 1]), array([0, 1, 2, 3]))
>>> a = np.arange(5)
>>> hist, bin_edges = np.histogram(a, density=True)
>>> hist
array([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])
>>> hist.sum()
2.4999999999999996
>>> np.sum(hist * np.diff(bin_edges))
1.0"
numpy.histogram2d,Compute the bi-dimensional histogram of two data samples.,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (N,)', 'description': 'An array containing the x coordinates of the points to behistogrammed.'}, {'name': 'y', 'type': 'array_like, shape (N,)', 'description': 'An array containing the y coordinates of the points to behistogrammed.'}, {'name': 'bins', 'type': 'int or array_like or [int, int] or [array, array], optional', 'description': 'The bin specification:If int, the number of bins for the two dimensions (nx=ny=bins).If array_like, the bin edges for the two dimensions(x_edges=y_edges=bins).If [int, int], the number of bins in each dimension(nx, ny = bins).If [array, array], the bin edges in each dimension(x_edges, y_edges = bins).A combination [int, array] or [array, int], where intis the number of bins and array is the bin edges.'}, {'name': 'range', 'type': 'array_like, shape(2,2), optional', 'description': 'The leftmost and rightmost edges of the bins along each dimension(if not specified explicitly in the bins parameters):[[xmin, xmax], [ymin, ymax]]. All values outside of this rangewill be considered outliers and not tallied in the histogram.'}, {'name': 'density', 'type': 'bool, optional', 'description': 'If False, the default, returns the number of samples in each bin.If True, returns the probability density function at the bin,bin_count / sample_count / bin_area.'}, {'name': 'weights', 'type': 'array_like, shape(N,), optional', 'description': 'An array of values w_i weighing each sample (x_i, y_i).Weights are normalized to 1 if density is True. If density isFalse, the values of the returned histogram are equal to the sum ofthe weights belonging to the samples falling into each bin.'}]}, {'Returns': [{'name': 'H', 'type': 'ndarray, shape(nx, ny)', 'description': 'The bi-dimensional histogram of samples x and y. Values in xare histogrammed along the first dimension and values in y arehistogrammed along the second dimension.'}, {'name': 'xedges', 'type': 'ndarray, shape(nx+1,)', 'description': 'The bin edges along the first dimension.'}, {'name': 'yedges', 'type': 'ndarray, shape(ny+1,)', 'description': 'The bin edges along the second dimension.'}]}]",">>> import numpy as np
>>> from matplotlib.image import NonUniformImage
>>> import matplotlib.pyplot as plt
>>> xedges = [0, 1, 3, 5]
>>> yedges = [0, 2, 3, 4, 6]
>>> x = np.random.normal(2, 1, 100)
>>> y = np.random.normal(1, 1, 100)
>>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
>>> # Histogram does not follow Cartesian convention (see Notes),
>>> # therefore transpose H for visualization purposes.
>>> H = H.T
>>> fig = plt.figure(figsize=(7, 3))
>>> ax = fig.add_subplot(131, title='imshow: square bins')
>>> plt.imshow(H, interpolation='nearest', origin='lower',
...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
<matplotlib.image.AxesImage object at 0x...>
>>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',
...         aspect='equal')
>>> X, Y = np.meshgrid(xedges, yedges)
>>> ax.pcolormesh(X, Y, H)
<matplotlib.collections.QuadMesh object at 0x...>
>>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
>>> im = NonUniformImage(ax, interpolation='bilinear')
>>> xcenters = (xedges[:-1] + xedges[1:]) / 2
>>> ycenters = (yedges[:-1] + yedges[1:]) / 2
>>> im.set_data(xcenters, ycenters, H)
>>> ax.add_image(im)
>>> plt.show()
>>> # Generate non-symmetric test data
>>> n = 10000
>>> x = np.linspace(1, 100, n)
>>> y = 2*np.log(x) + np.random.rand(n) - 0.5
>>> # Compute 2d histogram. Note the order of x/y and xedges/yedges
>>> H, yedges, xedges = np.histogram2d(y, x, bins=20)
>>> # Plot histogram using pcolormesh
>>> fig, (ax1, ax2) = plt.subplots(ncols=2, sharey=True)
>>> ax1.pcolormesh(xedges, yedges, H, cmap='rainbow')
>>> ax1.plot(x, 2*np.log(x), 'k-')
>>> ax1.set_xlim(x.min(), x.max())
>>> ax1.set_ylim(y.min(), y.max())
>>> ax1.set_xlabel('x')
>>> ax1.set_ylabel('y')
>>> ax1.set_title('histogram2d')
>>> ax1.grid()
>>> # Create hexbin plot for comparison
>>> ax2.hexbin(x, y, gridsize=20, cmap='rainbow')
>>> ax2.plot(x, 2*np.log(x), 'k-')
>>> ax2.set_title('hexbin')
>>> ax2.set_xlim(x.min(), x.max())
>>> ax2.set_xlabel('x')
>>> ax2.grid()
>>> plt.show()"
numpy.histogramdd,Compute the multidimensional histogram of some data.,"[{'Parameters': [{'name': 'sample', 'type': '(N, D) array, or (N, D) array_like', 'description': 'The data to be histogrammed.Note the unusual interpretation of sample when an array_like:When an array, each row is a coordinate in a D-dimensional space -such as histogramdd(np.array([p1, p2, p3])).When an array_like, each element is the list of values for singlecoordinate - such as histogramdd((X, Y, Z)).The first form should be preferred.'}, {'name': 'bins', 'type': 'sequence or int, optional', 'description': 'The bin specification:A sequence of arrays describing the monotonically increasing binedges along each dimension.The number of bins for each dimension (nx, ny, … =bins)The number of bins for all dimensions (nx=ny=…=bins).'}, {'name': 'range', 'type': 'sequence, optional', 'description': 'A sequence of length D, each an optional (lower, upper) tuple givingthe outer bin edges to be used if the edges are not given explicitly inbins.An entry of None in the sequence results in the minimum and maximumvalues being used for the corresponding dimension.The default, None, is equivalent to passing a tuple of D None values.'}, {'name': 'density', 'type': 'bool, optional', 'description': 'If False, the default, returns the number of samples in each bin.If True, returns the probability density function at the bin,bin_count / sample_count / bin_volume.'}, {'name': 'weights', 'type': '(N,) array_like, optional', 'description': 'An array of values w_i weighing each sample (x_i, y_i, z_i, …).Weights are normalized to 1 if density is True. If density is False,the values of the returned histogram are equal to the sum of theweights belonging to the samples falling into each bin.'}]}, {'Returns': [{'name': 'H', 'type': 'ndarray', 'description': 'The multidimensional histogram of sample x. See density and weightsfor the different possible semantics.'}, {'name': 'edges', 'type': 'tuple of ndarrays', 'description': 'A tuple of D arrays describing the bin edges for each dimension.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng()
>>> r = rng.normal(size=(100,3))
>>> H, edges = np.histogramdd(r, bins = (5, 8, 4))
>>> H.shape, edges[0].size, edges[1].size, edges[2].size
((5, 8, 4), 6, 9, 5)"
numpy.bincount,Count number of occurrences of each value in array of non-negative ints.,"[{'Parameters': [{'name': 'x', 'type': 'array_like, 1 dimension, nonnegative ints', 'description': 'Input array.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'Weights, array of the same shape as x.'}, {'name': 'minlength', 'type': 'int, optional', 'description': 'A minimum number of bins for the output array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray of ints', 'description': 'The result of binning the input array.The length of out is equal to np.amax(x)+1.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the input is not 1-dimensional, or contains elements with negativevalues, or if minlength is negative.'}, {'name': 'TypeError', 'type': None, 'description': 'If the type of the input is float or complex.'}]}]",">>> import numpy as np
>>> np.bincount(np.arange(5))
array([1, 1, 1, 1, 1])
>>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
array([1, 3, 1, 1, 0, 0, 0, 1])
>>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
>>> np.bincount(x).size == np.amax(x)+1
True
>>> np.bincount(np.arange(5, dtype=float))
Traceback (most recent call last):
  ...
TypeError: Cannot cast array data from dtype('float64') to dtype('int64')
according to the rule 'safe'
>>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
>>> x = np.array([0, 1, 1, 2, 2, 2])
>>> np.bincount(x,  weights=w)
array([ 0.3,  0.7,  1.1])"
numpy.histogram_bin_edges,"Function to calculate only the edges of the bins used by the histogram
function.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data. The histogram is computed over the flattened array.'}, {'name': 'bins', 'type': 'int or sequence of scalars or str, optional', 'description': 'If bins is an int, it defines the number of equal-widthbins in the given range (10, by default). If bins is asequence, it defines the bin edges, including the rightmostedge, allowing for non-uniform bin widths.If bins is a string from the list below, histogram_bin_edges willuse the method chosen to calculate the optimal bin width andconsequently the number of bins (see the Notes section for more detailon the estimators) from the data that falls within the requested range.While the bin width will be optimal for the actual datain the range, the number of bins will be computed to fill theentire range, including the empty portions. For visualisation,using the ‘auto’ option is suggested. Weighted data is notsupported for automated bin size selection.‘auto’Minimum bin width between the ‘sturges’ and ‘fd’ estimators.Provides good all-around performance.‘fd’ (Freedman Diaconis Estimator)Robust (resilient to outliers) estimator that takes intoaccount data variability and data size.‘doane’An improved version of Sturges’ estimator that works betterwith non-normal datasets.‘scott’Less robust estimator that takes into account data variabilityand data size.‘stone’Estimator based on leave-one-out cross-validation estimate ofthe integrated squared error. Can be regarded as a generalizationof Scott’s rule.‘rice’Estimator does not take variability into account, only datasize. Commonly overestimates number of bins required.‘sturges’R’s default method, only accounts for data size. Onlyoptimal for gaussian data and underestimates number of binsfor large non-gaussian datasets.‘sqrt’Square root (of data size) estimator, used by Excel andother programs for its speed and simplicity.'}, {'name': '‘auto’', 'type': None, 'description': 'Minimum bin width between the ‘sturges’ and ‘fd’ estimators.Provides good all-around performance.'}, {'name': '‘fd’ (Freedman Diaconis Estimator)', 'type': None, 'description': 'Robust (resilient to outliers) estimator that takes intoaccount data variability and data size.'}, {'name': '‘doane’', 'type': None, 'description': 'An improved version of Sturges’ estimator that works betterwith non-normal datasets.'}, {'name': '‘scott’', 'type': None, 'description': 'Less robust estimator that takes into account data variabilityand data size.'}, {'name': '‘stone’', 'type': None, 'description': 'Estimator based on leave-one-out cross-validation estimate ofthe integrated squared error. Can be regarded as a generalizationof Scott’s rule.'}, {'name': '‘rice’', 'type': None, 'description': 'Estimator does not take variability into account, only datasize. Commonly overestimates number of bins required.'}, {'name': '‘sturges’', 'type': None, 'description': 'R’s default method, only accounts for data size. Onlyoptimal for gaussian data and underestimates number of binsfor large non-gaussian datasets.'}, {'name': '‘sqrt’', 'type': None, 'description': 'Square root (of data size) estimator, used by Excel andother programs for its speed and simplicity.'}, {'name': 'range', 'type': '(float, float), optional', 'description': 'The lower and upper range of the bins.  If not provided, rangeis simply (a.min(), a.max()).  Values outside the range areignored. The first element of the range must be less than orequal to the second. range affects the automatic bincomputation as well. While bin width is computed to be optimalbased on the actual data within range, the bin count will fillthe entire range including portions containing no data.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'An array of weights, of the same shape as a.  Each value ina only contributes its associated weight towards the bin count(instead of 1). This is currently not used by any of the bin estimators,but may be in the future.'}]}, {'Returns': [{'name': 'bin_edges', 'type': 'array of dtype float', 'description': 'The edges to pass into histogram'}]}]",">>> import numpy as np
>>> arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])
>>> np.histogram_bin_edges(arr, bins='auto', range=(0, 1))
array([0.  , 0.25, 0.5 , 0.75, 1.  ])
>>> np.histogram_bin_edges(arr, bins=2)
array([0. , 2.5, 5. ])
>>> np.histogram_bin_edges(arr, [1, 2])
array([1, 2])
>>> shared_bins = np.histogram_bin_edges(arr, bins='auto')
>>> shared_bins
array([0., 1., 2., 3., 4., 5.])
>>> group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])
>>> hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)
>>> hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)
>>> hist_0; hist_1
array([1, 1, 0, 1, 0])
array([2, 0, 1, 1, 2])
>>> hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')
>>> hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')
>>> hist_0; hist_1
array([1, 1, 1])
array([2, 1, 1, 2])
>>> bins_0; bins_1
array([0., 1., 2., 3.])
array([0.  , 1.25, 2.5 , 3.75, 5.  ])"
numpy.digitize,Return the indices of the bins to which each value in input array belongs.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array to be binned. Prior to NumPy 1.10.0, this array had tobe 1-dimensional, but can now have any shape.'}, {'name': 'bins', 'type': 'array_like', 'description': 'Array of bins. It has to be 1-dimensional and monotonic.'}, {'name': 'right', 'type': 'bool, optional', 'description': 'Indicating whether the intervals include the right or the left binedge. Default behavior is (right==False) indicating that the intervaldoes not include the right edge. The left bin end is open in thiscase, i.e., bins[i-1] <= x < bins[i] is the default behavior formonotonically increasing bins.'}]}, {'Returns': [{'name': 'indices', 'type': 'ndarray of ints', 'description': 'Output array of indices, of same shape as x.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If bins is not monotonic.'}, {'name': 'TypeError', 'type': None, 'description': 'If the type of the input is complex.'}]}]",">>> import numpy as np
>>> x = np.array([0.2, 6.4, 3.0, 1.6])
>>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
>>> inds = np.digitize(x, bins)
>>> inds
array([1, 4, 3, 2])
>>> for n in range(x.size):
...   print(bins[inds[n]-1], ""<="", x[n], ""<"", bins[inds[n]])
...
0.0 <= 0.2 < 1.0
4.0 <= 6.4 < 10.0
2.5 <= 3.0 < 4.0
1.0 <= 1.6 < 2.5
>>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
>>> bins = np.array([0, 5, 10, 15, 20])
>>> np.digitize(x,bins,right=True)
array([1, 2, 3, 4, 4])
>>> np.digitize(x,bins,right=False)
array([1, 3, 3, 4, 5])"
numpy.c_,Translates slice objects to concatenation along the second axis.,[],">>> import numpy as np
>>> np.c_[np.array([1,2,3]), np.array([4,5,6])]
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]
array([[1, 2, 3, ..., 4, 5, 6]])"
numpy.r_,Translates slice objects to concatenation along the first axis.,"[{'Parameters': [{'name': 'Not a function, so takes no parameters', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'A concatenated ndarray or matrix.', 'type': None, 'description': ''}]}]",">>> import numpy as np
>>> np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]
array([1, 2, 3, ..., 4, 5, 6])
>>> np.r_[-1:1:6j, [0]*3, 5, 6]
array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])
>>> a = np.array([[0, 1, 2], [3, 4, 5]])
>>> np.r_['-1', a, a] # concatenate along last axis
array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])
>>> np.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim>=2
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.r_['0,2,0', [1,2,3], [4,5,6]]
array([[1],
       [2],
       [3],
       [4],
       [5],
       [6]])
>>> np.r_['1,2,0', [1,2,3], [4,5,6]]
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> np.r_['r',[1,2,3], [4,5,6]]
matrix([[1, 2, 3, 4, 5, 6]])"
numpy.s_,A nicer way to build up index tuples for arrays.,"[{'Parameters': [{'name': 'maketuple', 'type': 'bool', 'description': 'If True, always returns a tuple.'}]}]",">>> import numpy as np
>>> np.s_[2::2]
slice(2, None, 2)
>>> np.index_exp[2::2]
(slice(2, None, 2),)
>>> np.array([0, 1, 2, 3, 4])[np.s_[2::2]]
array([2, 4])"
numpy.nonzero,Return the indices of the elements that are non-zero.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'tuple_of_arrays', 'type': 'tuple', 'description': 'Indices of elements that are non-zero.'}]}]",">>> import numpy as np
>>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
>>> x
array([[3, 0, 0],
       [0, 4, 0],
       [5, 6, 0]])
>>> np.nonzero(x)
(array([0, 1, 2, 2]), array([0, 1, 0, 1]))
>>> x[np.nonzero(x)]
array([3, 4, 5, 6])
>>> np.transpose(np.nonzero(x))
array([[0, 0],
       [1, 1],
       [2, 0],
       [2, 1]])
>>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> a > 3
array([[False, False, False],
       [ True,  True,  True],
       [ True,  True,  True]])
>>> np.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
>>> a[np.nonzero(a > 3)]
array([4, 5, 6, 7, 8, 9])
>>> a[a > 3]  # prefer this spelling
array([4, 5, 6, 7, 8, 9])
>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
numpy.where,Return elements chosen from x or y depending on condition.,"[{'Parameters': [{'name': 'condition', 'type': 'array_like, bool', 'description': 'Where True, yield x, otherwise yield y.'}, {'name': 'x, y', 'type': 'array_like', 'description': 'Values from which to choose. x, y and condition need to bebroadcastable to some shape.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array with elements from x where condition is True, and elementsfrom y elsewhere.'}]}]",">>> import numpy as np
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.where(a < 5, a, 10*a)
array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
>>> np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
       [3, 4]])
>>> x, y = np.ogrid[:3, :4]
>>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
array([[10,  0,  0,  0],
       [10, 11,  1,  1],
       [10, 11, 12,  2]])
>>> a = np.array([[0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6]])
>>> np.where(a < 4, a, -1)  # -1 is broadcast
array([[ 0,  1,  2],
       [ 0,  2, -1],
       [ 0,  3, -1]])"
numpy.indices,Return an array representing the indices of a grid.,"[{'Parameters': [{'name': 'dimensions', 'type': 'sequence of ints', 'description': 'The shape of the grid.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data type of the result.'}, {'name': 'sparse', 'type': 'boolean, optional', 'description': 'Return a sparse representation of the grid instead of a denserepresentation. Default is False.'}]}, {'Returns': [{'name': 'grid', 'type': 'one ndarray or tuple of ndarrays', 'description': 'If sparse is False:Returns one array of grid indices,grid.shape = (len(dimensions),) + tuple(dimensions).If sparse is True:Returns a tuple of arrays, withgrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) withdimensions[i] in the ith place'}, {'name': 'If sparse is False:', 'type': None, 'description': 'Returns one array of grid indices,grid.shape = (len(dimensions),) + tuple(dimensions).'}, {'name': 'If sparse is True:', 'type': None, 'description': 'Returns a tuple of arrays, withgrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) withdimensions[i] in the ith place'}]}]",">>> import numpy as np
>>> grid = np.indices((2, 3))
>>> grid.shape
(2, 2, 3)
>>> grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
>>> grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])
>>> x = np.arange(20).reshape(5, 4)
>>> row, col = np.indices((2, 3))
>>> x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])
>>> i, j = np.indices((2, 3), sparse=True)
>>> i.shape
(2, 1)
>>> j.shape
(1, 3)
>>> i        # row indices
array([[0],
       [1]])
>>> j        # column indices
array([[0, 1, 2]])"
numpy.ix_,Construct an open mesh from multiple sequences.,"[{'Parameters': [{'name': 'args', 'type': '1-D sequences', 'description': 'Each sequence should be of integer or boolean type.Boolean sequences will be interpreted as boolean masks for thecorresponding dimension (equivalent to passing innp.nonzero(boolean_sequence)).'}]}, {'Returns': [{'name': 'out', 'type': 'tuple of ndarrays', 'description': 'N arrays with N dimensions each, with N the number of inputsequences. Together these arrays form an open mesh.'}]}]",">>> import numpy as np
>>> a = np.arange(10).reshape(2, 5)
>>> a
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> ixgrid = np.ix_([0, 1], [2, 4])
>>> ixgrid
(array([[0],
       [1]]), array([[2, 4]]))
>>> ixgrid[0].shape, ixgrid[1].shape
((2, 1), (1, 2))
>>> a[ixgrid]
array([[2, 4],
       [7, 9]])
>>> ixgrid = np.ix_([True, True], [2, 4])
>>> a[ixgrid]
array([[2, 4],
       [7, 9]])
>>> ixgrid = np.ix_([True, True], [False, False, True, False, True])
>>> a[ixgrid]
array([[2, 4],
       [7, 9]])"
numpy.ogrid,An instance which returns an open multi-dimensional “meshgrid”.,"[{'Returns': [{'name': 'mesh-grid', 'type': 'ndarray or tuple of ndarrays', 'description': 'If the input is a single slice, returns an array.If the input is multiple slices, returns a tuple of arrays, withonly one dimension not equal to 1.'}]}]",">>> from numpy import ogrid
>>> ogrid[-1:1:5j]
array([-1. , -0.5,  0. ,  0.5,  1. ])
>>> ogrid[0:5, 0:5]
(array([[0],
        [1],
        [2],
        [3],
        [4]]),
 array([[0, 1, 2, 3, 4]]))"
numpy.ravel_multi_index,"Converts a tuple of index arrays into an array of flat
indices, applying boundary modes to the multi-index.","[{'Parameters': [{'name': 'multi_index', 'type': 'tuple of array_like', 'description': 'A tuple of integer arrays, one array for each dimension.'}, {'name': 'dims', 'type': 'tuple of ints', 'description': 'The shape of array into which the indices from multi_index apply.'}, {'name': 'mode', 'type': '{‘raise’, ‘wrap’, ‘clip’}, optional', 'description': 'Specifies how out-of-bounds indices are handled.  Can specifyeither one mode or a tuple of modes, one mode per index.‘raise’ – raise an error (default)‘wrap’ – wrap around‘clip’ – clip to the rangeIn ‘clip’ mode, a negative index which would normallywrap will clip to 0 instead.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Determines whether the multi-index should be viewed asindexing in row-major (C-style) or column-major(Fortran-style) order.'}]}, {'Returns': [{'name': 'raveled_indices', 'type': 'ndarray', 'description': 'An array of indices into the flattened version of an arrayof dimensions dims.'}]}]",">>> import numpy as np
>>> arr = np.array([[3,6,6],[4,5,1]])
>>> np.ravel_multi_index(arr, (7,6))
array([22, 41, 37])
>>> np.ravel_multi_index(arr, (7,6), order='F')
array([31, 41, 13])
>>> np.ravel_multi_index(arr, (4,6), mode='clip')
array([22, 23, 19])
>>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
array([12, 13, 13])
>>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))
1621"
numpy.unravel_index,"Converts a flat index or array of flat indices into a tuple
of coordinate arrays.","[{'Parameters': [{'name': 'indices', 'type': 'array_like', 'description': 'An integer array whose elements are indices into the flattenedversion of an array of dimensions shape. Before version 1.6.0,this function accepted just one index value.'}, {'name': 'shape', 'type': 'tuple of ints', 'description': 'The shape of the array to use for unraveling indices.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Determines whether the indices should be viewed as indexing inrow-major (C-style) or column-major (Fortran-style) order.'}]}, {'Returns': [{'name': 'unraveled_coords', 'type': 'tuple of ndarray', 'description': 'Each array in the tuple has the same shape as the indicesarray.'}]}]",">>> import numpy as np
>>> np.unravel_index([22, 41, 37], (7,6))
(array([3, 6, 6]), array([4, 5, 1]))
>>> np.unravel_index([31, 41, 13], (7,6), order='F')
(array([3, 6, 6]), array([4, 5, 1]))
>>> np.unravel_index(1621, (6,7,8,9))
(3, 1, 4, 1)"
numpy.diag_indices,Return the indices to access the main diagonal of an array.,"[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'The size, along each dimension, of the arrays for which the returnedindices can be used.'}, {'name': 'ndim', 'type': 'int, optional', 'description': 'The number of dimensions.'}]}]",">>> import numpy as np
>>> di = np.diag_indices(4)
>>> di
(array([0, 1, 2, 3]), array([0, 1, 2, 3]))
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> a[di] = 100
>>> a
array([[100,   1,   2,   3],
       [  4, 100,   6,   7],
       [  8,   9, 100,  11],
       [ 12,  13,  14, 100]])
>>> d3 = np.diag_indices(2, 3)
>>> d3
(array([0, 1]), array([0, 1]), array([0, 1]))
>>> a = np.zeros((2, 2, 2), dtype=int)
>>> a[d3] = 1
>>> a
array([[[1, 0],
        [0, 0]],
       [[0, 0],
        [0, 1]]])"
numpy.diag_indices_from,Return the indices to access the main diagonal of an n-dimensional array.,"[{'Parameters': [{'name': 'arr', 'type': 'array, at least 2-D', 'description': ''}]}]",">>> import numpy as np
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> di = np.diag_indices_from(a)
>>> di
(array([0, 1, 2, 3]), array([0, 1, 2, 3]))
>>> a[di]
array([ 0,  5, 10, 15])
>>> np.diag_indices(a.shape[0])
(array([0, 1, 2, 3]), array([0, 1, 2, 3]))"
numpy.mask_indices,"Return the indices to access (n, n) arrays, given a masking function.","[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'The returned indices will be valid to access arrays of shape (n, n).'}, {'name': 'mask_func', 'type': 'callable', 'description': 'A function whose call signature is similar to that of triu, tril.That is, mask_func(x, k) returns a boolean array, shaped like x.k is an optional argument to the function.'}, {'name': 'k', 'type': 'scalar', 'description': 'An optional argument which is passed through to mask_func. Functionslike triu, tril take a second argument that is interpreted as anoffset.'}]}, {'Returns': [{'name': 'indices', 'type': 'tuple of arrays.', 'description': 'The n arrays of indices corresponding to the locations wheremask_func(np.ones((n, n)), k) is True.'}]}]",">>> import numpy as np
>>> iu = np.mask_indices(3, np.triu)
>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> a[iu]
array([0, 1, 2, 4, 5, 8])
>>> iu1 = np.mask_indices(3, np.triu, 1)
>>> a[iu1]
array([1, 2, 5])"
numpy.tril_indices,"Return the indices for the lower-triangle of an (n, m) array.","[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'The row dimension of the arrays for which the returnedindices will be valid.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal offset (see tril for details).'}, {'name': 'm', 'type': 'int, optional', 'description': 'The column dimension of the arrays for which the returnedarrays will be valid.By default m is taken equal to n.'}]}, {'Returns': [{'name': 'inds', 'type': 'tuple of arrays', 'description': 'The row and column indices, respectively. The row indices are sortedin non-decreasing order, and the correspdonding column indices arestrictly increasing for each row.'}]}]",">>> import numpy as np
>>> il1 = np.tril_indices(4)
>>> il1
(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> a[il1]
array([ 0,  4,  5, ..., 13, 14, 15])
>>> a[il1] = -1
>>> a
array([[-1,  1,  2,  3],
       [-1, -1,  6,  7],
       [-1, -1, -1, 11],
       [-1, -1, -1, -1]])
>>> il2 = np.tril_indices(4, 2)
>>> a[il2] = -10
>>> a
array([[-10, -10, -10,   3],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10]])"
numpy.tril_indices_from,Return the indices for the lower-triangle of arr.,"[{'Parameters': [{'name': 'arr', 'type': 'array_like', 'description': 'The indices will be valid for square arrays whose dimensions arethe same as arr.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal offset (see tril for details).'}]}]",">>> import numpy as np
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> trili = np.tril_indices_from(a)
>>> trili
(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))
>>> a[trili]
array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])
>>> np.tril_indices(a.shape[0])
(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))
>>> trili1 = np.tril_indices_from(a, k=1)
>>> a[trili1]
array([ 0,  1,  4,  5,  6,  8,  9, 10, 11, 12, 13, 14, 15])"
numpy.triu_indices,"Return the indices for the upper-triangle of an (n, m) array.","[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'The size of the arrays for which the returned indices willbe valid.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal offset (see triu for details).'}, {'name': 'm', 'type': 'int, optional', 'description': 'The column dimension of the arrays for which the returnedarrays will be valid.By default m is taken equal to n.'}]}, {'Returns': [{'name': 'inds', 'type': 'tuple, shape(2) of ndarrays, shape(n)', 'description': 'The row and column indices, respectively. The row indices are sortedin non-decreasing order, and the correspdonding column indices arestrictly increasing for each row.'}]}]",">>> import numpy as np
>>> iu1 = np.triu_indices(4)
>>> iu1
(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> a[iu1]
array([ 0,  1,  2, ..., 10, 11, 15])
>>> a[iu1] = -1
>>> a
array([[-1, -1, -1, -1],
       [ 4, -1, -1, -1],
       [ 8,  9, -1, -1],
       [12, 13, 14, -1]])
>>> iu2 = np.triu_indices(4, 2)
>>> a[iu2] = -10
>>> a
array([[ -1,  -1, -10, -10],
       [  4,  -1,  -1, -10],
       [  8,   9,  -1,  -1],
       [ 12,  13,  14,  -1]])"
numpy.triu_indices_from,Return the indices for the upper-triangle of arr.,"[{'Parameters': [{'name': 'arr', 'type': 'ndarray, shape(N, N)', 'description': 'The indices will be valid for square arrays.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal offset (see triu for details).'}]}, {'Returns': [{'name': 'triu_indices_from', 'type': 'tuple, shape(2) of ndarray, shape(N)', 'description': 'Indices for the upper-triangle of arr.'}]}]",">>> import numpy as np
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> triui = np.triu_indices_from(a)
>>> triui
(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))
>>> a[triui]
array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])
>>> np.triu_indices(a.shape[0])
(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))
>>> triuim1 = np.triu_indices_from(a, k=1)
>>> a[triuim1]
array([ 1,  2,  3,  6,  7, 11])"
numpy.take,Take elements from an array along an axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like (Ni…, M, Nk…)', 'description': 'The source array.'}, {'name': 'indices', 'type': 'array_like (Nj…)', 'description': 'The indices of the values to extract.Also allow scalars for indices.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis over which to select values. By default, the flattenedinput array is used.'}, {'name': 'out', 'type': 'ndarray, optional (Ni…, Nj…, Nk…)', 'description': 'If provided, the result will be placed in this array. It shouldbe of the appropriate shape and dtype. Note that out is alwaysbuffered if mode=’raise’; use other modes for better performance.'}, {'name': 'mode', 'type': '{‘raise’, ‘wrap’, ‘clip’}, optional', 'description': 'Specifies how out-of-bounds indices will behave.‘raise’ – raise an error (default)‘wrap’ – wrap around‘clip’ – clip to the range‘clip’ mode means that all indices that are too large are replacedby the index that addresses the last element along that axis. Notethat this disables indexing with negative numbers.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray (Ni…, Nj…, Nk…)', 'description': 'The returned array has the same type as a.'}]}]",">>> import numpy as np
>>> a = [4, 3, 5, 7, 6, 8]
>>> indices = [0, 1, 4]
>>> np.take(a, indices)
array([4, 3, 6])
>>> a = np.array(a)
>>> a[indices]
array([4, 3, 6])
>>> np.take(a, [[0, 1], [2, 3]])
array([[4, 3],
       [5, 7]])"
numpy.take_along_axis,Take values from the input array by matching 1d index and data slices.,"[{'Parameters': [{'name': 'arr', 'type': 'ndarray (Ni…, M, Nk…)', 'description': 'Source array'}, {'name': 'indices', 'type': 'ndarray (Ni…, J, Nk…)', 'description': 'Indices to take along each 1d slice of arr. This must match thedimension of arr, but dimensions Ni and Nj only need to broadcastagainst arr.'}, {'name': 'axis', 'type': 'int', 'description': 'The axis to take 1d slices along. If axis is None, the input array istreated as if it had first been flattened to 1d, for consistency withsort and argsort.'}]}, {'Returns': [{'name': 'out: ndarray (Ni…, J, Nk…)', 'type': None, 'description': 'The indexed result.'}]}]",">>> import numpy as np
>>> a = np.array([[10, 30, 20], [60, 40, 50]])
>>> np.sort(a, axis=1)
array([[10, 20, 30],
       [40, 50, 60]])
>>> ai = np.argsort(a, axis=1)
>>> ai
array([[0, 2, 1],
       [1, 2, 0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[10, 20, 30],
       [40, 50, 60]])
>>> np.max(a, axis=1, keepdims=True)
array([[30],
       [60]])
>>> ai = np.argmax(a, axis=1, keepdims=True)
>>> ai
array([[1],
       [0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[30],
       [60]])
>>> ai_min = np.argmin(a, axis=1, keepdims=True)
>>> ai_max = np.argmax(a, axis=1, keepdims=True)
>>> ai = np.concatenate([ai_min, ai_max], axis=1)
>>> ai
array([[0, 1],
       [1, 0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[10, 30],
       [40, 60]])"
numpy.choose,Construct an array from an index array and a list of arrays to choose from.,"[{'Parameters': [{'name': 'a', 'type': 'int array', 'description': 'This array must contain integers in [0, n-1], where n is thenumber of choices, unless mode=wrap or mode=clip, in whichcases any integers are permissible.'}, {'name': 'choices', 'type': 'sequence of arrays', 'description': 'Choice arrays. a and all of the choices must be broadcastable to thesame shape.  If choices is itself an array (not recommended), thenits outermost dimension (i.e., the one corresponding tochoices.shape[0]) is taken as defining the “sequence”.'}, {'name': 'out', 'type': 'array, optional', 'description': ""If provided, the result will be inserted into this array. It shouldbe of the appropriate shape and dtype. Note that out is alwaysbuffered if mode='raise'; use other modes for better performance.""}, {'name': 'mode', 'type': '{‘raise’ (default), ‘wrap’, ‘clip’}, optional', 'description': 'Specifies how indices outside [0, n-1] will be treated:‘raise’ : an exception is raised‘wrap’ : value becomes value mod n‘clip’ : values < 0 are mapped to 0, values > n-1 are mapped to n-1'}]}, {'Returns': [{'name': 'merged_array', 'type': 'array', 'description': 'The merged result.'}]}, {'Raises': [{'name': 'ValueError: shape mismatch', 'type': None, 'description': 'If a and each choice array are not all broadcastable to the sameshape.'}]}]",">>> import numpy as np
>>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
...   [20, 21, 22, 23], [30, 31, 32, 33]]
>>> np.choose([2, 3, 1, 0], choices
... # the first element of the result will be the first element of the
... # third (2+1) ""array"" in choices, namely, 20; the second element
... # will be the second element of the fourth (3+1) choice array, i.e.,
... # 31, etc.
... )
array([20, 31, 12,  3])
>>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
array([20, 31, 12,  3])
>>> # because there are 4 choice arrays
>>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
array([20,  1, 12,  3])
>>> # i.e., 0
>>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
>>> choices = [-10, 10]
>>> np.choose(a, choices)
array([[ 10, -10,  10],
       [-10,  10, -10],
       [ 10, -10,  10]])
>>> # With thanks to Anne Archibald
>>> a = np.array([0, 1]).reshape((2,1,1))
>>> c1 = np.array([1, 2, 3]).reshape((1,3,1))
>>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
>>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
array([[[ 1,  1,  1,  1,  1],
        [ 2,  2,  2,  2,  2],
        [ 3,  3,  3,  3,  3]],
       [[-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5]]])"
numpy.compress,Return selected slices of an array along given axis.,"[{'Parameters': [{'name': 'condition', 'type': '1-D array of bools', 'description': 'Array that selects which entries to return. If len(condition)is less than the size of a along the given axis, then output istruncated to the length of the condition array.'}, {'name': 'a', 'type': 'array_like', 'description': 'Array from which to extract a part.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to take slices. If None (default), work on theflattened array.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Output array.  Its type is preserved and it must be of the rightshape to hold the output.'}]}, {'Returns': [{'name': 'compressed_array', 'type': 'ndarray', 'description': 'A copy of a without the slices along axis for which conditionis false.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4], [5, 6]])
>>> a
array([[1, 2],
       [3, 4],
       [5, 6]])
>>> np.compress([0, 1], a, axis=0)
array([[3, 4]])
>>> np.compress([False, True, True], a, axis=0)
array([[3, 4],
       [5, 6]])
>>> np.compress([False, True], a, axis=1)
array([[2],
       [4],
       [6]])
>>> np.compress([False, True], a)
array([2])"
numpy.diag,Extract a diagonal or construct a diagonal array.,"[{'Parameters': [{'name': 'v', 'type': 'array_like', 'description': 'If v is a 2-D array, return a copy of its k-th diagonal.If v is a 1-D array, return a 2-D array with v on the k-thdiagonal.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal in question. The default is 0. Use k>0 for diagonalsabove the main diagonal, and k<0 for diagonals below the maindiagonal.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The extracted diagonal or constructed diagonal array.'}]}]",">>> import numpy as np
>>> x = np.arange(9).reshape((3,3))
>>> x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.diag(x)
array([0, 4, 8])
>>> np.diag(x, k=1)
array([1, 5])
>>> np.diag(x, k=-1)
array([3, 7])
>>> np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])"
numpy.diagonal,Return specified diagonals.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array from which the diagonals are taken.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Offset of the diagonal from the main diagonal.  Can be positive ornegative.  Defaults to main diagonal (0).'}, {'name': 'axis1', 'type': 'int, optional', 'description': 'Axis to be used as the first axis of the 2-D sub-arrays from whichthe diagonals should be taken.  Defaults to first axis (0).'}, {'name': 'axis2', 'type': 'int, optional', 'description': 'Axis to be used as the second axis of the 2-D sub-arrays fromwhich the diagonals should be taken. Defaults to second axis (1).'}]}, {'Returns': [{'name': 'array_of_diagonals', 'type': 'ndarray', 'description': 'If a is 2-D, then a 1-D array containing the diagonal and of thesame type as a is returned unless a is a matrix, in which casea 1-D array rather than a (2-D) matrix is returned in order tomaintain backward compatibility.If a.ndim > 2, then the dimensions specified by axis1 and axis2are removed, and a new axis inserted at the end corresponding to thediagonal.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the dimension of a is less than 2.'}]}]",">>> import numpy as np
>>> a = np.arange(4).reshape(2,2)
>>> a
array([[0, 1],
       [2, 3]])
>>> a.diagonal()
array([0, 3])
>>> a.diagonal(1)
array([1])
>>> a = np.arange(8).reshape(2,2,2); a
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> a.diagonal(0,  # Main diagonals of two arrays created by skipping
...            0,  # across the outer(left)-most axis last and
...            1)  # the ""middle"" (row) axis first.
array([[0, 6],
       [1, 7]])
>>> a[:,:,0]  # main diagonal is [0 6]
array([[0, 2],
       [4, 6]])
>>> a[:,:,1]  # main diagonal is [1 7]
array([[1, 3],
       [5, 7]])
>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.fliplr(a).diagonal()  # Horizontal flip
array([2, 4, 6])
>>> np.flipud(a).diagonal()  # Vertical flip
array([6, 4, 2])"
numpy.select,"Return an array drawn from elements in choicelist, depending on conditions.","[{'Parameters': [{'name': 'condlist', 'type': 'list of bool ndarrays', 'description': 'The list of conditions which determine from which array in choicelistthe output elements are taken. When multiple conditions are satisfied,the first one encountered in condlist is used.'}, {'name': 'choicelist', 'type': 'list of ndarrays', 'description': 'The list of arrays from which the output elements are taken. It hasto be of the same length as condlist.'}, {'name': 'default', 'type': 'scalar, optional', 'description': 'The element inserted in output when all conditions evaluate to False.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'The output at position m is the m-th element of the array inchoicelist where the m-th element of the corresponding array incondlist is True.'}]}]",">>> import numpy as np
>>> x = np.arange(6)
>>> condlist = [x<3, x>3]
>>> choicelist = [x, x**2]
>>> np.select(condlist, choicelist, 42)
array([ 0,  1,  2, 42, 16, 25])
>>> condlist = [x<=4, x>3]
>>> choicelist = [x, x**2]
>>> np.select(condlist, choicelist, 55)
array([ 0,  1,  2,  3,  4, 25])"
numpy.place,Change elements of an array based on conditional and input values.,"[{'Parameters': [{'name': 'arr', 'type': 'ndarray', 'description': 'Array to put data into.'}, {'name': 'mask', 'type': 'array_like', 'description': 'Boolean mask array. Must have the same size as a.'}, {'name': 'vals', 'type': '1-D sequence', 'description': 'Values to put into a. Only the first N elements are used, whereN is the number of True values in mask. If vals is smallerthan N, it will be repeated, and if elements of a are to be masked,this sequence must be non-empty.'}]}]",">>> import numpy as np
>>> arr = np.arange(6).reshape(2, 3)
>>> np.place(arr, arr>2, [44, 55])
>>> arr
array([[ 0,  1,  2],
       [44, 55, 44]])"
numpy.put,Replaces specified elements of an array with given values.,"[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'Target array.'}, {'name': 'ind', 'type': 'array_like', 'description': 'Target indices, interpreted as integers.'}, {'name': 'v', 'type': 'array_like', 'description': 'Values to place in a at target indices. If v is shorter thanind it will be repeated as necessary.'}, {'name': 'mode', 'type': '{‘raise’, ‘wrap’, ‘clip’}, optional', 'description': 'Specifies how out-of-bounds indices will behave.‘raise’ – raise an error (default)‘wrap’ – wrap around‘clip’ – clip to the range‘clip’ mode means that all indices that are too large are replacedby the index that addresses the last element along that axis. Notethat this disables indexing with negative numbers. In ‘raise’ mode,if an exception occurs the target array may still be modified.'}]}]",">>> import numpy as np
>>> a = np.arange(5)
>>> np.put(a, [0, 2], [-44, -55])
>>> a
array([-44,   1, -55,   3,   4])
>>> a = np.arange(5)
>>> np.put(a, 22, -5, mode='clip')
>>> a
array([ 0,  1,  2,  3, -5])"
numpy.put_along_axis,Put values into the destination array by matching 1d index and data slices.,"[{'Parameters': [{'name': 'arr', 'type': 'ndarray (Ni…, M, Nk…)', 'description': 'Destination array.'}, {'name': 'indices', 'type': 'ndarray (Ni…, J, Nk…)', 'description': 'Indices to change along each 1d slice of arr. This must match thedimension of arr, but dimensions in Ni and Nj may be 1 to broadcastagainst arr.'}, {'name': 'values', 'type': 'array_like (Ni…, J, Nk…)', 'description': 'values to insert at those indices. Its shape and dimension arebroadcast to match that of indices.'}, {'name': 'axis', 'type': 'int', 'description': 'The axis to take 1d slices along. If axis is None, the destinationarray is treated as if a flattened 1d view had been created of it.'}]}]",">>> import numpy as np
>>> a = np.array([[10, 30, 20], [60, 40, 50]])
>>> ai = np.argmax(a, axis=1, keepdims=True)
>>> ai
array([[1],
       [0]])
>>> np.put_along_axis(a, ai, 99, axis=1)
>>> a
array([[10, 99, 20],
       [99, 40, 50]])"
numpy.putmask,Changes elements of an array based on conditional and input values.,"[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'Target array.'}, {'name': 'mask', 'type': 'array_like', 'description': 'Boolean mask array. It has to be the same shape as a.'}, {'name': 'values', 'type': 'array_like', 'description': 'Values to put into a where mask is True. If values is smallerthan a it will be repeated.'}]}]",">>> import numpy as np
>>> x = np.arange(6).reshape(2, 3)
>>> np.putmask(x, x>2, x**2)
>>> x
array([[ 0,  1,  2],
       [ 9, 16, 25]])
>>> x = np.arange(5)
>>> np.putmask(x, x>1, [-33, -44])
>>> x
array([  0,   1, -33, -44, -33])"
numpy.fill_diagonal,Fill the main diagonal of the given array of any dimensionality.,"[{'Parameters': [{'name': 'a', 'type': 'array, at least 2-D.', 'description': 'Array whose diagonal is to be filled in-place.'}, {'name': 'val', 'type': 'scalar or array_like', 'description': 'Value(s) to write on the diagonal. If val is scalar, the value iswritten along the diagonal. If array-like, the flattened val iswritten along the diagonal, repeating if necessary to fill alldiagonal entries.'}, {'name': 'wrap', 'type': 'bool', 'description': 'For tall matrices in NumPy version up to 1.6.2, thediagonal “wrapped” after N columns. You can have this behaviorwith this option. This affects only tall matrices.'}]}]",">>> import numpy as np
>>> a = np.zeros((3, 3), int)
>>> np.fill_diagonal(a, 5)
>>> a
array([[5, 0, 0],
       [0, 5, 0],
       [0, 0, 5]])
>>> a = np.zeros((3, 3, 3, 3), int)
>>> np.fill_diagonal(a, 4)
>>> a[0, 0]
array([[4, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])
>>> a[1, 1]
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 0]])
>>> a[2, 2]
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 4]])
>>> # tall matrices no wrap
>>> a = np.zeros((5, 3), int)
>>> np.fill_diagonal(a, 4)
>>> a
array([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [0, 0, 0]])
>>> # tall matrices wrap
>>> a = np.zeros((5, 3), int)
>>> np.fill_diagonal(a, 4, wrap=True)
>>> a
array([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [4, 0, 0]])
>>> # wide matrices
>>> a = np.zeros((3, 5), int)
>>> np.fill_diagonal(a, 4, wrap=True)
>>> a
array([[4, 0, 0, 0, 0],
       [0, 4, 0, 0, 0],
       [0, 0, 4, 0, 0]])
>>> a = np.zeros((3, 3), int);
>>> np.fill_diagonal(np.fliplr(a), [1,2,3])  # Horizontal flip
>>> a
array([[0, 0, 1],
       [0, 2, 0],
       [3, 0, 0]])
>>> np.fill_diagonal(np.flipud(a), [1,2,3])  # Vertical flip
>>> a
array([[0, 0, 3],
       [0, 2, 0],
       [1, 0, 0]])"
numpy.nditer,"Efficient multi-dimensional iterator object to iterate over arrays.
To get started using this object, see the
introductory guide to array iteration.","[{'Parameters': [{'name': 'op', 'type': 'ndarray or sequence of array_like', 'description': 'The array(s) to iterate over.'}, {'name': 'flags', 'type': 'sequence of str, optional', 'description': 'Flags to control the behavior of the iterator.buffered enables buffering when required.c_index causes a C-order index to be tracked.f_index causes a Fortran-order index to be tracked.multi_index causes a multi-index, or a tuple of indiceswith one per iteration dimension, to be tracked.common_dtype causes all the operands to be converted toa common data type, with copying or buffering as necessary.copy_if_overlap causes the iterator to determine if readoperands have overlap with write operands, and make temporarycopies as necessary to avoid overlap. False positives (needlesscopying) are possible in some cases.delay_bufalloc delays allocation of the buffers untila reset() call is made. Allows allocate operands tobe initialized before their values are copied into the buffers.external_loop causes the values given to beone-dimensional arrays with multiple values instead ofzero-dimensional arrays.grow_inner allows the value array sizes to be madelarger than the buffer size when both buffered andexternal_loop is used.ranged allows the iterator to be restricted to a sub-rangeof the iterindex values.refs_ok enables iteration of reference types, such asobject arrays.reduce_ok enables iteration of readwrite operandswhich are broadcasted, also known as reduction operands.zerosize_ok allows itersize to be zero.'}, {'name': 'op_flags', 'type': 'list of list of str, optional', 'description': 'This is a list of flags for each operand. At minimum, one ofreadonly, readwrite, or writeonly must be specified.readonly indicates the operand will only be read from.readwrite indicates the operand will be read from and written to.writeonly indicates the operand will only be written to.no_broadcast prevents the operand from being broadcasted.contig forces the operand data to be contiguous.aligned forces the operand data to be aligned.nbo forces the operand data to be in native byte order.copy allows a temporary read-only copy if required.updateifcopy allows a temporary read-write copy if required.allocate causes the array to be allocated if it is Nonein the op parameter.no_subtype prevents an allocate operand from using a subtype.arraymask indicates that this operand is the mask to usefor selecting elements when writing to operands with the‘writemasked’ flag set. The iterator does not enforce this,but when writing from a buffer back to the array, it onlycopies those elements indicated by this mask.writemasked indicates that only elements where the chosenarraymask operand is True will be written to.overlap_assume_elementwise can be used to mark operands that areaccessed only in the iterator order, to allow less conservativecopying when copy_if_overlap is present.'}, {'name': 'op_dtypes', 'type': 'dtype or tuple of dtype(s), optional', 'description': 'The required data type(s) of the operands. If copying or bufferingis enabled, the data will be converted to/from their original types.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Controls the iteration order. ‘C’ means C order, ‘F’ meansFortran order, ‘A’ means ‘F’ order if all the arrays are Fortrancontiguous, ‘C’ order otherwise, and ‘K’ means as close to theorder the array elements appear in memory as possible. This alsoaffects the element memory order of allocate operands, as theyare allocated to be compatible with iteration order.Default is ‘K’.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur when making a copyor buffering.  Setting this to ‘unsafe’ is not recommended,as it can adversely affect accumulations.‘no’ means the data types should not be cast at all.‘equiv’ means only byte-order changes are allowed.‘safe’ means only casts which can preserve values are allowed.‘same_kind’ means only safe casts or casts within a kind,like float64 to float32, are allowed.‘unsafe’ means any data conversions may be done.'}, {'name': 'op_axes', 'type': 'list of list of ints, optional', 'description': 'If provided, is a list of ints or None for each operands.The list of axes for an operand is a mapping from the dimensionsof the iterator to the dimensions of the operand. A value of-1 can be placed for entries, causing that dimension to betreated as newaxis.'}, {'name': 'itershape', 'type': 'tuple of ints, optional', 'description': 'The desired shape of the iterator. This allows allocate operandswith a dimension mapped by op_axes not corresponding to a dimensionof a different operand to get a value not equal to 1 for thatdimension.'}, {'name': 'buffersize', 'type': 'int, optional', 'description': 'When buffering is enabled, controls the size of the temporarybuffers. Set to 0 for the default value.'}]}, {'Attributes': [{'name': 'dtypes', 'type': 'tuple of dtype(s)', 'description': 'The data types of the values provided in value. This may bedifferent from the operand data types if buffering is enabled.Valid only before the iterator is closed.'}, {'name': 'finished', 'type': 'bool', 'description': 'Whether the iteration over the operands is finished or not.'}, {'name': 'has_delayed_bufalloc', 'type': 'bool', 'description': 'If True, the iterator was created with the delay_bufalloc flag,and no reset() function was called on it yet.'}, {'name': 'has_index', 'type': 'bool', 'description': 'If True, the iterator was created with either the c_index orthe f_index flag, and the property index can be used toretrieve it.'}, {'name': 'has_multi_index', 'type': 'bool', 'description': 'If True, the iterator was created with the multi_index flag,and the property multi_index can be used to retrieve it.'}, {'name': 'index', 'type': None, 'description': 'When the c_index or f_index flag was used, this propertyprovides access to the index. Raises a ValueError if accessedand has_index is False.'}, {'name': 'iterationneedsapi', 'type': 'bool', 'description': 'Whether iteration requires access to the Python API, for exampleif one of the operands is an object array.'}, {'name': 'iterindex', 'type': 'int', 'description': 'An index which matches the order of iteration.'}, {'name': 'itersize', 'type': 'int', 'description': 'Size of the iterator.'}, {'name': 'itviews', 'type': None, 'description': 'Structured view(s) of operands in memory, matching the reorderedand optimized iterator access pattern. Valid only before the iteratoris closed.'}, {'name': 'multi_index', 'type': None, 'description': 'When the multi_index flag was used, this propertyprovides access to the index. Raises a ValueError if accessedaccessed and has_multi_index is False.'}, {'name': 'ndim', 'type': 'int', 'description': 'The dimensions of the iterator.'}, {'name': 'nop', 'type': 'int', 'description': 'The number of iterator operands.'}, {'name': 'operandstuple of operand(s)', 'type': 'tuple of operand(s)', 'description': 'operands[Slice]'}, {'name': 'shape', 'type': 'tuple of ints', 'description': 'Shape tuple, the shape of the iterator.'}, {'name': 'value', 'type': None, 'description': 'Value of operands at current iteration. Normally, this is atuple of array scalars, but if the flag external_loop is used,it is a tuple of one dimensional arrays.'}]}]",">>> import numpy as np
>>> def iter_add_py(x, y, out=None):
...     addop = np.add
...     it = np.nditer([x, y, out], [],
...                 [['readonly'], ['readonly'], ['writeonly','allocate']])
...     with it:
...         for (a, b, c) in it:
...             addop(a, b, out=c)
...         return it.operands[2]
>>> def iter_add(x, y, out=None):
...    addop = np.add
...    it = np.nditer([x, y, out], [],
...                [['readonly'], ['readonly'], ['writeonly','allocate']])
...    with it:
...        while not it.finished:
...            addop(it[0], it[1], out=it[2])
...            it.iternext()
...        return it.operands[2]
>>> def outer_it(x, y, out=None):
...     mulop = np.multiply
...     it = np.nditer([x, y, out], ['external_loop'],
...             [['readonly'], ['readonly'], ['writeonly', 'allocate']],
...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,
...                      [-1] * x.ndim + list(range(y.ndim)),
...                      None])
...     with it:
...         for (a, b, c) in it:
...             mulop(a, b, out=c)
...         return it.operands[2]
>>> a = np.arange(2)+1
>>> b = np.arange(3)+1
>>> outer_it(a,b)
array([[1, 2, 3],
       [2, 4, 6]])
>>> def luf(lamdaexpr, *args, **kwargs):
...    '''luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)'''
...    nargs = len(args)
...    op = (kwargs.get('out',None),) + args
...    it = np.nditer(op, ['buffered','external_loop'],
...            [['writeonly','allocate','no_broadcast']] +
...                            [['readonly','nbo','aligned']]*nargs,
...            order=kwargs.get('order','K'),
...            casting=kwargs.get('casting','safe'),
...            buffersize=kwargs.get('buffersize',0))
...    while not it.finished:
...        it[0] = lamdaexpr(*it[1:])
...        it.iternext()
...    return it.operands[0]
>>> a = np.arange(5)
>>> b = np.ones(5)
>>> luf(lambda i,j:i*i + j/2, a, b)
array([  0.5,   1.5,   4.5,   9.5,  16.5])
>>> a = np.arange(6, dtype='i4')[::-2]
>>> with np.nditer(a, [],
...        [['writeonly', 'updateifcopy']],
...        casting='unsafe',
...        op_dtypes=[np.dtype('f4')]) as i:
...    x = i.operands[0]
...    x[:] = [-1, -2, -3]
...    # a still unchanged here
>>> a, x
(array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))"
numpy.ndenumerate,Multidimensional index iterator.,"[{'Parameters': [{'name': 'arr', 'type': 'ndarray', 'description': 'Input array.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> for index, x in np.ndenumerate(a):
...     print(index, x)
(0, 0) 1
(0, 1) 2
(1, 0) 3
(1, 1) 4"
numpy.ndindex,An N-dimensional iterator object to index arrays.,"[{'Parameters': [{'name': 'shape', 'type': 'ints, or a single tuple of ints', 'description': 'The size of each dimension of the array can be passed asindividual parameters or as the elements of a tuple.'}]}]",">>> import numpy as np
>>> for index in np.ndindex(3, 2, 1):
...     print(index)
(0, 0, 0)
(0, 1, 0)
(1, 0, 0)
(1, 1, 0)
(2, 0, 0)
(2, 1, 0)
>>> for index in np.ndindex((3, 2, 1)):
...     print(index)
(0, 0, 0)
(0, 1, 0)
(1, 0, 0)
(1, 1, 0)
(2, 0, 0)
(2, 1, 0)"
numpy.nested_iters,Create nditers for use in nested loops,"[{'Parameters': [{'name': 'op', 'type': 'ndarray or sequence of array_like', 'description': 'The array(s) to iterate over.'}, {'name': 'axes', 'type': 'list of list of int', 'description': 'Each item is used as an “op_axes” argument to an nditer'}, {'name': 'flags, op_flags, op_dtypes, order, casting, buffersize (optional)', 'type': None, 'description': 'See nditer parameters of the same name'}]}, {'Returns': [{'name': 'iters', 'type': 'tuple of nditer', 'description': 'An nditer for each item in axes, outermost first'}]}]",">>> import numpy as np
>>> a = np.arange(12).reshape(2, 3, 2)
>>> i, j = np.nested_iters(a, [[1], [0, 2]], flags=[""multi_index""])
>>> for x in i:
...      print(i.multi_index)
...      for y in j:
...          print('', j.multi_index, y)
(0,)
 (0, 0) 0
 (0, 1) 1
 (1, 0) 6
 (1, 1) 7
(1,)
 (0, 0) 2
 (0, 1) 3
 (1, 0) 8
 (1, 1) 9
(2,)
 (0, 0) 4
 (0, 1) 5
 (1, 0) 10
 (1, 1) 11"
numpy.flatiter,Flat iterator object to iterate over arrays.,"[{'Attributes': [{'name': 'base', 'type': None, 'description': 'A reference to the array that is iterated over.'}, {'name': 'coords', 'type': None, 'description': 'An N-dimensional tuple of current coordinates.'}, {'name': 'index', 'type': None, 'description': 'Current flat index into the array.'}]}]",">>> import numpy as np
>>> x = np.arange(6).reshape(2, 3)
>>> fl = x.flat
>>> type(fl)
<class 'numpy.flatiter'>
>>> for item in fl:
...     print(item)
...
0
1
2
3
4
5
>>> fl[2:4]
array([2, 3])"
numpy.iterable,Check whether or not an object can be iterated over.,"[{'Parameters': [{'name': 'y', 'type': 'object', 'description': 'Input object.'}]}, {'Returns': [{'name': 'b', 'type': 'bool', 'description': 'Return True if the object has an iterator method or is asequence and False otherwise.'}]}]",">>> import numpy as np
>>> np.iterable([1, 2, 3])
True
>>> np.iterable(2)
False"
"class numpy.random.SeedSequence(entropy=None, *, spawn_key=(), pool_size=4)",SeedSequence mixes sources of entropy in a reproducible way to set theinitial state for independent and very probably non-overlappingBitGenerators.,"[{'Parameters': [{'name': 'entropy', 'type': '{None, int, sequence[int]}, optional', 'description': 'The entropy for creating a SeedSequence.All integer values must be non-negative.'}, {'name': 'spawn_key', 'type': '{(), sequence[int]}, optional', 'description': 'An additional source of entropy based on the position of thisSeedSequence in the tree of such objects created with theSeedSequence.spawn method. Typically, only SeedSequence.spawn willset this, and users will not.'}, {'name': 'pool_size', 'type': '{int}, optional', 'description': 'Size of the pooled entropy to store. Default is 4 to give a 128-bitentropy pool. 8 (for 256 bits) is another reasonable choice if workingwith larger PRNGs, but there is very little to be gained by selectinganother value.'}, {'name': 'n_children_spawned', 'type': '{int}, optional', 'description': 'The number of children already spawned. Only pass this ifreconstructing a SeedSequence from a serialized form.'}]}, {'Attributes': [{'name': 'entropy', 'type': None, 'description': ''}, {'name': 'n_children_spawned', 'type': None, 'description': ''}, {'name': 'pool', 'type': None, 'description': ''}, {'name': 'pool_size', 'type': None, 'description': ''}, {'name': 'spawn_key', 'type': None, 'description': ''}, {'name': 'state', 'type': None, 'description': ''}]}]",">>> sq1 = np.random.SeedSequence()
>>> sq1.entropy
243799254704924441050048792905230269161  # random
>>> sq2 = np.random.SeedSequence(sq1.entropy)
>>> np.all(sq1.generate_state(10) == sq2.generate_state(10))
True"
numpy.random.SeedSequence.generate_state,method,"[{'Parameters': [{'name': 'n_words', 'type': 'int', 'description': ''}, {'name': 'dtype', 'type': 'np.uint32 or np.uint64, optional', 'description': 'The size of each word. This should only be either uint32 oruint64. Strings (‘uint32’, ‘uint64’) are fine. Note thatrequesting uint64 will draw twice as many bits as uint32 forthe same n_words. This is a convenience for BitGeneratorsthat express their states as uint64 arrays.'}]}, {'Returns': [{'name': 'state', 'type': 'uint32 or uint64 array, shape=(n_words,)', 'description': ''}]}]",
numpy.random.SeedSequence.spawn,method,"[{'Parameters': [{'name': 'n_children', 'type': 'int', 'description': ''}]}, {'Returns': [{'name': 'seqs', 'type': 'list of SeedSequence s', 'description': ''}]}]",
numpy.random.SeedSequence.spawn_key,attribute,[],
class numpy.random.BitGenerator(seed=None),"Base Class for generic BitGenerators, which provide a streamof random bits based on different algorithms. Must be overridden.","[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like[ints], SeedSequence}, optional', 'description': 'A seed to initialize the BitGenerator. If None, then fresh,unpredictable entropy will be pulled from the OS. If an int orarray_like[ints] is passed, then it will be passed toSeedSequence to derive the initial BitGenerator state.One may also pass in a SeedSequence instance.All integer values must be non-negative.'}]}, {'Attributes': [{'name': 'lock', 'type': 'threading.Lock', 'description': 'Lock instance that is shared so that the same BitGenerator canbe used in multiple Generators without corrupting the state. Code thatgenerates values from a bit generator should hold the bit generator’slock.'}]}]",
numpy.random.BitGenerator.random_raw,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'output', 'type': 'bool, optional', 'description': 'Output values.  Used for performance testing since the generatedvalues are not returned.'}]}, {'Returns': [{'name': 'out', 'type': 'uint or ndarray', 'description': 'Drawn samples.'}]}]",
numpy.random.BitGenerator.spawn,method,"[{'Parameters': [{'name': 'n_children', 'type': 'int', 'description': ''}]}, {'Returns': [{'name': 'child_bit_generators', 'type': 'list of BitGenerators', 'description': ''}]}, {'Raises': [{'name': 'TypeError', 'type': None, 'description': 'When the underlying SeedSequence does not implement spawning.'}]}]",
numpy.polynomial.polynomial.Polynomial,A power series class.,"[{'Parameters': [{'name': 'coef', 'type': 'array_like', 'description': 'Polynomial coefficients in order of increasing degree, i.e.,(1, 2, 3) give 1 + 2*x + 3*x**2.'}, {'name': 'domain', 'type': '(2,) array_like, optional', 'description': 'Domain to use. The interval [domain[0], domain[1]] is mappedto the interval [window[0], window[1]] by shifting and scaling.The default value is [-1., 1.].'}, {'name': 'window', 'type': '(2,) array_like, optional', 'description': 'Window, see domain for its use. The default value is [-1., 1.].'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol used to represent the independent variable in stringrepresentations of the polynomial expression, e.g. for printing.The symbol must be a valid Python identifier. Default value is ‘x’.New in version 1.24.'}]}, {'Attributes': [{'name': 'basis_name', 'type': None, 'description': ''}, {'name': 'symbol', 'type': None, 'description': ''}]}]",
numpy.polynomial.polynomial.Polynomial.__call__,method,[],
numpy.polynomial.polynomial.Polynomial.basis,method,"[{'Parameters': [{'name': 'deg', 'type': 'int', 'description': 'Degree of the basis polynomial for the series. Must be >= 0.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series with the coefficient of the deg term set to one andall others zero.'}]}]",
numpy.polynomial.polynomial.Polynomial.cast,method,"[{'Parameters': [{'name': 'series', 'type': 'series', 'description': 'The series instance to be converted.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series of the same kind as the calling class and equal toseries when evaluated.'}]}]",
numpy.polynomial.polynomial.Polynomial.convert,method,"[{'Parameters': [{'name': 'domain', 'type': 'array_like, optional', 'description': 'The domain of the converted series. If the value is None,the default domain of kind is used.'}, {'name': 'kind', 'type': 'class, optional', 'description': 'The polynomial series type class to which the current instanceshould be converted. If kind is None, then the class of thecurrent instance is used.'}, {'name': 'window', 'type': 'array_like, optional', 'description': 'The window of the converted series. If the value is None,the default window of kind is used.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'The returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.'}]}]",
numpy.polynomial.polynomial.Polynomial.copy,method,"[{'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Copy of self.'}]}]",
numpy.polynomial.polynomial.Polynomial.cutdeg,method,"[{'Parameters': [{'name': 'deg', 'type': 'non-negative int', 'description': 'The series is reduced to degree deg by discarding the highorder terms. The value of deg must be a non-negative integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with reduced degree.'}]}]",
numpy.polynomial.polynomial.Polynomial.degree,method,"[{'Returns': [{'name': 'degree', 'type': 'int', 'description': 'Degree of the series, one less than the number of coefficients.'}]}]",">>> poly = np.polynomial.Polynomial([1, 7, 4])
>>> print(poly)
1.0 + 7.0·x + 4.0·x²
>>> poly.degree()
2
>>> poly = np.polynomial.Polynomial([1, 7, 0])
>>> print(poly)
1.0 + 7.0·x + 0.0·x²
>>> poly.degree()
2
>>> poly.trim().degree()
1"
numpy.polynomial.polynomial.Polynomial.deriv,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'Find the derivative of order m.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the derivative. The domain is the sameas the domain of the differentiated series.'}]}]",
numpy.polynomial.polynomial.Polynomial.fit,method,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (M,)', 'description': 'x-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'y', 'type': 'array_like, shape (M,)', 'description': 'y-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'deg', 'type': 'int or 1-D array_like', 'description': 'Degree(s) of the fitting polynomials. If deg is a single integerall terms up to and including the deg’th term are included in thefit. For NumPy versions >= 1.11.0 a list of integers specifying thedegrees of the terms to include may be used instead.'}, {'name': 'domain', 'type': '{None, [beg, end], []}, optional', 'description': 'Domain to use for the returned series. If None,then a minimal domain that covers the points x is chosen.  If[] the class domain is used. The default value was theclass domain in NumPy 1.4 and None in later versions.The [] option was added in numpy 1.5.0.'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Relative condition number of the fit. Singular values smallerthan this relative to the largest singular value will beignored. The default value is len(x)*eps, where eps is therelative precision of the float type, about 2e-16 in mostcases.'}, {'name': 'full', 'type': 'bool, optional', 'description': 'Switch determining nature of return value. When it is False(the default) just the coefficients are returned, when Truediagnostic information from the singular value decomposition isalso returned.'}, {'name': 'w', 'type': 'array_like, shape (M,), optional', 'description': 'Weights. If not None, the weight w[i] applies to the unsquaredresidual y[i] - y_hat[i] at x[i]. Ideally the weights arechosen so that the errors of the products w[i]*y[i] all havethe same variance.  When using inverse-variance weighting, usew[i] = 1/sigma(y[i]).  The default value is None.'}, {'name': 'window', 'type': '{[beg, end]}, optional', 'description': 'Window to use for the returned series. The defaultvalue is the default class domain'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.'}, {'name': '[resid, rank, sv, rcond]', 'type': 'list', 'description': 'These values are only returned if full == Trueresid – sum of squared residuals of the least squares fitrank – the numerical rank of the scaled Vandermonde matrixsv – singular values of the scaled Vandermonde matrixrcond – value of rcond.For more details, see linalg.lstsq.'}]}]",
numpy.polynomial.polynomial.Polynomial.fromroots,method,"[{'Parameters': [{'name': 'roots', 'type': 'array_like', 'description': 'List of roots.'}, {'name': 'domain', 'type': '{[], None, array_like}, optional', 'description': 'Domain for the resulting series. If None the domain is theinterval from the smallest root to the largest. If [] thedomain is the class domain. The default is [].'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'Window for the returned series. If None the class window isused. The default is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series with the specified roots.'}]}]",
numpy.polynomial.polynomial.Polynomial.has_samecoef,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the coef attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the coefficients are the same, False otherwise.'}]}]",
numpy.polynomial.polynomial.Polynomial.has_samedomain,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the domain attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the domains are the same, False otherwise.'}]}]",
numpy.polynomial.polynomial.Polynomial.has_sametype,method,"[{'Parameters': [{'name': 'other', 'type': 'object', 'description': 'Class instance.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if other is same class as self'}]}]",
numpy.polynomial.polynomial.Polynomial.has_samewindow,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the window attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the windows are the same, False otherwise.'}]}]",
numpy.polynomial.polynomial.Polynomial.identity,method,"[{'Parameters': [{'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series of representing the identity.'}]}]",
numpy.polynomial.polynomial.Polynomial.integ,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'The number of integrations to perform.'}, {'name': 'k', 'type': 'array_like', 'description': 'Integration constants. The first constant is applied to thefirst integration, the second to the second, and so on. Thelist of values must less than or equal to m in length and anymissing values are set to zero.'}, {'name': 'lbnd', 'type': 'Scalar', 'description': 'The lower bound of the definite integral.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the integral. The domain is the sameas the domain of the integrated series.'}]}]",
numpy.polynomial.polynomial.Polynomial.linspace,method,"[{'Parameters': [{'name': 'n', 'type': 'int, optional', 'description': 'Number of point pairs to return. The default value is 100.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If not None, the specified domain is used instead of that ofthe calling instance. It should be of the form [beg,end].The default is None which case the class domain is used.'}]}, {'Returns': [{'name': 'x, y', 'type': 'ndarray', 'description': 'x is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.'}]}]",
numpy.polynomial.polynomial.Polynomial.mapparms,method,"[{'Returns': [{'name': 'off, scl', 'type': 'float or complex', 'description': 'The mapping function is defined by off + scl*x.'}]}]",
numpy.polynomial.polynomial.Polynomial.roots,method,"[{'Returns': [{'name': 'roots', 'type': 'ndarray', 'description': 'Array containing the roots of the series.'}]}]",
numpy.polynomial.polynomial.Polynomial.trim,method,"[{'Parameters': [{'name': 'tol', 'type': 'non-negative number.', 'description': 'All trailing coefficients less than tol will be removed.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with trimmed coefficients.'}]}]",
numpy.polynomial.polynomial.Polynomial.truncate,method,"[{'Parameters': [{'name': 'size', 'type': 'positive int', 'description': 'The series is reduced to length size by discarding the highdegree terms. The value of size must be a positive integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with truncated coefficients.'}]}]",
class numpy.random.MT19937(seed=None),Container for the Mersenne Twister pseudo-random number generator.,"[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like[ints], SeedSequence}, optional', 'description': 'A seed to initialize the BitGenerator. If None, then fresh,unpredictable entropy will be pulled from the OS. If an int orarray_like[ints] is passed, then it will be passed toSeedSequence to derive the initial BitGenerator state. One may alsopass in a SeedSequence instance.'}]}, {'Attributes': [{'name': 'lock: threading.Lock', 'type': None, 'description': 'Lock instance that is shared so that the same bit git generator canbe used in multiple Generators without corrupting the state. Code thatgenerates values from a bit generator should hold the bit generator’slock.'}]}]",">>> from numpy.random import Generator, MT19937, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(MT19937(s)) for s in sg.spawn(10)]
>>> from numpy.random import Generator, MT19937, SeedSequence
>>> sg = SeedSequence(1234)
>>> bit_generator = MT19937(sg)
>>> rg = []
>>> for _ in range(10):
...    rg.append(Generator(bit_generator))
...    # Chain the BitGenerators
...    bit_generator = bit_generator.jumped()"
numpy.random.MT19937.state,attribute,"[{'Returns': [{'name': 'state', 'type': 'dict', 'description': 'Dictionary containing the information required to describe thestate of the PRNG'}]}]",
numpy.random.MT19937.jumped,method,"[{'Parameters': [{'name': 'jumps', 'type': 'integer, positive', 'description': 'Number of times to jump the state of the bit generator returned'}]}, {'Returns': [{'name': 'bit_generator', 'type': 'MT19937', 'description': 'New instance of generator jumped iter times'}]}]",
numpy.random.MT19937.cffi,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.random.MT19937.ctypes,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.random.default_rng(seed=None),Construct a new Generator with the default BitGenerator (PCG64).,"[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like[ints], SeedSequence, BitGenerator, Generator, RandomState}, optional', 'description': 'A seed to initialize the BitGenerator. If None, then fresh,unpredictable entropy will be pulled from the OS. If an int orarray_like[ints] is passed, then all values must be non-negative and will bepassed to SeedSequence to derive the initial BitGenerator state. One may alsopass in a SeedSequence instance.Additionally, when passed a BitGenerator, it will be wrapped byGenerator. If passed a Generator, it will be returned unaltered.When passed a legacy RandomState instance it will be coerced to a Generator.'}]}, {'Returns': [{'name': 'Generator', 'type': None, 'description': 'The initialized generator object.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng(12345)
>>> print(rng)
Generator(PCG64)
>>> rfloat = rng.random()
>>> rfloat
0.22733602246716966
>>> type(rfloat)
<class 'float'>
>>> import numpy as np
>>> rng = np.random.default_rng(12345)
>>> rints = rng.integers(low=0, high=10, size=3)
>>> rints
array([6, 2, 7])
>>> type(rints[0])
<class 'numpy.int64'>
>>> import numpy as np
>>> rng = np.random.default_rng(seed=42)
>>> print(rng)
Generator(PCG64)
>>> arr1 = rng.random((3, 3))
>>> arr1
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
>>> import numpy as np
>>> rng = np.random.default_rng(seed=42)
>>> arr2 = rng.random((3, 3))
>>> arr2
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
>>> from numpy.random import Generator, PCG64
>>> rng = Generator(PCG64())
>>> rng.standard_normal()
-0.203  # random
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> x = np.arange(0, 15).reshape(3, 5)
>>> x 
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> y = rng.permuted(x, axis=1, out=x)
>>> x 
array([[ 1,  0,  2,  4,  3],  # random
       [ 6,  7,  8,  9,  5],
       [10, 14, 11, 13, 12]])
>>> y is x
True
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> x = np.arange(0, 15).reshape(3, 5)
>>> x
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> rng.permutation(x, axis=1) 
array([[ 1,  3,  2,  0,  4],  # random
       [ 6,  8,  7,  5,  9],
       [11, 13, 12, 10, 14]])
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> rng.permuted(x, axis=1) 
array([[ 1,  0,  2,  4,  3],  # random
       [ 5,  7,  6,  9,  8],
       [10, 14, 12, 13, 11]])
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> a = ['A', 'B', 'C', 'D', 'E']
>>> rng.shuffle(a)  # shuffle the list in-place
>>> a 
['B', 'D', 'A', 'E', 'C']  # random"
class numpy.random.Generator(bit_generator),Container for the BitGenerators.,"[{'Parameters': [{'name': 'bit_generator', 'type': 'BitGenerator', 'description': 'BitGenerator to use as the core generator.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng(12345)
>>> print(rng)
Generator(PCG64)
>>> rfloat = rng.random()
>>> rfloat
0.22733602246716966
>>> type(rfloat)
<class 'float'>
>>> import numpy as np
>>> rng = np.random.default_rng(12345)
>>> rints = rng.integers(low=0, high=10, size=3)
>>> rints
array([6, 2, 7])
>>> type(rints[0])
<class 'numpy.int64'>
>>> import numpy as np
>>> rng = np.random.default_rng(seed=42)
>>> print(rng)
Generator(PCG64)
>>> arr1 = rng.random((3, 3))
>>> arr1
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
>>> import numpy as np
>>> rng = np.random.default_rng(seed=42)
>>> arr2 = rng.random((3, 3))
>>> arr2
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
>>> from numpy.random import Generator, PCG64
>>> rng = Generator(PCG64())
>>> rng.standard_normal()
-0.203  # random
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> x = np.arange(0, 15).reshape(3, 5)
>>> x 
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> y = rng.permuted(x, axis=1, out=x)
>>> x 
array([[ 1,  0,  2,  4,  3],  # random
       [ 6,  7,  8,  9,  5],
       [10, 14, 11, 13, 12]])
>>> y is x
True
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> x = np.arange(0, 15).reshape(3, 5)
>>> x
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> rng.permutation(x, axis=1) 
array([[ 1,  3,  2,  0,  4],  # random
       [ 6,  8,  7,  5,  9],
       [11, 13, 12, 10, 14]])
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> rng.permuted(x, axis=1) 
array([[ 1,  0,  2,  4,  3],  # random
       [ 5,  7,  6,  9,  8],
       [10, 14, 12, 13, 11]])
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> a = ['A', 'B', 'C', 'D', 'E']
>>> rng.shuffle(a)  # shuffle the list in-place
>>> a 
['B', 'D', 'A', 'E', 'C']  # random"
numpy.random.Generator.bit_generator,attribute,"[{'Returns': [{'name': 'bit_generator', 'type': 'BitGenerator', 'description': 'The bit generator instance used by the generator'}]}]",
numpy.random.Generator.spawn,method,"[{'Parameters': [{'name': 'n_children', 'type': 'int', 'description': ''}]}, {'Returns': [{'name': 'child_generators', 'type': 'list of Generators', 'description': ''}]}, {'Raises': [{'name': 'TypeError', 'type': None, 'description': 'When the underlying SeedSequence does not implement spawning.'}]}]",">>> # High quality entropy created with: f""0x{secrets.randbits(128):x}""
>>> entropy = 0x3034c61a9ae04ff8cb62ab8ec2c4b501
>>> rng = np.random.default_rng(entropy)
>>> child_rng1, child_rng2 = rng.spawn(2)
>>> rng.uniform(), child_rng1.uniform(), child_rng2.uniform()
(0.19029263503854454, 0.9475673279178444, 0.4702687338396767)
>>> more_child_rngs = rng.spawn(20)
>>> nested_spawn = child_rng1.spawn(20)"
numpy.random.Generator.integers,method,"[{'Parameters': [{'name': 'low', 'type': 'int or array-like of ints', 'description': 'Lowest (signed) integers to be drawn from the distribution (unlesshigh=None, in which case this parameter is 0 and this value isused for high).'}, {'name': 'high', 'type': 'int or array-like of ints, optional', 'description': 'If provided, one above the largest (signed) integer to be drawnfrom the distribution (see above for behavior if high=None).If array-like, must contain integer values'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Desired dtype of the result. Byteorder must be native.The default value is np.int64.'}, {'name': 'endpoint', 'type': 'bool, optional', 'description': 'If true, sample from the interval [low, high] instead of thedefault [low, high)Defaults to False'}]}, {'Returns': [{'name': 'out', 'type': 'int or ndarray of ints', 'description': 'size-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.'}]}]",">>> rng = np.random.default_rng()
>>> rng.integers(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])  # random
>>> rng.integers(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
>>> rng.integers(5, size=(2, 4))
array([[4, 0, 2, 1],
       [3, 2, 2, 0]])  # random
>>> rng.integers(1, [3, 5, 10])
array([2, 2, 9])  # random
>>> rng.integers([1, 5, 7], 10)
array([9, 8, 7])  # random
>>> rng.integers([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)
array([[ 8,  6,  9,  7],
       [ 1, 16,  9, 12]], dtype=uint8)  # random"
numpy.random.Generator.random,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Desired dtype of the result, only float64 and float32 are supported.Byteorder must be native. The default value is np.float64.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. If size is not None,it must have the same shape as the provided size and must match the type ofthe output values.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray of floats', 'description': 'Array of random floats of shape size (unless size=None, in whichcase a single float is returned).'}]}]",">>> rng = np.random.default_rng()
>>> rng.random()
0.47108547995356098 # random
>>> type(rng.random())
<class 'float'>
>>> rng.random((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random
>>> 5 * rng.random((3, 2)) - 5
array([[-3.99149989, -0.52338984], # random
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])"
numpy.random.Generator.choice,method,"[{'Parameters': [{'name': 'a', 'type': '{array_like, int}', 'description': 'If an ndarray, a random sample is generated from its elements.If an int, the random sample is generated from np.arange(a).'}, {'name': 'size', 'type': '{int, tuple[int]}, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn from the 1-d a. If a has morethan one dimension, the size shape will be inserted into theaxis dimension, so the output ndim will be a.ndim - 1 +len(size). Default is None, in which case a single value isreturned.'}, {'name': 'replace', 'type': 'bool, optional', 'description': 'Whether the sample is with or without replacement. Default is True,meaning that a value of a can be selected multiple times.'}, {'name': 'p', 'type': '1-D array_like, optional', 'description': 'The probabilities associated with each entry in a.If not given, the sample assumes a uniform distribution over allentries in a.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which the selection is performed. The default, 0,selects by row.'}, {'name': 'shuffle', 'type': 'bool, optional', 'description': 'Whether the sample is shuffled when sampling without replacement.Default is True, False provides a speedup.'}]}, {'Returns': [{'name': 'samples', 'type': 'single item or ndarray', 'description': 'The generated random samples'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If a is an int and less than zero, if p is not 1-dimensional, ifa is array-like with a size 0, if p is not a vector ofprobabilities, if a and p have different lengths, or ifreplace=False and the sample size is greater than the populationsize.'}]}]",">>> rng = np.random.default_rng()
>>> rng.choice(5, 3)
array([0, 3, 4]) # random
>>> #This is equivalent to rng.integers(0,5,3)
>>> rng.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
array([3, 3, 0]) # random
>>> rng.choice(5, 3, replace=False)
array([3,1,0]) # random
>>> #This is equivalent to rng.permutation(np.arange(5))[:3]
>>> rng.choice([[0, 1, 2], [3, 4, 5], [6, 7, 8]], 2, replace=False)
array([[3, 4, 5], # random
       [0, 1, 2]])
>>> rng.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
array([2, 3, 0]) # random
>>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
>>> rng.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random
      dtype='<U11')"
numpy.random.Generator.bytes,method,"[{'Parameters': [{'name': 'length', 'type': 'int', 'description': 'Number of random bytes.'}]}, {'Returns': [{'name': 'out', 'type': 'bytes', 'description': 'String of length length.'}]}]",">>> rng = np.random.default_rng()
>>> rng.bytes(10)
b'\xfeC\x9b\x86\x17\xf2\xa1\xafcp'  # random"
numpy.random.Generator.shuffle,method,"[{'Parameters': [{'name': 'x', 'type': 'ndarray or MutableSequence', 'description': 'The array, list or mutable sequence to be shuffled.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis which x is shuffled along. Default is 0.It is only supported on ndarray objects.'}]}, {'Returns': [{'name': 'None', 'type': None, 'description': ''}]}]",">>> rng = np.random.default_rng()
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> rng.shuffle(arr)
>>> arr
array([2, 0, 7, 5, 1, 4, 8, 9, 3, 6]) # random
>>> arr = np.arange(9).reshape((3, 3))
>>> arr
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> rng.shuffle(arr)
>>> arr
array([[3, 4, 5], # random
       [6, 7, 8],
       [0, 1, 2]])
>>> arr = np.arange(9).reshape((3, 3))
>>> arr
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> rng.shuffle(arr, axis=1)
>>> arr
array([[2, 0, 1], # random
       [5, 3, 4],
       [8, 6, 7]])"
numpy.random.Generator.permutation,method,"[{'Parameters': [{'name': 'x', 'type': 'int or array_like', 'description': 'If x is an integer, randomly permute np.arange(x).If x is an array, make a copy and shuffle the elementsrandomly.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis which x is shuffled along. Default is 0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Permuted sequence or array range.'}]}]",">>> rng = np.random.default_rng()
>>> rng.permutation(10)
array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random
>>> rng.permutation([1, 4, 9, 12, 15])
array([15,  1,  9,  4, 12]) # random
>>> arr = np.arange(9).reshape((3, 3))
>>> rng.permutation(arr)
array([[6, 7, 8], # random
       [0, 1, 2],
       [3, 4, 5]])
>>> rng.permutation(""abc"")
Traceback (most recent call last):
    ...
numpy.exceptions.AxisError: axis 0 is out of bounds for array of dimension 0
>>> arr = np.arange(9).reshape((3, 3))
>>> rng.permutation(arr, axis=1)
array([[0, 2, 1], # random
       [3, 5, 4],
       [6, 8, 7]])"
numpy.random.Generator.permuted,method,"[{'Parameters': [{'name': 'x', 'type': 'array_like, at least one-dimensional', 'description': 'Array to be shuffled.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Slices of x in this axis are shuffled. Each sliceis shuffled independently of the others.  If axis isNone, the flattened array is shuffled.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If given, this is the destination of the shuffled array.If out is None, a shuffled copy of the array is returned.'}]}, {'Returns': [{'name': 'ndarray', 'type': None, 'description': 'If out is None, a shuffled copy of x is returned.Otherwise, the shuffled array is stored in out,and out is returned'}]}]",">>> rng = np.random.default_rng()
>>> x = np.arange(24).reshape(3, 8)
>>> x
array([[ 0,  1,  2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23]])
>>> y = rng.permuted(x, axis=1)
>>> y
array([[ 4,  3,  6,  7,  1,  2,  5,  0],  # random
       [15, 10, 14,  9, 12, 11,  8, 13],
       [17, 16, 20, 21, 18, 22, 23, 19]])
>>> x
array([[ 0,  1,  2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23]])
>>> y = rng.permuted(x, axis=1, out=x)
>>> x
array([[ 3,  0,  4,  7,  1,  6,  2,  5],  # random
       [ 8, 14, 13,  9, 12, 11, 15, 10],
       [17, 18, 16, 22, 19, 23, 20, 21]])
>>> y is x
True"
numpy.random.Generator.beta,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Alpha, positive (>0).'}, {'name': 'b', 'type': 'float or array_like of floats', 'description': 'Beta, positive (>0).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a and b are both scalars.Otherwise, np.broadcast(a, b).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized beta distribution.'}]}]",">>> rng = np.random.default_rng()
>>> a, b, size = 2.0, 2.0, 10000
>>> sample = rng.beta(a=a, b=b, size=size)
>>> np.mean(sample)
0.5047328775385895  # may vary
>>> a, b, size = 2, 7, 10000
>>> sample_left = rng.beta(a=a, b=b, size=size)
>>> sample_right = rng.beta(a=b, b=a, size=size)
>>> m_left, m_right = np.mean(sample_left), np.mean(sample_right)
>>> print(m_left, m_right)
0.2238596793678923 0.7774613834041182  # may vary
>>> print(m_left - a/(a+b))
0.001637457145670096  # may vary
>>> print(m_right - b/(a+b))
-0.0003163943736596009  # may vary
>>> import matplotlib.pyplot as plt
>>> plt.hist([sample_left, sample_right], 
...          50, density=True, histtype='bar')
>>> plt.show()"
numpy.random.Generator.binomial,method,"[{'Parameters': [{'name': 'n', 'type': 'int or array_like of ints', 'description': 'Parameter of the distribution, >= 0. Floats are also accepted,but they will be truncated to integers.'}, {'name': 'p', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, >= 0 and <=1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if n and p are both scalars.Otherwise, np.broadcast(n, p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized binomial distribution, whereeach sample is equal to the number of successes over the n trials.'}]}]",">>> rng = np.random.default_rng()
>>> n, p, size = 10, .5, 10000  
>>> s = rng.binomial(n, p, 10000)
>>> n, p, size = 9, 0.1, 20000
>>> np.sum(rng.binomial(n=n, p=p, size=size) == 0)/size
0.39015  # may vary
>>> import matplotlib.pyplot as plt
>>> from scipy.stats import binom
>>> n, p, size = 100, 0.4, 10000
>>> sample = rng.binomial(n, p, size=size)
>>> count, bins, _ = plt.hist(sample, 30, density=True)
>>> x = np.arange(n)
>>> y = binom.pmf(x, n, p)
>>> plt.plot(x, y, linewidth=2, color='r')"
numpy.random.Generator.chisquare,method,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Number of degrees of freedom, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df is a scalar.  Otherwise,np.array(df).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized chi-square distribution.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'When df <= 0 or when an inappropriate size (e.g. size=-1)is given.'}]}]",">>> rng = np.random.default_rng()
>>> rng.chisquare(2,4)
array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random
>>> import matplotlib.pyplot as plt
>>> import scipy.stats as stats
>>> s = rng.chisquare(20, 10000)
>>> count, bins, _ = plt.hist(s, 30, density=True)
>>> x = np.linspace(0, 60, 1000)
>>> plt.plot(x, stats.chi2.pdf(x, df=20))
>>> plt.xlim([0, 60])
>>> plt.show()"
numpy.random.Generator.dirichlet,method,"[{'Parameters': [{'name': 'alpha', 'type': 'sequence of floats, length k', 'description': 'Parameter of the distribution (length k for sample oflength k).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n), thenm * n * k samples are drawn.  Default is None, in which case avector of length k is returned.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray,', 'description': 'The drawn samples, of shape (size, k).'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If any value in alpha is less than zero'}]}]",">>> rng = np.random.default_rng()
>>> s = rng.dirichlet((10, 5, 3), 20).transpose()
>>> import matplotlib.pyplot as plt
>>> plt.barh(range(20), s[0])
>>> plt.barh(range(20), s[1], left=s[0], color='g')
>>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
>>> plt.title(""Lengths of Strings"")"
numpy.random.Generator.exponential,method,"[{'Parameters': [{'name': 'scale', 'type': 'float or array_like of floats', 'description': 'The scale parameter, \\(\\beta = 1/\\lambda\\). Must benon-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if scale is a scalar.  Otherwise,np.array(scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized exponential distribution.'}]}]",">>> scale, size = 4, 10000
>>> rng = np.random.default_rng()
>>> time_between_calls = rng.exponential(scale=scale, size=size)
>>> x = ((time_between_calls < 5).sum())/size
>>> y = ((time_between_calls < 4).sum())/size
>>> x - y
0.08  # may vary
>>> import matplotlib.pyplot as plt
>>> scale, size = 4, 10000
>>> rng = np.random.default_rng()
>>> sample = rng.exponential(scale=scale, size=size)
>>> count, bins, _ = plt.hist(sample, 30, density=True)
>>> plt.plot(bins, scale**(-1)*np.exp(-scale**-1*bins), linewidth=2, color='r')
>>> plt.show()"
numpy.random.Generator.f,method,"[{'Parameters': [{'name': 'dfnum', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom in numerator, must be > 0.'}, {'name': 'dfden', 'type': 'float or array_like of float', 'description': 'Degrees of freedom in denominator, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if dfnum and dfden are both scalars.Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Fisher distribution.'}]}]",">>> dfnum = 1. # between group degrees of freedom
>>> dfden = 48. # within groups degrees of freedom
>>> rng = np.random.default_rng()
>>> s = rng.f(dfnum, dfden, 1000)
>>> np.sort(s)[-10]
7.61988120985 # random
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> dfnum, dfden, size = 20, 20, 10000
>>> s = rng.f(dfnum=dfnum, dfden=dfden, size=size)
>>> bins, density, _ = plt.hist(s, 30, density=True)
>>> x = np.linspace(0, 5, 1000)
>>> plt.plot(x, stats.f.pdf(x, dfnum, dfden))
>>> plt.xlim([0, 5])
>>> plt.show()"
numpy.random.Generator.gamma,method,"[{'Parameters': [{'name': 'shape', 'type': 'float or array_like of floats', 'description': 'The shape of the gamma distribution. Must be non-negative.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'The scale of the gamma distribution. Must be non-negative.Default is equal to 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if shape and scale are both scalars.Otherwise, np.broadcast(shape, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized gamma distribution.'}]}]",">>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
>>> rng = np.random.default_rng()
>>> s = rng.gamma(shape, scale, 1000)
>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  
>>> count, bins, _ = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1)*(np.exp(-bins/scale) /  
...                      (sps.gamma(shape)*scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.Generator.geometric,method,"[{'Parameters': [{'name': 'p', 'type': 'float or array_like of floats', 'description': 'The probability of success of an individual trial.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if p is a scalar.  Otherwise,np.array(p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized geometric distribution.'}]}]",">>> p, size = 0.35, 10000
>>> rng = np.random.default_rng()
>>> sample = rng.geometric(p=p, size=size)
>>> (sample == 1).sum()/size
0.34889999999999999  # may vary
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(sample, bins=30, density=True)
>>> plt.plot(bins, (1-p)**(bins-1)*p)
>>> plt.xlim([0, 25])
>>> plt.show()"
numpy.random.Generator.gumbel,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'The location of the mode of the distribution. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'The scale parameter of the distribution. Default is 1. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Gumbel distribution.'}]}]",">>> rng = np.random.default_rng()
>>> mu, beta = 0, 0.1 # location and scale
>>> s = rng.gumbel(mu, beta, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 30, density=True)
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp( -np.exp( -(bins - mu) /beta) ),
...          linewidth=2, color='r')
>>> plt.show()
>>> means = []
>>> maxima = []
>>> for i in range(0,1000) :
...    a = rng.normal(mu, beta, 1000)
...    means.append(a.mean())
...    maxima.append(a.max())
>>> count, bins, _ = plt.hist(maxima, 30, density=True)
>>> beta = np.std(maxima) * np.sqrt(6) / np.pi
>>> mu = np.mean(maxima) - 0.57721*beta
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp(-np.exp(-(bins - mu)/beta)),
...          linewidth=2, color='r')
>>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
...          linewidth=2, color='g')
>>> plt.show()"
numpy.random.Generator.hypergeometric,method,"[{'Parameters': [{'name': 'ngood', 'type': 'int or array_like of ints', 'description': 'Number of ways to make a good selection.  Must be nonnegative andless than 10**9.'}, {'name': 'nbad', 'type': 'int or array_like of ints', 'description': 'Number of ways to make a bad selection.  Must be nonnegative andless than 10**9.'}, {'name': 'nsample', 'type': 'int or array_like of ints', 'description': 'Number of items sampled.  Must be nonnegative and less thanngood + nbad.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if ngood, nbad, and nsampleare all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized hypergeometric distribution. Eachsample is the number of good items within a randomly selected subset ofsize nsample taken from a set of ngood good items and nbad bad items.'}]}]",">>> rng = np.random.default_rng()
>>> ngood, nbad, nsamp = 100, 2, 10
# number of good, number of bad, and number of samples
>>> s = rng.hypergeometric(ngood, nbad, nsamp, 1000)
>>> from matplotlib.pyplot import hist
>>> hist(s)
#   note that it is very unlikely to grab both bad items
>>> s = rng.hypergeometric(15, 15, 15, 100000)
>>> sum(s>=12)/100000. + sum(s<=3)/100000.
#   answer = 0.003 ... pretty unlikely!"
numpy.random.Generator.laplace,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'The position, \\(\\mu\\), of the distribution peak. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': '\\(\\lambda\\), the exponential decay. Default is 1. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Laplace distribution.'}]}]",">>> loc, scale = 0., 1.
>>> rng = np.random.default_rng()
>>> s = rng.laplace(loc, scale, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 30, density=True)
>>> x = np.arange(-8., 8., .01)
>>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
>>> plt.plot(x, pdf)
>>> g = (1/(scale * np.sqrt(2 * np.pi)) *
...      np.exp(-(x - loc)**2 / (2 * scale**2)))
>>> plt.plot(x,g)"
numpy.random.Generator.logistic,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'Parameter of the distribution. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'Parameter of the distribution. Must be non-negative.Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized logistic distribution.'}]}]",">>> loc, scale = 10, 1
>>> rng = np.random.default_rng()
>>> s = rng.logistic(loc, scale, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, bins=50, label='Sampled data')
>>> def logistic(x, loc, scale):
...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)
>>> logistic_values  = logistic(bins, loc, scale)
>>> bin_spacing = np.mean(np.diff(bins))
>>> plt.plot(bins, logistic_values  * bin_spacing * s.size, label='Logistic PDF')
>>> plt.legend()
>>> plt.show()"
numpy.random.Generator.lognormal,method,"[{'Parameters': [{'name': 'mean', 'type': 'float or array_like of floats, optional', 'description': 'Mean value of the underlying normal distribution. Default is 0.'}, {'name': 'sigma', 'type': 'float or array_like of floats, optional', 'description': 'Standard deviation of the underlying normal distribution. Must benon-negative. Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mean and sigma are both scalars.Otherwise, np.broadcast(mean, sigma).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized log-normal distribution.'}]}]",">>> rng = np.random.default_rng()
>>> mu, sigma = 3., 1. # mean and standard deviation
>>> s = rng.lognormal(mu, sigma, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 100, density=True, align='mid')
>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))
>>> plt.plot(x, pdf, linewidth=2, color='r')
>>> plt.axis('tight')
>>> plt.show()
>>> # Generate a thousand samples: each is the product of 100 random
>>> # values, drawn from a normal distribution.
>>> rng = rng
>>> b = []
>>> for i in range(1000):
...    a = 10. + rng.standard_normal(100)
...    b.append(np.prod(a))
>>> b = np.array(b) / np.min(b) # scale values to be positive
>>> count, bins, _ = plt.hist(b, 100, density=True, align='mid')
>>> sigma = np.std(np.log(b))
>>> mu = np.mean(np.log(b))
>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))
>>> plt.plot(x, pdf, color='r', linewidth=2)
>>> plt.show()"
numpy.random.Generator.logseries,method,"[{'Parameters': [{'name': 'p', 'type': 'float or array_like of floats', 'description': 'Shape parameter for the distribution.  Must be in the range [0, 1).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if p is a scalar.  Otherwise,np.array(p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized logarithmic series distribution.'}]}]",">>> a = .6
>>> rng = np.random.default_rng()
>>> s = rng.logseries(a, 10000)
>>> import matplotlib.pyplot as plt
>>> bins = np.arange(-.5, max(s) + .5 )
>>> count, bins, _ = plt.hist(s, bins=bins, label='Sample count')
>>> def logseries(k, p):
...     return -p**k/(k*np.log(1-p))
>>> centres = np.arange(1, max(s) + 1)
>>> plt.plot(centres, logseries(centres, a) * s.size, 'r', label='logseries PMF')
>>> plt.legend()
>>> plt.show()"
numpy.random.Generator.multinomial,method,"[{'Parameters': [{'name': 'n', 'type': 'int or array-like of ints', 'description': 'Number of experiments.'}, {'name': 'pvals', 'type': 'array-like of floats', 'description': 'Probabilities of each of the p different outcomes with shape(k0, k1, ..., kn, p). Each element pvals[i,j,...,:] mustsum to 1 (however, the last element is always assumed to accountfor the remaining probability, as long assum(pvals[..., :-1], axis=-1) <= 1.0. Must have at least 1dimension where pvals.shape[-1] > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn each with p elements. Defaultis None where the output size is determined by the broadcast shapeof n and all by the final dimension of pvals, which isdenoted as b=(b0, b1, ..., bq). If size is not None, then itmust be compatible with the broadcast shape b. Specifically,size must have q or more elements and size[-(q-j):] must equalbj.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The drawn samples, of shape size, if provided. When size isprovided, the output shape is size + (p,)  If not specified,the shape is determined by the broadcast shape of n andpvals, (b0, b1, ..., bq) augmented with the dimension ofthe multinomial, p, so that that output shape is(b0, b1, ..., bq, p).Each entry out[i,j,...,:] is a p-dimensional value drawnfrom the distribution.'}]}]",">>> rng = np.random.default_rng()
>>> rng.multinomial(20, [1/6.]*6, size=1)
array([[4, 1, 7, 5, 2, 1]])  # random
>>> rng.multinomial(20, [1/6.]*6, size=2)
array([[3, 4, 3, 3, 4, 3],
       [2, 4, 3, 4, 0, 7]])  # random
>>> rng.multinomial([[10], [20]], [1/6.]*6, size=(2, 2))
array([[[2, 4, 0, 1, 2, 1],
        [1, 3, 0, 3, 1, 2]],
       [[1, 4, 4, 4, 4, 3],
        [3, 3, 2, 5, 5, 2]]])  # random
>>> rng.multinomial(100, [1/7.]*5 + [2/7.])
array([11, 16, 14, 17, 16, 26])  # random
>>> rng.multinomial([10, 20],[[1/4]*4 + [0]*2, [1/6]*6])
array([[2, 1, 4, 3, 0, 0],
       [3, 3, 3, 6, 1, 4]], dtype=int64)  # random
>>> rng.multinomial(1, [[.1, .5, .4 ], [.3, .7, .0]])
array([[0, 0, 1],
       [0, 1, 0]], dtype=int64)  # random
>>> pvals = [[.1, .5, .4 ], [.3, .7, .0]]
>>> rvs = rng.multinomial(1, pvals, size=(4,2))
>>> rvs.argmax(axis=-1)
array([[0, 1],
       [2, 0],
       [2, 1],
       [2, 0]], dtype=int64)  # random
>>> rvs = rng.multinomial([[1]] * 4, pvals)
>>> rvs.argmax(axis=-1)
array([[0, 1],
       [2, 0],
       [2, 1],
       [2, 0]], dtype=int64)  # random
>>> rng.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
array([38, 62])  # random
>>> rng.multinomial(100, [1.0, 2.0])  # WRONG
Traceback (most recent call last):
ValueError: pvals < 0, pvals > 1 or pvals contains NaNs"
numpy.random.Generator.multivariate_hypergeometric,method,"[{'Parameters': [{'name': 'colors', 'type': 'sequence of integers', 'description': 'The number of each type of item in the collection from whicha sample is drawn.  The values in colors must be nonnegative.To avoid loss of precision in the algorithm, sum(colors)must be less than 10**9 when method is “marginals”.'}, {'name': 'nsample', 'type': 'int', 'description': 'The number of items selected.  nsample must not be greaterthan sum(colors).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'The number of variates to generate, either an integer or a tupleholding the shape of the array of variates.  If the given size is,e.g., (k, m), then k * m variates are drawn, where onevariate is a vector of length len(colors), and the return valuehas shape (k, m, len(colors)).  If size is an integer, theoutput has shape (size, len(colors)).  Default is None, inwhich case a single variate is returned as an array with shape(len(colors),).'}, {'name': 'method', 'type': 'string, optional', 'description': 'Specify the algorithm that is used to generate the variates.Must be ‘count’ or ‘marginals’ (the default).  See the Notesfor a description of the methods.'}]}, {'Returns': [{'name': 'variates', 'type': 'ndarray', 'description': 'Array of variates drawn from the multivariate hypergeometricdistribution.'}]}]",">>> colors = [16, 8, 4]
>>> seed = 4861946401452
>>> gen = np.random.Generator(np.random.PCG64(seed))
>>> gen.multivariate_hypergeometric(colors, 6)
array([5, 0, 1])
>>> gen.multivariate_hypergeometric(colors, 6, size=3)
array([[5, 0, 1],
       [2, 2, 2],
       [3, 3, 0]])
>>> gen.multivariate_hypergeometric(colors, 6, size=(2, 2))
array([[[3, 2, 1],
        [3, 2, 1]],
       [[4, 1, 1],
        [3, 2, 1]]])"
numpy.random.Generator.multivariate_normal,method,"[{'Parameters': [{'name': 'mean', 'type': '1-D array_like, of length N', 'description': 'Mean of the N-dimensional distribution.'}, {'name': 'cov', 'type': '2-D array_like, of shape (N, N)', 'description': 'Covariance matrix of the distribution. It must be symmetric andpositive-semidefinite for proper sampling.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Given a shape of, for example, (m,n,k), m*n*k samples aregenerated, and packed in an m-by-n-by-k arrangement.  Becauseeach sample is N-dimensional, the output shape is (m,n,k,N).If no shape is specified, a single (N-D) sample is returned.'}, {'name': 'check_valid', 'type': '{ ‘warn’, ‘raise’, ‘ignore’ }, optional', 'description': 'Behavior when the covariance matrix is not positive semidefinite.'}, {'name': 'tol', 'type': 'float, optional', 'description': 'Tolerance when checking the singular values in covariance matrix.cov is cast to double before the check.'}, {'name': 'method', 'type': '{ ‘svd’, ‘eigh’, ‘cholesky’}, optional', 'description': 'The cov input is used to compute a factor matrix A such thatA @ A.T = cov. This argument is used to select the methodused to compute the factor matrix A. The default method ‘svd’ isthe slowest, while ‘cholesky’ is the fastest but less robust thanthe slowest method. The method eigh uses eigen decomposition tocompute A and is faster than svd but slower than cholesky.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.'}]}]",">>> mean = [0, 0]
>>> cov = [[1, 0], [0, 100]]  # diagonal covariance
>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> x, y = rng.multivariate_normal(mean, cov, 5000).T
>>> plt.plot(x, y, 'x')
>>> plt.axis('equal')
>>> plt.show()
>>> mean = (1, 2)
>>> cov = [[1, 0], [0, 1]]
>>> rng = np.random.default_rng()
>>> x = rng.multivariate_normal(mean, cov, (3, 3))
>>> x.shape
(3, 3, 2)
>>> y = rng.multivariate_normal(mean, cov, (3, 3), method='cholesky')
>>> y.shape
(3, 3, 2)
>>> cov = np.array([[6, -3], [-3, 3.5]])
>>> pts = rng.multivariate_normal([0, 0], cov, size=800)
>>> pts.mean(axis=0)
array([ 0.0326911 , -0.01280782])  # may vary
>>> np.cov(pts.T)
array([[ 5.96202397, -2.85602287],
       [-2.85602287,  3.47613949]])  # may vary
>>> np.corrcoef(pts.T)[0, 1]
-0.6273591314603949  # may vary
>>> import matplotlib.pyplot as plt
>>> plt.plot(pts[:, 0], pts[:, 1], '.', alpha=0.5)
>>> plt.axis('equal')
>>> plt.grid()
>>> plt.show()"
numpy.random.Generator.negative_binomial,method,"[{'Parameters': [{'name': 'n', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, > 0.'}, {'name': 'p', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution. Must satisfy 0 < p <= 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if n and p are both scalars.Otherwise, np.broadcast(n, p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized negative binomial distribution,where each sample is equal to N, the number of failures thatoccurred before a total of n successes was reached.'}]}]",">>> rng = np.random.default_rng()
>>> s = rng.negative_binomial(1, 0.1, 100000)
>>> for i in range(1, 11): 
...    probability = sum(s<i) / 100000.
...    print(i, ""wells drilled, probability of one success ="", probability)"
numpy.random.Generator.noncentral_chisquare,method,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom, must be > 0.'}, {'name': 'nonc', 'type': 'float or array_like of floats', 'description': 'Non-centrality, must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df and nonc are both scalars.Otherwise, np.broadcast(df, nonc).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized noncentral chi-square distribution.'}]}]",">>> rng = np.random.default_rng()
>>> import matplotlib.pyplot as plt
>>> values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()
>>> plt.figure()
>>> values = plt.hist(rng.noncentral_chisquare(3, .0000001, 100000),
...                   bins=np.arange(0., 25, .1), density=True)
>>> values2 = plt.hist(rng.chisquare(3, 100000),
...                    bins=np.arange(0., 25, .1), density=True)
>>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
>>> plt.show()
>>> plt.figure()
>>> values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()"
numpy.random.Generator.noncentral_f,method,"[{'Parameters': [{'name': 'dfnum', 'type': 'float or array_like of floats', 'description': 'Numerator degrees of freedom, must be > 0.'}, {'name': 'dfden', 'type': 'float or array_like of floats', 'description': 'Denominator degrees of freedom, must be > 0.'}, {'name': 'nonc', 'type': 'float or array_like of floats', 'description': 'Non-centrality parameter, the sum of the squares of the numeratormeans, must be >= 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if dfnum, dfden, and noncare all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized noncentral Fisher distribution.'}]}]",">>> rng = np.random.default_rng()
>>> dfnum = 3 # between group deg of freedom
>>> dfden = 20 # within groups degrees of freedom
>>> nonc = 3.0
>>> nc_vals = rng.noncentral_f(dfnum, dfden, nonc, 1000000)
>>> NF = np.histogram(nc_vals, bins=50, density=True)
>>> c_vals = rng.f(dfnum, dfden, 1000000)
>>> F = np.histogram(c_vals, bins=50, density=True)
>>> import matplotlib.pyplot as plt
>>> plt.plot(F[1][1:], F[0])
>>> plt.plot(NF[1][1:], NF[0])
>>> plt.show()"
numpy.random.Generator.normal,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats', 'description': 'Mean (“centre”) of the distribution.'}, {'name': 'scale', 'type': 'float or array_like of floats', 'description': 'Standard deviation (spread or “width”) of the distribution. Must benon-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized normal distribution.'}]}]",">>> mu, sigma = 0, 0.1 # mean and standard deviation
>>> rng = np.random.default_rng()
>>> s = rng.normal(mu, sigma, 1000)
>>> abs(mu - np.mean(s))
0.0  # may vary
>>> abs(sigma - np.std(s, ddof=1))
0.0  # may vary
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 30, density=True)
>>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
>>> plt.show()
>>> rng = np.random.default_rng()
>>> rng.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.Generator.pareto,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Shape of the distribution. Must be positive.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the Pareto II distribution.'}]}]",">>> a = 3.
>>> rng = np.random.default_rng()
>>> s = rng.pareto(a, 10000)
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(0, 3, 50)
>>> pdf = a / (x+1)**(a+1)
>>> plt.hist(s, bins=x, density=True, label='histogram')
>>> plt.plot(x, pdf, linewidth=2, color='r', label='pdf')
>>> plt.xlim(x.min(), x.max())
>>> plt.legend()
>>> plt.show()"
numpy.random.Generator.poisson,method,"[{'Parameters': [{'name': 'lam', 'type': 'float or array_like of floats', 'description': 'Expected number of events occurring in a fixed-time interval,must be >= 0. A sequence must be broadcastable over the requestedsize.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if lam is a scalar. Otherwise,np.array(lam).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Poisson distribution.'}]}]",">>> rng = np.random.default_rng()
>>> lam, size = 5, 10000
>>> s = rng.poisson(lam=lam, size=size)
>>> s.mean(), s.var()
(4.9917 5.1088311)  # may vary
>>> import matplotlib.pyplot as plt
>>> from scipy import stats
>>> x = np.arange(0, 21)
>>> pmf = stats.poisson.pmf(x, mu=lam)
>>> plt.hist(s, bins=x, density=True, width=0.5)
>>> plt.stem(x, pmf, 'C1-')
>>> plt.show()
>>> s = rng.poisson(lam=(100., 500.), size=(100, 2))"
numpy.random.Generator.power,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized power distribution.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If a <= 0.'}]}]",">>> rng = np.random.default_rng()
>>> a = 5. # shape
>>> samples = 1000
>>> s = rng.power(a, samples)
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, bins=30)
>>> x = np.linspace(0, 1, 100)
>>> y = a*x**(a-1.)
>>> normed_y = samples*np.diff(bins)[0]*y
>>> plt.plot(x, normed_y)
>>> plt.show()
>>> from scipy import stats  
>>> rvs = rng.power(5, 1000000)
>>> rvsp = rng.pareto(5, 1000000)
>>> xx = np.linspace(0,1,100)
>>> powpdf = stats.powerlaw.pdf(xx,5)
>>> plt.figure()
>>> plt.hist(rvs, bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('power(5)')
>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('inverse of 1 + Generator.pareto(5)')
>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('inverse of stats.pareto(5)')"
numpy.random.Generator.rayleigh,method,"[{'Parameters': [{'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'Scale, also equals the mode. Must be non-negative. Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if scale is a scalar.  Otherwise,np.array(scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Rayleigh distribution.'}]}]",">>> from matplotlib.pyplot import hist
>>> rng = np.random.default_rng()
>>> values = hist(rng.rayleigh(3, 100000), bins=200, density=True)
>>> meanvalue = 1
>>> modevalue = np.sqrt(2 / np.pi) * meanvalue
>>> s = rng.rayleigh(modevalue, 1000000)
>>> 100.*sum(s>3)/1000000.
0.087300000000000003 # random"
numpy.random.Generator.standard_cauchy,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray or scalar', 'description': 'The drawn samples.'}]}]",">>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> s = rng.standard_cauchy(1000000)
>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
>>> plt.hist(s, bins=100)
>>> plt.show()"
numpy.random.Generator.standard_exponential,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Desired dtype of the result, only float64 and float32 are supported.Byteorder must be native. The default value is np.float64.'}, {'name': 'method', 'type': 'str, optional', 'description': 'Either ‘inv’ or ‘zig’. ‘inv’ uses the default inverse CDF method.‘zig’ uses the much faster Ziggurat method of Marsaglia and Tsang.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. If size is not None,it must have the same shape as the provided size and must match the type ofthe output values.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray', 'description': 'Drawn samples.'}]}]",">>> rng = np.random.default_rng()
>>> n = rng.standard_exponential((3, 8000))"
numpy.random.Generator.standard_gamma,method,"[{'Parameters': [{'name': 'shape', 'type': 'float or array_like of floats', 'description': 'Parameter, must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if shape is a scalar.  Otherwise,np.array(shape).size samples are drawn.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Desired dtype of the result, only float64 and float32 are supported.Byteorder must be native. The default value is np.float64.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. If size isnot None, it must have the same shape as the provided size andmust match the type of the output values.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized standard gamma distribution.'}]}]",">>> shape, scale = 2., 1. # mean and width
>>> rng = np.random.default_rng()
>>> s = rng.standard_gamma(shape, 1000000)
>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  
>>> count, bins, _ = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1) * ((np.exp(-bins/scale))/  
...                       (sps.gamma(shape) * scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.Generator.standard_normal,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Desired dtype of the result, only float64 and float32 are supported.Byteorder must be native. The default value is np.float64.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. If size is not None,it must have the same shape as the provided size and must match the type ofthe output values.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray', 'description': 'A floating-point array of shape size of drawn samples, or asingle sample if size was not specified.'}]}]",">>> rng = np.random.default_rng()
>>> rng.standard_normal()
2.1923875335537315 # random
>>> s = rng.standard_normal(8000)
>>> s
array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
       -0.38672696, -0.4685006 ])                                # random
>>> s.shape
(8000,)
>>> s = rng.standard_normal(size=(3, 4, 2))
>>> s.shape
(3, 4, 2)
>>> 3 + 2.5 * rng.standard_normal(size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.Generator.standard_t,method,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df is a scalar.  Otherwise,np.array(df).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized standard Student’s t distribution.'}]}]",">>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
...                    7515, 8230, 8770])
>>> np.mean(intake)
6753.636363636364
>>> intake.std(ddof=1)
1142.1232221373727
>>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
>>> t
-2.8207540608310198
>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> s = rng.standard_t(10, size=1000000)
>>> h = plt.hist(s, bins=100, density=True)
>>> np.sum(np.abs(t) < np.abs(s)) / float(len(s))
0.018318  #random < 0.05, statistic is in critical region"
numpy.random.Generator.triangular,method,"[{'Parameters': [{'name': 'left', 'type': 'float or array_like of floats', 'description': 'Lower limit.'}, {'name': 'mode', 'type': 'float or array_like of floats', 'description': 'The value where the peak of the distribution occurs.The value must fulfill the condition left <= mode <= right.'}, {'name': 'right', 'type': 'float or array_like of floats', 'description': 'Upper limit, must be larger than left.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if left, mode, and rightare all scalars.  Otherwise, np.broadcast(left, mode, right).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized triangular distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> h = plt.hist(rng.triangular(-3, 0, 8, 100000), bins=200,
...              density=True)
>>> plt.show()"
numpy.random.Generator.uniform,method,"[{'Parameters': [{'name': 'low', 'type': 'float or array_like of floats, optional', 'description': 'Lower boundary of the output interval.  All values generated will begreater than or equal to low.  The default value is 0.'}, {'name': 'high', 'type': 'float or array_like of floats', 'description': 'Upper boundary of the output interval.  All values generated will beless than high.  The high limit may be included in the returned array of floats due to floating-point rounding in the equation low + (high-low) * random_sample().  high - low must be non-negative.  The default value is 1.0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if low and high are both scalars.Otherwise, np.broadcast(low, high).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized uniform distribution.'}]}]",">>> rng = np.random.default_rng()
>>> s = rng.uniform(-1,0,1000)
>>> np.all(s >= -1)
True
>>> np.all(s < 0)
True
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 15, density=True)
>>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
>>> plt.show()"
numpy.random.Generator.vonmises,method,"[{'Parameters': [{'name': 'mu', 'type': 'float or array_like of floats', 'description': 'Mode (“center”) of the distribution.'}, {'name': 'kappa', 'type': 'float or array_like of floats', 'description': 'Concentration of the distribution, has to be >=0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mu and kappa are both scalars.Otherwise, np.broadcast(mu, kappa).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized von Mises distribution.'}]}]",">>> mu, kappa = 0.0, 4.0 # mean and concentration
>>> rng = np.random.default_rng()
>>> s = rng.vonmises(mu, kappa, 1000)
>>> import matplotlib.pyplot as plt
>>> from scipy.special import i0  
>>> plt.hist(s, 50, density=True)
>>> x = np.linspace(-np.pi, np.pi, num=51)
>>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  
>>> plt.plot(x, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.Generator.wald,method,"[{'Parameters': [{'name': 'mean', 'type': 'float or array_like of floats', 'description': 'Distribution mean, must be > 0.'}, {'name': 'scale', 'type': 'float or array_like of floats', 'description': 'Scale parameter, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mean and scale are both scalars.Otherwise, np.broadcast(mean, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Wald distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> h = plt.hist(rng.wald(3, 2, 100000), bins=200, density=True)
>>> plt.show()"
numpy.random.Generator.weibull,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Shape parameter of the distribution.  Must be nonnegative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Weibull distribution.'}]}]",">>> rng = np.random.default_rng()
>>> a = 5. # shape
>>> s = rng.weibull(a, 1000)
>>> import matplotlib.pyplot as plt
>>> def weibull(x, n, a):
...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)
>>> count, bins, _ = plt.hist(rng.weibull(5., 1000))
>>> x = np.linspace(0, 2, 1000)
>>> bin_spacing = np.mean(np.diff(bins))
>>> plt.plot(x, weibull(x, 1., 5.) * bin_spacing * s.size, label='Weibull PDF')
>>> plt.legend()
>>> plt.show()"
numpy.random.Generator.zipf,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Distribution parameter. Must be greater than 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar. Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Zipf distribution.'}]}]",">>> a = 4.0
>>> n = 20000
>>> rng = np.random.default_rng()
>>> s = rng.zipf(a, size=n)
>>> import matplotlib.pyplot as plt
>>> from scipy.special import zeta
>>> count = np.bincount(s)
>>> k = np.arange(1, s.max() + 1)
>>> plt.bar(k, count[1:], alpha=0.5, label='sample count')
>>> plt.plot(k, n*(k**-a)/zeta(a), 'k.-', alpha=0.5,
...          label='expected count')   
>>> plt.semilogy()
>>> plt.grid(alpha=0.4)
>>> plt.legend()
>>> plt.title(f'Zipf sample, a={a}, size={n}')
>>> plt.show()"
numpy.fft.fft,Compute the one-dimensional discrete Fourier Transform.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, can be complex.'}, {'name': 'n', 'type': 'int, optional', 'description': 'Length of the transformed axis of the output.If n is smaller than the length of the input, the input is cropped.If it is larger, the input is padded with zeros.  If n is not given,the length of the input along the axis specified by axis is used.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which to compute the FFT.  If not given, the last axis isused.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.'}]}, {'Raises': [{'name': 'IndexError', 'type': None, 'description': 'If axis is not a valid axis of a.'}]}]",">>> import numpy as np
>>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])
>>> import matplotlib.pyplot as plt
>>> t = np.arange(256)
>>> sp = np.fft.fft(np.sin(t))
>>> freq = np.fft.fftfreq(t.shape[-1])
>>> plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
>>> plt.show()"
numpy.fft.ifft,Compute the one-dimensional inverse discrete Fourier Transform.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, can be complex.'}, {'name': 'n', 'type': 'int, optional', 'description': 'Length of the transformed axis of the output.If n is smaller than the length of the input, the input is cropped.If it is larger, the input is padded with zeros.  If n is not given,the length of the input along the axis specified by axis is used.See notes about padding issues.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which to compute the inverse DFT.  If not given, the lastaxis is used.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.'}]}, {'Raises': [{'name': 'IndexError', 'type': None, 'description': 'If axis is not a valid axis of a.'}]}]",">>> import numpy as np
>>> np.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary
>>> import matplotlib.pyplot as plt
>>> t = np.arange(400)
>>> n = np.zeros((400,), dtype=complex)
>>> n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))
>>> s = np.fft.ifft(n)
>>> plt.plot(t, s.real, label='real')
[<matplotlib.lines.Line2D object at ...>]
>>> plt.plot(t, s.imag, '--', label='imaginary')
[<matplotlib.lines.Line2D object at ...>]
>>> plt.legend()
<matplotlib.legend.Legend object at ...>
>>> plt.show()"
numpy.fft.fft2,Compute the 2-dimensional discrete Fourier Transform.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, can be complex'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape (length of each transformed axis) of the output(s[0] refers to axis 0, s[1] to axis 1, etc.).This corresponds to n for fft(x, n).Along each axis, if the given shape is smaller than that of the input,the input is cropped. If it is larger, the input is padded with zeros.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).If s is not given, the shape of the input along the axes specifiedby axes is used.Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'Axes over which to compute the FFT.  If not given, the last twoaxes are used.  A repeated index in axes means the transform overthat axis is performed multiple times.  A one-element sequence meansthat a one-dimensional FFT is performed. Default: (-2, -1).Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust not be None.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for all axes (and hence only thelast axis can have s not equal to the shape at that axis).New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axesindicated by axes, or the last two axes if axes is not given.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If s and axes have different length, or axes not given andlen(s) != 2.'}, {'name': 'IndexError', 'type': None, 'description': 'If an element of axes is larger than than the number of axes of a.'}]}]",">>> import numpy as np
>>> a = np.mgrid[:5, :5][0]
>>> np.fft.fft2(a)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ],
       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
          0.  +0.j        ,   0.  +0.j        ]])"
numpy.fft.ifft2,Compute the 2-dimensional inverse discrete Fourier Transform.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, can be complex.'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape (length of each axis) of the output (s[0] refers to axis 0,s[1] to axis 1, etc.).  This corresponds to n for ifft(x, n).Along each axis, if the given shape is smaller than that of the input,the input is cropped. If it is larger, the input is padded with zeros.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).If s is not given, the shape of the input along the axes specifiedby axes is used.  See notes for issue on ifft zero padding.Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'Axes over which to compute the FFT.  If not given, the last twoaxes are used.  A repeated index in axes means the transform overthat axis is performed multiple times.  A one-element sequence meansthat a one-dimensional FFT is performed. Default: (-2, -1).Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust not be None.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for all axes (and hence isincompatible with passing in all but the trivial s).New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axesindicated by axes, or the last two axes if axes is not given.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If s and axes have different length, or axes not given andlen(s) != 2.'}, {'name': 'IndexError', 'type': None, 'description': 'If an element of axes is larger than than the number of axes of a.'}]}]",">>> import numpy as np
>>> a = 4 * np.eye(4)
>>> np.fft.ifft2(a)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])"
numpy.fft.fftn,Compute the N-dimensional discrete Fourier Transform.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, can be complex.'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape (length of each transformed axis) of the output(s[0] refers to axis 0, s[1] to axis 1, etc.).This corresponds to n for fft(x, n).Along any axis, if the given shape is smaller than that of the input,the input is cropped. If it is larger, the input is padded with zeros.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).If s is not given, the shape of the input along the axes specifiedby axes is used.Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'Axes over which to compute the FFT.  If not given, the last len(s)axes are used, or all axes if s is also not specified.Repeated indices in axes means that the transform over that axis isperformed multiple times.Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust be explicitly specified too.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for all axes (and hence isincompatible with passing in all but the trivial s).New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s and a,as explained in the parameters section above.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If s and axes have different length.'}, {'name': 'IndexError', 'type': None, 'description': 'If an element of axes is larger than than the number of axes of a.'}]}]",">>> import numpy as np
>>> a = np.mgrid[:3, :3, :3][0]
>>> np.fft.fftn(a, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[ 9.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]],
       [[18.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j],
        [ 0.+0.j,   0.+0.j,   0.+0.j]]])
>>> np.fft.fftn(a, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
        [ 0.+0.j,  0.+0.j,  0.+0.j]],
       [[-2.+0.j, -2.+0.j, -2.+0.j],
        [ 0.+0.j,  0.+0.j,  0.+0.j]]])
>>> import matplotlib.pyplot as plt
>>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
>>> S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
>>> FS = np.fft.fftn(S)
>>> plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))
<matplotlib.image.AxesImage object at 0x...>
>>> plt.show()"
numpy.fft.ifftn,Compute the N-dimensional inverse discrete Fourier Transform.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, can be complex.'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape (length of each transformed axis) of the output(s[0] refers to axis 0, s[1] to axis 1, etc.).This corresponds to n for ifft(x, n).Along any axis, if the given shape is smaller than that of the input,the input is cropped. If it is larger, the input is padded with zeros.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).If s is not given, the shape of the input along the axes specifiedby axes is used. See notes for issue on ifft zero padding.Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'Axes over which to compute the IFFT.  If not given, the last len(s)axes are used, or all axes if s is also not specified.Repeated indices in axes means that the inverse transform over thataxis is performed multiple times.Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust be explicitly specified too.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for all axes (and hence isincompatible with passing in all but the trivial s).New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s or a,as explained in the parameters section above.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If s and axes have different length.'}, {'name': 'IndexError', 'type': None, 'description': 'If an element of axes is larger than than the number of axes of a.'}]}]",">>> import numpy as np
>>> a = np.eye(4)
>>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])
>>> import matplotlib.pyplot as plt
>>> n = np.zeros((200,200), dtype=complex)
>>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
>>> im = np.fft.ifftn(n).real
>>> plt.imshow(im)
<matplotlib.image.AxesImage object at 0x...>
>>> plt.show()"
numpy.fft.rfft,Compute the one-dimensional discrete Fourier Transform for real input.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array'}, {'name': 'n', 'type': 'int, optional', 'description': 'Number of points along transformation axis in the input to use.If n is smaller than the length of the input, the input is cropped.If it is larger, the input is padded with zeros. If n is not given,the length of the input along the axis specified by axis is used.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which to compute the FFT. If not given, the last axis isused.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.If n is even, the length of the transformed axis is (n/2)+1.If n is odd, the length is (n+1)/2.'}]}, {'Raises': [{'name': 'IndexError', 'type': None, 'description': 'If axis is not a valid axis of a.'}]}]",">>> import numpy as np
>>> np.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
>>> np.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary"
numpy.fft.irfft,Computes the inverse of rfft.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The input array.'}, {'name': 'n', 'type': 'int, optional', 'description': 'Length of the transformed axis of the output.For n output points, n//2+1 input points are necessary.  If theinput is longer than this, it is cropped.  If it is shorter than this,it is padded with zeros.  If n is not given, it is taken to be2*(m-1) where m is the length of the input along the axisspecified by axis.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which to compute the inverse FFT. If not given, the lastaxis is used.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.The length of the transformed axis is n, or, if n is not given,2*(m-1) where m is the length of the transformed axis of theinput. To get an odd number of output points, n must be specified.'}]}, {'Raises': [{'name': 'IndexError', 'type': None, 'description': 'If axis is not a valid axis of a.'}]}]",">>> import numpy as np
>>> np.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
>>> np.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])"
numpy.fft.rfft2,Compute the 2-dimensional FFT of a real array.,"[{'Parameters': [{'name': 'a', 'type': 'array', 'description': 'Input array, taken to be real.'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape of the FFT.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'Axes over which to compute the FFT. Default: (-2, -1).Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust not be None.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for the last inverse transform.incompatible with passing in all but the trivial s).New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The result of the real 2-D FFT.'}]}]",">>> import numpy as np
>>> a = np.mgrid[:5, :5][0]
>>> np.fft.rfft2(a)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],
       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ]])"
numpy.fft.irfft2,Computes the inverse of rfft2.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The input array'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape of the real output to the inverse FFT.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'The axes over which to compute the inverse fft.Default: (-2, -1), the last two axes.Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust not be None.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for the last transformation.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The result of the inverse real 2-D FFT.'}]}]",">>> import numpy as np
>>> a = np.mgrid[:5, :5][0]
>>> A = np.fft.rfft2(a)
>>> np.fft.irfft2(A, s=a.shape)
array([[0., 0., 0., 0., 0.],
       [1., 1., 1., 1., 1.],
       [2., 2., 2., 2., 2.],
       [3., 3., 3., 3., 3.],
       [4., 4., 4., 4., 4.]])"
numpy.fft.rfftn,Compute the N-dimensional discrete Fourier Transform for real input.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, taken to be real.'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape (length along each transformed axis) to use from the input.(s[0] refers to axis 0, s[1] to axis 1, etc.).The final element of s corresponds to n for rfft(x, n), whilefor the remaining axes, it corresponds to n for fft(x, n).Along any axis, if the given shape is smaller than that of the input,the input is cropped. If it is larger, the input is padded with zeros.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).If s is not given, the shape of the input along the axes specifiedby axes is used.Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'Axes over which to compute the FFT.  If not given, the last len(s)axes are used, or all axes if s is also not specified.Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust be explicitly specified too.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for all axes (and hence isincompatible with passing in all but the trivial s).New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s and a,as explained in the parameters section above.The length of the last axis transformed will be s[-1]//2+1,while the remaining transformed axes will have lengths according tos, or unchanged from the input.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If s and axes have different length.'}, {'name': 'IndexError', 'type': None, 'description': 'If an element of axes is larger than than the number of axes of a.'}]}]",">>> import numpy as np
>>> a = np.ones((2, 2, 2))
>>> np.fft.rfftn(a)
array([[[8.+0.j,  0.+0.j], # may vary
        [0.+0.j,  0.+0.j]],
       [[0.+0.j,  0.+0.j],
        [0.+0.j,  0.+0.j]]])
>>> np.fft.rfftn(a, axes=(2, 0))
array([[[4.+0.j,  0.+0.j], # may vary
        [4.+0.j,  0.+0.j]],
       [[0.+0.j,  0.+0.j],
        [0.+0.j,  0.+0.j]]])"
numpy.fft.irfftn,Computes the inverse of rfftn.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 's', 'type': 'sequence of ints, optional', 'description': 'Shape (length of each transformed axis) of the output(s[0] refers to axis 0, s[1] to axis 1, etc.). s is also thenumber of input points used along this axis, except for the last axis,where s[-1]//2+1 points of the input are used.Along any axis, if the shape indicated by s is smaller than that ofthe input, the input is cropped.  If it is larger, the input is paddedwith zeros.Changed in version 2.0: If it is -1, the whole input is used (no padding/trimming).If s is not given, the shape of the input along the axesspecified by axes is used. Except for the last axis which is taken tobe 2*(m-1) where m is the length of the input along that axis.Deprecated since version 2.0: If s is not None, axes must not be None either.Deprecated since version 2.0: s must contain only int s, not None values. Nonevalues currently mean that the default value for n is usedin the corresponding 1-D transform, but this behaviour isdeprecated.'}, {'name': 'axes', 'type': 'sequence of ints, optional', 'description': 'Axes over which to compute the inverse FFT. If not given, the lastlen(s) axes are used, or all axes if s is also not specified.Repeated indices in axes means that the inverse transform over thataxis is performed multiple times.Deprecated since version 2.0: If s is specified, the corresponding axes to be transformedmust be explicitly specified too.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype for the last transformation.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s or a,as explained in the parameters section above.The length of each transformed axis is as given by the correspondingelement of s, or the length of the input in every axis except for thelast one if s is not given.  In the final transformed axis the lengthof the output when s is not given is 2*(m-1) where m is thelength of the final transformed axis of the input.  To get an oddnumber of output points in the final axis, s must be specified.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If s and axes have different length.'}, {'name': 'IndexError', 'type': None, 'description': 'If an element of axes is larger than than the number of axes of a.'}]}]",">>> import numpy as np
>>> a = np.zeros((3, 2, 2))
>>> a[0, 0, 0] = 3 * 2 * 2
>>> np.fft.irfftn(a)
array([[[1.,  1.],
        [1.,  1.]],
       [[1.,  1.],
        [1.,  1.]],
       [[1.,  1.],
        [1.,  1.]]])"
numpy.fft.hfft,"Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The input array.'}, {'name': 'n', 'type': 'int, optional', 'description': 'Length of the transformed axis of the output. For n outputpoints, n//2 + 1 input points are necessary.  If the input islonger than this, it is cropped.  If it is shorter than this, it ispadded with zeros.  If n is not given, it is taken to be 2*(m-1)where m is the length of the input along the axis specified byaxis.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which to compute the FFT. If not given, the lastaxis is used.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.The length of the transformed axis is n, or, if n is not given,2*m - 2 where m is the length of the transformed axis ofthe input. To get an odd number of output points, n must bespecified, for instance as 2*m - 1 in the typical case,'}]}, {'Raises': [{'name': 'IndexError', 'type': None, 'description': 'If axis is not a valid axis of a.'}]}]",">>> import numpy as np
>>> signal = np.array([1, 2, 3, 4, 3, 2])
>>> np.fft.fft(signal)
array([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary
>>> np.fft.hfft(signal[:4]) # Input first half of signal
array([15.,  -4.,   0.,  -1.,   0.,  -4.])
>>> np.fft.hfft(signal, 6)  # Input entire signal and truncate
array([15.,  -4.,   0.,  -1.,   0.,  -4.])
>>> signal = np.array([[1, 1.j], [-1.j, 2]])
>>> np.conj(signal.T) - signal   # check Hermitian symmetry
array([[ 0.-0.j,  -0.+0.j], # may vary
       [ 0.+0.j,  0.-0.j]])
>>> freq_spectrum = np.fft.hfft(signal)
>>> freq_spectrum
array([[ 1.,  1.],
       [ 2., -2.]])"
numpy.fft.ihfft,Compute the inverse FFT of a signal that has Hermitian symmetry.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'n', 'type': 'int, optional', 'description': 'Length of the inverse FFT, the number of points alongtransformation axis in the input to use.  If n is smaller thanthe length of the input, the input is cropped.  If it is larger,the input is padded with zeros. If n is not given, the length ofthe input along the axis specified by axis is used.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which to compute the inverse FFT. If not given, the lastaxis is used.'}, {'name': 'norm', 'type': '{“backward”, “ortho”, “forward”}, optional', 'description': 'Normalization mode (see numpy.fft). Default is “backward”.Indicates which direction of the forward/backward pair of transformsis scaled and with what normalization factor.New in version 1.20.0: The “backward”, “forward” values were added.'}, {'name': 'out', 'type': 'complex ndarray, optional', 'description': 'If provided, the result will be placed in this array. It should beof the appropriate shape and dtype.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'The truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.The length of the transformed axis is n//2 + 1.'}]}]",">>> import numpy as np
>>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])
>>> np.fft.ifft(spectrum)
array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
>>> np.fft.ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary"
numpy.fft.fftfreq,Return the Discrete Fourier Transform sample frequencies.,"[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'Window length.'}, {'name': 'd', 'type': 'scalar, optional', 'description': 'Sample spacing (inverse of the sampling rate). Defaults to 1.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'f', 'type': 'ndarray', 'description': 'Array of length n containing the sample frequencies.'}]}]",">>> import numpy as np
>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
>>> fourier = np.fft.fft(signal)
>>> n = signal.size
>>> timestep = 0.1
>>> freq = np.fft.fftfreq(n, d=timestep)
>>> freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])"
numpy.fft.rfftfreq,"Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).","[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'Window length.'}, {'name': 'd', 'type': 'scalar, optional', 'description': 'Sample spacing (inverse of the sampling rate). Defaults to 1.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'f', 'type': 'ndarray', 'description': 'Array of length n//2 + 1 containing the sample frequencies.'}]}]",">>> import numpy as np
>>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
>>> fourier = np.fft.rfft(signal)
>>> n = signal.size
>>> sample_rate = 100
>>> freq = np.fft.fftfreq(n, d=1./sample_rate)
>>> freq
array([  0.,  10.,  20., ..., -30., -20., -10.])
>>> freq = np.fft.rfftfreq(n, d=1./sample_rate)
>>> freq
array([  0.,  10.,  20.,  30.,  40.,  50.])"
numpy.fft.fftshift,Shift the zero-frequency component to the center of the spectrum.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axes', 'type': 'int or shape tuple, optional', 'description': 'Axes over which to shift.  Default is None, which shifts all axes.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The shifted array.'}]}]",">>> import numpy as np
>>> freqs = np.fft.fftfreq(10, 0.1)
>>> freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
>>> np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
>>> freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
>>> np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
       [-4.,  3.,  4.],
       [-1., -3., -2.]])"
numpy.fft.ifftshift,"The inverse of fftshift. Although identical for even-length x, the
functions differ by one sample for odd-length x.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axes', 'type': 'int or shape tuple, optional', 'description': 'Axes over which to calculate.  Defaults to None, which shifts all axes.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The shifted array.'}]}]",">>> import numpy as np
>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
>>> freqs
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])
>>> np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
       [ 3.,  4., -4.],
       [-3., -2., -1.]])"
numpy.polynomial.chebyshev.Chebyshev,A Chebyshev series class.,"[{'Parameters': [{'name': 'coef', 'type': 'array_like', 'description': 'Chebyshev coefficients in order of increasing degree, i.e.,(1, 2, 3) gives 1*T_0(x) + 2*T_1(x) + 3*T_2(x).'}, {'name': 'domain', 'type': '(2,) array_like, optional', 'description': 'Domain to use. The interval [domain[0], domain[1]] is mappedto the interval [window[0], window[1]] by shifting and scaling.The default value is [-1., 1.].'}, {'name': 'window', 'type': '(2,) array_like, optional', 'description': 'Window, see domain for its use. The default value is [-1., 1.].'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol used to represent the independent variable in stringrepresentations of the polynomial expression, e.g. for printing.The symbol must be a valid Python identifier. Default value is ‘x’.New in version 1.24.'}]}, {'Attributes': [{'name': 'symbol', 'type': None, 'description': ''}]}]",
numpy.polynomial.chebyshev.Chebyshev.__call__,method,[],
numpy.polynomial.chebyshev.Chebyshev.basis,method,"[{'Parameters': [{'name': 'deg', 'type': 'int', 'description': 'Degree of the basis polynomial for the series. Must be >= 0.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series with the coefficient of the deg term set to one andall others zero.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.cast,method,"[{'Parameters': [{'name': 'series', 'type': 'series', 'description': 'The series instance to be converted.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series of the same kind as the calling class and equal toseries when evaluated.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.convert,method,"[{'Parameters': [{'name': 'domain', 'type': 'array_like, optional', 'description': 'The domain of the converted series. If the value is None,the default domain of kind is used.'}, {'name': 'kind', 'type': 'class, optional', 'description': 'The polynomial series type class to which the current instanceshould be converted. If kind is None, then the class of thecurrent instance is used.'}, {'name': 'window', 'type': 'array_like, optional', 'description': 'The window of the converted series. If the value is None,the default window of kind is used.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'The returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.copy,method,"[{'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Copy of self.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.cutdeg,method,"[{'Parameters': [{'name': 'deg', 'type': 'non-negative int', 'description': 'The series is reduced to degree deg by discarding the highorder terms. The value of deg must be a non-negative integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with reduced degree.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.degree,method,"[{'Returns': [{'name': 'degree', 'type': 'int', 'description': 'Degree of the series, one less than the number of coefficients.'}]}]",">>> poly = np.polynomial.Polynomial([1, 7, 4])
>>> print(poly)
1.0 + 7.0·x + 4.0·x²
>>> poly.degree()
2
>>> poly = np.polynomial.Polynomial([1, 7, 0])
>>> print(poly)
1.0 + 7.0·x + 0.0·x²
>>> poly.degree()
2
>>> poly.trim().degree()
1"
numpy.polynomial.chebyshev.Chebyshev.deriv,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'Find the derivative of order m.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the derivative. The domain is the sameas the domain of the differentiated series.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.fit,method,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (M,)', 'description': 'x-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'y', 'type': 'array_like, shape (M,)', 'description': 'y-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'deg', 'type': 'int or 1-D array_like', 'description': 'Degree(s) of the fitting polynomials. If deg is a single integerall terms up to and including the deg’th term are included in thefit. For NumPy versions >= 1.11.0 a list of integers specifying thedegrees of the terms to include may be used instead.'}, {'name': 'domain', 'type': '{None, [beg, end], []}, optional', 'description': 'Domain to use for the returned series. If None,then a minimal domain that covers the points x is chosen.  If[] the class domain is used. The default value was theclass domain in NumPy 1.4 and None in later versions.The [] option was added in numpy 1.5.0.'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Relative condition number of the fit. Singular values smallerthan this relative to the largest singular value will beignored. The default value is len(x)*eps, where eps is therelative precision of the float type, about 2e-16 in mostcases.'}, {'name': 'full', 'type': 'bool, optional', 'description': 'Switch determining nature of return value. When it is False(the default) just the coefficients are returned, when Truediagnostic information from the singular value decomposition isalso returned.'}, {'name': 'w', 'type': 'array_like, shape (M,), optional', 'description': 'Weights. If not None, the weight w[i] applies to the unsquaredresidual y[i] - y_hat[i] at x[i]. Ideally the weights arechosen so that the errors of the products w[i]*y[i] all havethe same variance.  When using inverse-variance weighting, usew[i] = 1/sigma(y[i]).  The default value is None.'}, {'name': 'window', 'type': '{[beg, end]}, optional', 'description': 'Window to use for the returned series. The defaultvalue is the default class domain'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.'}, {'name': '[resid, rank, sv, rcond]', 'type': 'list', 'description': 'These values are only returned if full == Trueresid – sum of squared residuals of the least squares fitrank – the numerical rank of the scaled Vandermonde matrixsv – singular values of the scaled Vandermonde matrixrcond – value of rcond.For more details, see linalg.lstsq.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.fromroots,method,"[{'Parameters': [{'name': 'roots', 'type': 'array_like', 'description': 'List of roots.'}, {'name': 'domain', 'type': '{[], None, array_like}, optional', 'description': 'Domain for the resulting series. If None the domain is theinterval from the smallest root to the largest. If [] thedomain is the class domain. The default is [].'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'Window for the returned series. If None the class window isused. The default is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series with the specified roots.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.has_samecoef,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the coef attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the coefficients are the same, False otherwise.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.has_samedomain,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the domain attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the domains are the same, False otherwise.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.has_sametype,method,"[{'Parameters': [{'name': 'other', 'type': 'object', 'description': 'Class instance.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if other is same class as self'}]}]",
numpy.polynomial.chebyshev.Chebyshev.has_samewindow,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the window attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the windows are the same, False otherwise.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.identity,method,"[{'Parameters': [{'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series of representing the identity.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.integ,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'The number of integrations to perform.'}, {'name': 'k', 'type': 'array_like', 'description': 'Integration constants. The first constant is applied to thefirst integration, the second to the second, and so on. Thelist of values must less than or equal to m in length and anymissing values are set to zero.'}, {'name': 'lbnd', 'type': 'Scalar', 'description': 'The lower bound of the definite integral.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the integral. The domain is the sameas the domain of the integrated series.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.interpolate,method,"[{'Parameters': [{'name': 'func', 'type': 'function', 'description': 'The function to be interpolated. It must be a function of a singlevariable of the form f(x, a, b, c...), where a, b, c... areextra arguments passed in the args parameter.'}, {'name': 'deg', 'type': 'int', 'description': 'Degree of the interpolating polynomial.'}, {'name': 'domain', 'type': '{None, [beg, end]}, optional', 'description': 'Domain over which func is interpolated. The default is None, inwhich case the domain is [-1, 1].'}, {'name': 'args', 'type': 'tuple, optional', 'description': 'Extra arguments to be used in the function call. Default is noextra arguments.'}]}, {'Returns': [{'name': 'polynomial', 'type': 'Chebyshev instance', 'description': 'Interpolating Chebyshev instance.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.linspace,method,"[{'Parameters': [{'name': 'n', 'type': 'int, optional', 'description': 'Number of point pairs to return. The default value is 100.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If not None, the specified domain is used instead of that ofthe calling instance. It should be of the form [beg,end].The default is None which case the class domain is used.'}]}, {'Returns': [{'name': 'x, y', 'type': 'ndarray', 'description': 'x is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.mapparms,method,"[{'Returns': [{'name': 'off, scl', 'type': 'float or complex', 'description': 'The mapping function is defined by off + scl*x.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.roots,method,"[{'Returns': [{'name': 'roots', 'type': 'ndarray', 'description': 'Array containing the roots of the series.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.trim,method,"[{'Parameters': [{'name': 'tol', 'type': 'non-negative number.', 'description': 'All trailing coefficients less than tol will be removed.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with trimmed coefficients.'}]}]",
numpy.polynomial.chebyshev.Chebyshev.truncate,method,"[{'Parameters': [{'name': 'size', 'type': 'positive int', 'description': 'The series is reduced to length size by discarding the highdegree terms. The value of size must be a positive integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with truncated coefficients.'}]}]",
numpy.all,Test whether all array elements along a given axis evaluate to True.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array or object that can be converted to an array.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which a logical AND reduction is performed.The default (axis=None) is to perform a logical AND over allthe dimensions of the input array. axis may be negative, inwhich case it counts from the last to the first axis. If thisis a tuple of ints, a reduction is performed on multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.It must have the same shape as the expected output and itstype is preserved (e.g., if dtype(out) is float, the resultwill consist of 0.0’s and 1.0’s). See Output type determinationfor more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the all method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in checking for all True values.See reduce for details.New in version 1.20.0.'}]}, {'Returns': [{'name': 'all', 'type': 'ndarray, bool', 'description': 'A new boolean or array is returned unless out is specified,in which case a reference to out is returned.'}]}]",">>> import numpy as np
>>> np.all([[True,False],[True,True]])
False
>>> np.all([[True,False],[True,True]], axis=0)
array([ True, False])
>>> np.all([-1, 4, 5])
True
>>> np.all([1.0, np.nan])
True
>>> np.all([[True, True], [False, True]], where=[[True], [False]])
True
>>> o=np.array(False)
>>> z=np.all([-1, 4, 5], out=o)
>>> id(z), id(o), z
(28293632, 28293632, array(True)) # may vary"
numpy.any,Test whether any array element along a given axis evaluates to True.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array or object that can be converted to an array.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which a logical OR reduction is performed.The default (axis=None) is to perform a logical OR over allthe dimensions of the input array. axis may be negative, inwhich case it counts from the last to the first axis. If thisis a tuple of ints, a reduction is performed on multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  It must havethe same shape as the expected output and its type is preserved(e.g., if it is of type float, then it will remain so, returning1.0 for True and 0.0 for False, regardless of the type of a).See Output type determination for more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the any method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in checking for any True values.See reduce for details.New in version 1.20.0.'}]}, {'Returns': [{'name': 'any', 'type': 'bool or ndarray', 'description': 'A new boolean or ndarray is returned unless out is specified,in which case a reference to out is returned.'}]}]",">>> import numpy as np
>>> np.any([[True, False], [True, True]])
True
>>> np.any([[True,  False, True ],
...         [False, False, False]], axis=0)
array([ True, False, True])
>>> np.any([-1, 0, 5])
True
>>> np.any([[np.nan], [np.inf]], axis=1, keepdims=True)
array([[ True],
       [ True]])
>>> np.any([[True, False], [False, False]], where=[[False], [True]])
False
>>> a = np.array([[1, 0, 0],
...               [0, 0, 1],
...               [0, 0, 0]])
>>> np.any(a, axis=0)
array([ True, False,  True])
>>> np.any(a, axis=1)
array([ True,  True, False])
>>> o=np.array(False)
>>> z=np.any([-1, 4, 5], out=o)
>>> z, o
(array(True), array(True))
>>> # Check now that z is a reference to o
>>> z is o
True
>>> id(z), id(o) # identity of z and o              
(191614240, 191614240)"
numpy.isfinite,Test element-wise for finiteness (not infinity and not Not a Number).,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray, bool', 'description': 'True where x is not positive infinity, negative infinity,or NaN; false otherwise.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.isfinite(1)
True
>>> np.isfinite(0)
True
>>> np.isfinite(np.nan)
False
>>> np.isfinite(np.inf)
False
>>> np.isfinite(-np.inf)
False
>>> np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False])
>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isfinite(x, y)
array([0, 1, 0])
>>> y
array([0, 1, 0])"
numpy.isinf,Test element-wise for positive or negative infinity.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'bool (scalar) or boolean ndarray', 'description': 'True where x is positive or negative infinity, false otherwise.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.isinf(np.inf)
True
>>> np.isinf(np.nan)
False
>>> np.isinf(-np.inf)
True
>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])
array([ True,  True, False, False])
>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isinf(x, y)
array([1, 0, 1])
>>> y
array([1, 0, 1])"
numpy.isnan,Test element-wise for NaN and return result as a boolean array.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or bool', 'description': 'True where x is NaN, false otherwise.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.isnan(np.nan)
True
>>> np.isnan(np.inf)
False
>>> np.isnan([np.log(-1.),1.,np.log(0)])
array([ True, False, False])"
numpy.isnat,Test element-wise for NaT (not a time) and return result as a boolean array.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array with datetime or timedelta data type.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or bool', 'description': 'True where x is NaT, false otherwise.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.isnat(np.datetime64(""NaT""))
True
>>> np.isnat(np.datetime64(""2016-01-01""))
False
>>> np.isnat(np.array([""NaT"", ""2016-01-01""], dtype=""datetime64[ns]""))
array([ True, False])"
numpy.isneginf,"Test element-wise for negative infinity, return result as bool array.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The input array.'}, {'name': 'out', 'type': 'array_like, optional', 'description': 'A location into which the result is stored. If provided, it must have ashape that the input broadcasts to. If not provided or None, afreshly-allocated boolean array is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'A boolean array with the same dimensions as the input.If second argument is not supplied then a numpy boolean array isreturned with values True where the corresponding element of theinput is negative infinity and values False where the element ofthe input is not negative infinity.If a second argument is supplied the result is stored there. If thetype of that array is a numeric type the result is represented aszeros and ones, if the type is boolean then as False and True. Thereturn value out is then a reference to that array.'}]}]",">>> import numpy as np
>>> np.isneginf(-np.inf)
True
>>> np.isneginf(np.inf)
False
>>> np.isneginf([-np.inf, 0., np.inf])
array([ True, False, False])
>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isneginf(x, y)
array([1, 0, 0])
>>> y
array([1, 0, 0])"
numpy.isposinf,"Test element-wise for positive infinity, return result as bool array.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The input array.'}, {'name': 'out', 'type': 'array_like, optional', 'description': 'A location into which the result is stored. If provided, it must have ashape that the input broadcasts to. If not provided or None, afreshly-allocated boolean array is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'A boolean array with the same dimensions as the input.If second argument is not supplied then a boolean array is returnedwith values True where the corresponding element of the input ispositive infinity and values False where the element of the input isnot positive infinity.If a second argument is supplied the result is stored there. If thetype of that array is a numeric type the result is represented as zerosand ones, if the type is boolean then as False and True.The return value out is then a reference to that array.'}]}]",">>> import numpy as np
>>> np.isposinf(np.inf)
True
>>> np.isposinf(-np.inf)
False
>>> np.isposinf([-np.inf, 0., np.inf])
array([False, False,  True])
>>> x = np.array([-np.inf, 0., np.inf])
>>> y = np.array([2, 2, 2])
>>> np.isposinf(x, y)
array([0, 0, 1])
>>> y
array([0, 0, 1])"
numpy.iscomplex,"Returns a bool array, where True if input element is complex.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray of bools', 'description': 'Output array.'}]}]",">>> import numpy as np
>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([ True, False, False, False, False,  True])"
numpy.iscomplexobj,Check for a complex type or an array of complex numbers.,"[{'Parameters': [{'name': 'x', 'type': 'any', 'description': 'The input can be of any type and shape.'}]}, {'Returns': [{'name': 'iscomplexobj', 'type': 'bool', 'description': 'The return value, True if x is of a complex type or has at leastone complex element.'}]}]",">>> import numpy as np
>>> np.iscomplexobj(1)
False
>>> np.iscomplexobj(1+0j)
True
>>> np.iscomplexobj([3, 1+0j, True])
True"
numpy.isfortran,Check if the array is Fortran contiguous but not C contiguous.,"[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'Input array.'}]}, {'Returns': [{'name': 'isfortran', 'type': 'bool', 'description': 'Returns True if the array is Fortran contiguous but not C contiguous.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False
>>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')
>>> b
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(b)
True
>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False
>>> b = a.T
>>> b
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> np.isfortran(b)
True
>>> np.isfortran(np.array([1, 2], order='F'))
False"
numpy.isreal,"Returns a bool array, where True if input element is real.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray, bool', 'description': 'Boolean array of same shape as x.'}]}]",">>> import numpy as np
>>> a = np.array([1+1j, 1+0j, 4.5, 3, 2, 2j], dtype=complex)
>>> np.isreal(a)
array([False,  True,  True,  True,  True, False])
>>> a = np.array([2j, ""a""], dtype=""U"")
>>> np.isreal(a)  # Warns about non-elementwise comparison
False
>>> a = np.array([1, ""2"", 3+4j], dtype=object)
>>> np.isreal(a)
array([ True,  True,  True])
>>> a = np.array([1+2j, 2+1j], dtype=object)
>>> np.isreal(a)
array([ True,  True])"
numpy.isrealobj,Return True if x is a not complex type or an array of complex numbers.,"[{'Parameters': [{'name': 'x', 'type': 'any', 'description': 'The input can be of any type and shape.'}]}, {'Returns': [{'name': 'y', 'type': 'bool', 'description': 'The return value, False if x is of a complex type.'}]}]",">>> np.isrealobj('A string')
True
>>> np.isrealobj(False)
True
>>> np.isrealobj(None)
True
>>> import numpy as np
>>> np.isrealobj(1)
True
>>> np.isrealobj(1+0j)
False
>>> np.isrealobj([3, 1+0j, True])
False"
numpy.isscalar,Returns True if the type of element is a scalar type.,"[{'Parameters': [{'name': 'element', 'type': 'any', 'description': 'Input argument, can be of any type and shape.'}]}, {'Returns': [{'name': 'val', 'type': 'bool', 'description': 'True if element is a scalar type, False if it is not.'}]}]",">>> import numpy as np
>>> np.isscalar(3.1)
True
>>> np.isscalar(np.array(3.1))
False
>>> np.isscalar([3.1])
False
>>> np.isscalar(False)
True
>>> np.isscalar('numpy')
True
>>> from fractions import Fraction
>>> np.isscalar(Fraction(5, 17))
True
>>> from numbers import Number
>>> np.isscalar(Number())
True"
numpy.logical_and,Compute the truth value of x1 AND x2 element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or bool', 'description': 'Boolean result of the logical AND operation applied to the elementsof x1 and x2; the shape is determined by broadcasting.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.logical_and(True, False)
False
>>> np.logical_and([True, False], [False, False])
array([False, False])
>>> x = np.arange(5)
>>> np.logical_and(x>1, x<4)
array([False, False,  True,  True, False])
>>> a = np.array([True, False])
>>> b = np.array([False, False])
>>> a & b
array([False, False])"
numpy.logical_or,Compute the truth value of x1 OR x2 element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Logical OR is applied to the elements of x1 and x2.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or bool', 'description': 'Boolean result of the logical OR operation applied to the elementsof x1 and x2; the shape is determined by broadcasting.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.logical_or(True, False)
True
>>> np.logical_or([True, False], [False, False])
array([ True, False])
>>> x = np.arange(5)
>>> np.logical_or(x < 1, x > 3)
array([ True, False, False, False,  True])
>>> a = np.array([True, False])
>>> b = np.array([False, False])
>>> a | b
array([ True, False])"
numpy.logical_not,Compute the truth value of NOT x element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Logical NOT is applied to the elements of x.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'bool or ndarray of bool', 'description': 'Boolean result with the same shape as x of the NOT operationon elements of x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.logical_not(3)
False
>>> np.logical_not([True, False, 0, 1])
array([False,  True,  True, False])
>>> x = np.arange(5)
>>> np.logical_not(x<3)
array([False, False, False,  True,  True])"
numpy.logical_xor,"Compute the truth value of x1 XOR x2, element-wise.","[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Logical XOR is applied to the elements of x1 and x2.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'bool or ndarray of bool', 'description': 'Boolean result of the logical XOR operation applied to the elementsof x1 and x2; the shape is determined by broadcasting.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.logical_xor(True, False)
True
>>> np.logical_xor([True, True, False, False], [True, False, True, False])
array([False,  True,  True, False])
>>> x = np.arange(5)
>>> np.logical_xor(x < 1, x > 3)
array([ True, False, False, False,  True])
>>> np.logical_xor(0, np.eye(2))
array([[ True, False],
       [False,  True]])"
numpy.allclose,Returns True if two arrays are element-wise equal within a tolerance.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'Input arrays to compare.'}, {'name': 'rtol', 'type': 'array_like', 'description': 'The relative tolerance parameter (see Notes).'}, {'name': 'atol', 'type': 'array_like', 'description': 'The absolute tolerance parameter (see Notes).'}, {'name': 'equal_nan', 'type': 'bool', 'description': 'Whether to compare NaN’s as equal.  If True, NaN’s in a will beconsidered equal to NaN’s in b in the output array.'}]}, {'Returns': [{'name': 'allclose', 'type': 'bool', 'description': 'Returns True if the two arrays are equal within the giventolerance; False otherwise.'}]}]",">>> import numpy as np
>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
False
>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
True
>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
False
>>> np.allclose([1.0, np.nan], [1.0, np.nan])
False
>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
True"
numpy.isclose,"Returns a boolean array where two arrays are element-wise equal within a
tolerance.","[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'Input arrays to compare.'}, {'name': 'rtol', 'type': 'array_like', 'description': 'The relative tolerance parameter (see Notes).'}, {'name': 'atol', 'type': 'array_like', 'description': 'The absolute tolerance parameter (see Notes).'}, {'name': 'equal_nan', 'type': 'bool', 'description': 'Whether to compare NaN’s as equal.  If True, NaN’s in a will beconsidered equal to NaN’s in b in the output array.'}]}, {'Returns': [{'name': 'y', 'type': 'array_like', 'description': 'Returns a boolean array of where a and b are equal within thegiven tolerance. If both a and b are scalars, returns a singleboolean value.'}]}]",">>> import numpy as np
>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
array([ True, False])
>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
array([ True, True])
>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
array([False,  True])
>>> np.isclose([1.0, np.nan], [1.0, np.nan])
array([ True, False])
>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
array([ True, True])
>>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
array([ True, False])
>>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
array([False, False])
>>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
array([ True,  True])
>>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
array([False,  True])"
numpy.array_equal,"True if two arrays have the same shape and elements, False otherwise.","[{'Parameters': [{'name': 'a1, a2', 'type': 'array_like', 'description': 'Input arrays.'}, {'name': 'equal_nan', 'type': 'bool', 'description': 'Whether to compare NaN’s as equal. If the dtype of a1 and a2 iscomplex, values will be considered equal if either the real or theimaginary component of a given value is nan.'}]}, {'Returns': [{'name': 'b', 'type': 'bool', 'description': 'Returns True if the arrays are equal.'}]}]",">>> import numpy as np
>>> np.array_equal([1, 2], [1, 2])
True
>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
True
>>> np.array_equal([1, 2], [1, 2, 3])
False
>>> np.array_equal([1, 2], [1, 4])
False
>>> a = np.array([1, np.nan])
>>> np.array_equal(a, a)
False
>>> np.array_equal(a, a, equal_nan=True)
True
>>> a = np.array([1 + 1j])
>>> b = a.copy()
>>> a.real = np.nan
>>> b.imag = np.nan
>>> np.array_equal(a, b, equal_nan=True)
True"
numpy.array_equiv,Returns True if input arrays are shape consistent and all elements equal.,"[{'Parameters': [{'name': 'a1, a2', 'type': 'array_like', 'description': 'Input arrays.'}]}, {'Returns': [{'name': 'out', 'type': 'bool', 'description': 'True if equivalent, False otherwise.'}]}]",">>> import numpy as np
>>> np.array_equiv([1, 2], [1, 2])
True
>>> np.array_equiv([1, 2], [1, 3])
False
>>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
True
>>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
False
>>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
False"
numpy.greater,Return the truth value of (x1 > x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.greater([4,2],[2,2])
array([ True, False])
>>> a = np.array([4, 2])
>>> b = np.array([2, 2])
>>> a > b
array([ True, False])"
numpy.greater_equal,Return the truth value of (x1 >= x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'bool or ndarray of bool', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.greater_equal([4, 2, 1], [2, 2, 2])
array([ True, True, False])
>>> a = np.array([4, 2, 1])
>>> b = np.array([2, 2, 2])
>>> a >= b
array([ True,  True, False])"
numpy.less,Return the truth value of (x1 < x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.less([1, 2], [2, 2])
array([ True, False])
>>> a = np.array([1, 2])
>>> b = np.array([2, 2])
>>> a < b
array([ True, False])"
numpy.less_equal,Return the truth value of (x1 <= x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.less_equal([4, 2, 1], [2, 2, 2])
array([False,  True,  True])
>>> a = np.array([4, 2, 1])
>>> b = np.array([2, 2, 2])
>>> a <= b
array([False,  True,  True])"
numpy.equal,Return (x1 == x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.equal([0, 1, 3], np.arange(3))
array([ True,  True, False])
>>> np.equal(1, np.ones(1))
array([ True])
>>> a = np.array([2, 4, 6])
>>> b = np.array([2, 4, 2])
>>> a == b
array([ True,  True, False])"
numpy.not_equal,Return (x1 != x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.not_equal([1.,2.], [1., 3.])
array([False,  True])
>>> np.not_equal([1, 2], [[1, 3],[1, 4]])
array([[False,  True],
       [False,  True]])
>>> a = np.array([1., 2.])
>>> b = np.array([1., 3.])
>>> a != b
array([False,  True])"
numpy.poly1d,A one-dimensional polynomial class.,"[{'Parameters': [{'name': 'c_or_r', 'type': 'array_like', 'description': 'The polynomial’s coefficients, in decreasing powers, or ifthe value of the second parameter is True, the polynomial’sroots (values where the polynomial evaluates to 0).  For example,poly1d([1, 2, 3]) returns an object that represents\\(x^2 + 2x + 3\\), whereas poly1d([1, 2, 3], True) returnsone that represents \\((x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6\\).'}, {'name': 'r', 'type': 'bool, optional', 'description': 'If True, c_or_r specifies the polynomial’s roots; the defaultis False.'}, {'name': 'variable', 'type': 'str, optional', 'description': 'Changes the variable used when printing p from x to variable(see Examples).'}]}, {'Attributes': [{'name': 'c', 'type': None, 'description': 'The polynomial coefficients'}, {'name': 'coef', 'type': None, 'description': 'The polynomial coefficients'}, {'name': 'coefficients', 'type': None, 'description': 'The polynomial coefficients'}, {'name': 'coeffs', 'type': None, 'description': 'The polynomial coefficients'}, {'name': 'o', 'type': None, 'description': 'The order or degree of the polynomial'}, {'name': 'order', 'type': None, 'description': 'The order or degree of the polynomial'}, {'name': 'r', 'type': None, 'description': 'The roots of the polynomial, where self(x) == 0'}, {'name': 'roots', 'type': None, 'description': 'The roots of the polynomial, where self(x) == 0'}, {'name': 'variable', 'type': None, 'description': 'The name of the polynomial variable'}]}]",">>> import numpy as np
>>> p = np.poly1d([1, 2, 3])
>>> print(np.poly1d(p))
   2
1 x + 2 x + 3
>>> p(0.5)
4.25
>>> p.r
array([-1.+1.41421356j, -1.-1.41421356j])
>>> p(p.r)
array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary
>>> p.c
array([1, 2, 3])
>>> p.order
2
>>> p[1]
2
>>> p * p
poly1d([ 1,  4, 10, 12,  9])
>>> (p**3 + 4) / p
(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))
>>> p**2 # square of polynomial
poly1d([ 1,  4, 10, 12,  9])
>>> np.square(p) # square of individual coefficients
array([1, 4, 9])
>>> p = np.poly1d([1,2,3], variable='z')
>>> print(p)
   2
1 z + 2 z + 3
>>> np.poly1d([1, 2], True)
poly1d([ 1., -3.,  2.])
>>> np.poly1d([1, -1]) * np.poly1d([1, -2])
poly1d([ 1, -3,  2])"
numpy.polynomial,A sub-package for efficiently dealing with polynomials.,[],
numpy.polynomial.set_default_printstyle,Set the default format for the string representation of polynomials.,"[{'Parameters': [{'name': 'style', 'type': 'str', 'description': 'Format string for default printing style. Must be either ‘ascii’ or‘unicode’.'}]}]",">>> p = np.polynomial.Polynomial([1, 2, 3])
>>> c = np.polynomial.Chebyshev([1, 2, 3])
>>> np.polynomial.set_default_printstyle('unicode')
>>> print(p)
1.0 + 2.0·x + 3.0·x²
>>> print(c)
1.0 + 2.0·T₁(x) + 3.0·T₂(x)
>>> np.polynomial.set_default_printstyle('ascii')
>>> print(p)
1.0 + 2.0 x + 3.0 x**2
>>> print(c)
1.0 + 2.0 T_1(x) + 3.0 T_2(x)
>>> # Formatting supersedes all class/package-level defaults
>>> print(f""{p:unicode}"")
1.0 + 2.0·x + 3.0·x²"
numpy.bartlett,Return the Bartlett window.,"[{'Parameters': [{'name': 'M', 'type': 'int', 'description': 'Number of points in the output window. If zero or less, anempty array is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'array', 'description': 'The triangular window, with the maximum value normalized to one(the value one appears only if the number of samples is odd), withthe first and last samples equal to zero.'}]}]",">>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> np.bartlett(12)
array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary
        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
        0.18181818,  0.        ])"
numpy.blackman,Return the Blackman window.,"[{'Parameters': [{'name': 'M', 'type': 'int', 'description': 'Number of points in the output window. If zero or less, an emptyarray is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The window, with the maximum value normalized to one (the value oneappears only if the number of samples is odd).'}]}]",">>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> np.blackman(12)
array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary
        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])"
numpy.hamming,Return the Hamming window.,"[{'Parameters': [{'name': 'M', 'type': 'int', 'description': 'Number of points in the output window. If zero or less, anempty array is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The window, with the maximum value normalized to one (the valueone appears only if the number of samples is odd).'}]}]",">>> import numpy as np
>>> np.hamming(12)
array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary
        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
        0.15302337,  0.08      ])"
numpy.hanning,Return the Hanning window.,"[{'Parameters': [{'name': 'M', 'type': 'int', 'description': 'Number of points in the output window. If zero or less, anempty array is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray, shape(M,)', 'description': 'The window, with the maximum value normalized to one (the valueone appears only if M is odd).'}]}]",">>> import numpy as np
>>> np.hanning(12)
array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,
       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,
       0.07937323, 0.        ])"
numpy.kaiser,Return the Kaiser window.,"[{'Parameters': [{'name': 'M', 'type': 'int', 'description': 'Number of points in the output window. If zero or less, anempty array is returned.'}, {'name': 'beta', 'type': 'float', 'description': 'Shape parameter for window.'}]}, {'Returns': [{'name': 'out', 'type': 'array', 'description': 'The window, with the maximum value normalized to one (the valueone appears only if the number of samples is odd).'}]}]",">>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> np.kaiser(12, 14)
 array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary
        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,
        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,
        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])"
numpy.copyto,"Copies values from one array to another, broadcasting as necessary.","[{'Parameters': [{'name': 'dst', 'type': 'ndarray', 'description': 'The array into which values are copied.'}, {'name': 'src', 'type': 'array_like', 'description': 'The array from which values are copied.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur when copying.‘no’ means the data types should not be cast at all.‘equiv’ means only byte-order changes are allowed.‘safe’ means only casts which can preserve values are allowed.‘same_kind’ means only safe casts or casts within a kind,like float64 to float32, are allowed.‘unsafe’ means any data conversions may be done.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'A boolean array which is broadcasted to match the dimensionsof dst, and selects elements to copy from src to dstwherever it contains the value True.'}]}]",">>> import numpy as np
>>> A = np.array([4, 5, 6])
>>> B = [1, 2, 3]
>>> np.copyto(A, B)
>>> A
array([1, 2, 3])
>>> A = np.array([[1, 2, 3], [4, 5, 6]])
>>> B = [[4, 5, 6], [7, 8, 9]]
>>> np.copyto(A, B)
>>> A
array([[4, 5, 6],
       [7, 8, 9]])"
numpy.ndim,Return the number of dimensions of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.  If it is not already an ndarray, a conversion isattempted.'}]}, {'Returns': [{'name': 'number_of_dimensions', 'type': 'int', 'description': 'The number of dimensions in a.  Scalars are zero-dimensional.'}]}]",">>> import numpy as np
>>> np.ndim([[1,2,3],[4,5,6]])
2
>>> np.ndim(np.array([[1,2,3],[4,5,6]]))
2
>>> np.ndim(1)
0"
numpy.shape,Return the shape of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'shape', 'type': 'tuple of ints', 'description': 'The elements of the shape tuple give the lengths of thecorresponding array dimensions.'}]}]",">>> import numpy as np
>>> np.shape(np.eye(3))
(3, 3)
>>> np.shape([[1, 3]])
(1, 2)
>>> np.shape([0])
(1,)
>>> np.shape(0)
()
>>> a = np.array([(1, 2), (3, 4), (5, 6)],
...              dtype=[('x', 'i4'), ('y', 'i4')])
>>> np.shape(a)
(3,)
>>> a.shape
(3,)"
numpy.size,Return the number of elements along a given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the elements are counted.  By default, givethe total number of elements.'}]}, {'Returns': [{'name': 'element_count', 'type': 'int', 'description': 'Number of elements along the specified axis.'}]}]",">>> import numpy as np
>>> a = np.array([[1,2,3],[4,5,6]])
>>> np.size(a)
6
>>> np.size(a,1)
3
>>> np.size(a,0)
2"
numpy.reshape,Gives a new shape to an array without changing its data.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array to be reshaped.'}, {'name': 'shape', 'type': 'int or tuple of ints', 'description': 'The new shape should be compatible with the original shape. Ifan integer, then the result will be a 1-D array of that length.One shape dimension can be -1. In this case, the value isinferred from the length of the array and remaining dimensions.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’}, optional', 'description': 'Read the elements of a using this index order, and place theelements into the reshaped array using this index order. ‘C’means to read / write the elements using C-like index order,with the last axis index changing fastest, back to the firstaxis index changing slowest. ‘F’ means to read / write theelements using Fortran-like index order, with the first indexchanging fastest, and the last index changing slowest. Note thatthe ‘C’ and ‘F’ options take no account of the memory layout ofthe underlying array, and only refer to the order of indexing.‘A’ means to read / write the elements in Fortran-like indexorder if a is Fortran contiguous in memory, C-like orderotherwise.'}, {'name': 'newshape', 'type': 'int or tuple of ints', 'description': 'Deprecated since version 2.1: Replaced by shape argument. Retained for backwardcompatibility.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If True, then the array data is copied. If None, a copy willonly be made if it’s required by order. For False it raisesa ValueError if a copy cannot be avoided. Default: None.'}]}, {'Returns': [{'name': 'reshaped_array', 'type': 'ndarray', 'description': 'This will be a new view object if possible; otherwise, it willbe a copy.  Note there is no guarantee of the memory layout (C- orFortran- contiguous) of the returned array.'}]}]",">>> a = np.arange(6).reshape((3, 2))
>>> a
array([[0, 1],
       [2, 3],
       [4, 5]])
>>> np.reshape(a, (2, 3)) # C-like index ordering
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
array([[0, 4, 3],
       [2, 1, 5]])
>>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
array([[0, 4, 3],
       [2, 1, 5]])
>>> import numpy as np
>>> a = np.array([[1,2,3], [4,5,6]])
>>> np.reshape(a, 6)
array([1, 2, 3, 4, 5, 6])
>>> np.reshape(a, 6, order='F')
array([1, 4, 2, 5, 3, 6])
>>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
array([[1, 2],
       [3, 4],
       [5, 6]])"
numpy.ravel,Return a contiguous flattened array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.  The elements in a are read in the order specified byorder, and packed as a 1-D array.'}, {'name': 'order', 'type': '{‘C’,’F’, ‘A’, ‘K’}, optional', 'description': 'The elements of a are read using this index order. ‘C’ meansto index the elements in row-major, C-style order,with the last axis index changing fastest, back to the firstaxis index changing slowest.  ‘F’ means to index the elementsin column-major, Fortran-style order, with thefirst index changing fastest, and the last index changingslowest. Note that the ‘C’ and ‘F’ options take no account ofthe memory layout of the underlying array, and only refer tothe order of axis indexing.  ‘A’ means to read the elements inFortran-like index order if a is Fortran contiguous inmemory, C-like order otherwise.  ‘K’ means to read theelements in the order they occur in memory, except forreversing the data when strides are negative.  By default, ‘C’index order is used.'}]}, {'Returns': [{'name': 'y', 'type': 'array_like', 'description': 'y is a contiguous 1-D array of the same subtype as a,with shape (a.size,).Note that matrices are special cased for backward compatibility,if a is a matrix, then y is a 1-D ndarray.'}]}]",">>> import numpy as np
>>> x = np.array([[1, 2, 3], [4, 5, 6]])
>>> np.ravel(x)
array([1, 2, 3, 4, 5, 6])
>>> x.reshape(-1)
array([1, 2, 3, 4, 5, 6])
>>> np.ravel(x, order='F')
array([1, 4, 2, 5, 3, 6])
>>> np.ravel(x.T)
array([1, 4, 2, 5, 3, 6])
>>> np.ravel(x.T, order='A')
array([1, 2, 3, 4, 5, 6])
>>> a = np.arange(3)[::-1]; a
array([2, 1, 0])
>>> a.ravel(order='C')
array([2, 1, 0])
>>> a.ravel(order='K')
array([2, 1, 0])
>>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
array([[[ 0,  2,  4],
        [ 1,  3,  5]],
       [[ 6,  8, 10],
        [ 7,  9, 11]]])
>>> a.ravel(order='C')
array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
>>> a.ravel(order='K')
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])"
numpy.ndarray.flat,attribute,[],">>> import numpy as np
>>> x = np.arange(1, 7).reshape(2, 3)
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
>>> x.flat[3]
4
>>> x.T
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> x.T.flat[3]
5
>>> type(x.flat)
<class 'numpy.flatiter'>
>>> x.flat = 3; x
array([[3, 3, 3],
       [3, 3, 3]])
>>> x.flat[[1,4]] = 1; x
array([[3, 1, 3],
       [3, 1, 3]])"
numpy.ndarray.flatten,method,"[{'Parameters': [{'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': '‘C’ means to flatten in row-major (C-style) order.‘F’ means to flatten in column-major (Fortran-style) order. ‘A’ means to flatten in column-majororder if a is Fortran contiguous in memory,row-major order otherwise. ‘K’ means to flattena in the order the elements occur in memory.The default is ‘C’.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'A copy of the input array, flattened to one dimension.'}]}]",">>> import numpy as np
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])"
numpy.moveaxis,Move axes of an array to new positions.,"[{'Parameters': [{'name': 'a', 'type': 'np.ndarray', 'description': 'The array whose axes should be reordered.'}, {'name': 'source', 'type': 'int or sequence of int', 'description': 'Original positions of the axes to move. These must be unique.'}, {'name': 'destination', 'type': 'int or sequence of int', 'description': 'Destination positions for each of the original axes. These must also beunique.'}]}, {'Returns': [{'name': 'result', 'type': 'np.ndarray', 'description': 'Array with moved axes. This array is a view of the input array.'}]}]",">>> import numpy as np
>>> x = np.zeros((3, 4, 5))
>>> np.moveaxis(x, 0, -1).shape
(4, 5, 3)
>>> np.moveaxis(x, -1, 0).shape
(5, 3, 4)
>>> np.transpose(x).shape
(5, 4, 3)
>>> np.swapaxes(x, 0, -1).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1], [-1, -2]).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
(5, 4, 3)"
numpy.rollaxis,"Roll the specified axis backwards, until it lies in a given position.","[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int', 'description': 'The axis to be rolled. The positions of the other axes do notchange relative to one another.'}, {'name': 'start', 'type': 'int, optional', 'description': 'When start <= axis, the axis is rolled back until it lies inthis position. When start > axis, the axis is rolled until itlies before this position. The default, 0, results in a “complete”roll. The following table describes how negative values of startare interpreted:startNormalized start-(arr.ndim+1)raise AxisError-arr.ndim0⋮⋮-1arr.ndim-100⋮⋮arr.ndimarr.ndimarr.ndim + 1raise AxisError'}]}, {'Returns': [{'name': 'res', 'type': 'ndarray', 'description': 'For NumPy >= 1.10.0 a view of a is always returned. For earlierNumPy versions a view of a is returned only if the order of theaxes is changed, otherwise the input array is returned.'}]}]",">>> import numpy as np
>>> a = np.ones((3,4,5,6))
>>> np.rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
>>> np.rollaxis(a, 2).shape
(5, 3, 4, 6)
>>> np.rollaxis(a, 1, 4).shape
(3, 5, 6, 4)"
numpy.swapaxes,Interchange two axes of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis1', 'type': 'int', 'description': 'First axis.'}, {'name': 'axis2', 'type': 'int', 'description': 'Second axis.'}]}, {'Returns': [{'name': 'a_swapped', 'type': 'ndarray', 'description': 'For NumPy >= 1.10.0, if a is an ndarray, then a view of a isreturned; otherwise a new array is created. For earlier NumPyversions a view of a is returned only if the order of theaxes is changed, otherwise the input array is returned.'}]}]",">>> import numpy as np
>>> x = np.array([[1,2,3]])
>>> np.swapaxes(x,0,1)
array([[1],
       [2],
       [3]])
>>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
>>> x
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> np.swapaxes(x,0,2)
array([[[0, 4],
        [2, 6]],
       [[1, 5],
        [3, 7]]])"
numpy.ndarray.T,attribute,[],">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.T
array([[1, 3],
       [2, 4]])
>>> a = np.array([1, 2, 3, 4])
>>> a
array([1, 2, 3, 4])
>>> a.T
array([1, 2, 3, 4])"
numpy.transpose,Returns an array with axes transposed.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axes', 'type': 'tuple or list of ints, optional', 'description': 'If specified, it must be a tuple or list which contains a permutationof [0, 1, …, N-1] where N is the number of axes of a. Negativeindices can also be used to specify axes. The i-th axis of the returnedarray will correspond to the axis numbered axes[i] of the input.If not specified, defaults to range(a.ndim)[::-1], which reversesthe order of the axes.'}]}, {'Returns': [{'name': 'p', 'type': 'ndarray', 'description': 'a with its axes permuted. A view is returned whenever possible.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> np.transpose(a)
array([[1, 3],
       [2, 4]])
>>> a = np.array([1, 2, 3, 4])
>>> a
array([1, 2, 3, 4])
>>> np.transpose(a)
array([1, 2, 3, 4])
>>> a = np.ones((1, 2, 3))
>>> np.transpose(a, (1, 0, 2)).shape
(2, 1, 3)
>>> a = np.ones((2, 3, 4, 5))
>>> np.transpose(a).shape
(5, 4, 3, 2)
>>> a = np.arange(3*4*5).reshape((3, 4, 5))
>>> np.transpose(a, (-1, 0, -2)).shape
(5, 3, 4)"
numpy.permute_dims,Returns an array with axes transposed.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axes', 'type': 'tuple or list of ints, optional', 'description': 'If specified, it must be a tuple or list which contains a permutationof [0, 1, …, N-1] where N is the number of axes of a. Negativeindices can also be used to specify axes. The i-th axis of the returnedarray will correspond to the axis numbered axes[i] of the input.If not specified, defaults to range(a.ndim)[::-1], which reversesthe order of the axes.'}]}, {'Returns': [{'name': 'p', 'type': 'ndarray', 'description': 'a with its axes permuted. A view is returned whenever possible.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> np.transpose(a)
array([[1, 3],
       [2, 4]])
>>> a = np.array([1, 2, 3, 4])
>>> a
array([1, 2, 3, 4])
>>> np.transpose(a)
array([1, 2, 3, 4])
>>> a = np.ones((1, 2, 3))
>>> np.transpose(a, (1, 0, 2)).shape
(2, 1, 3)
>>> a = np.ones((2, 3, 4, 5))
>>> np.transpose(a).shape
(5, 4, 3, 2)
>>> a = np.arange(3*4*5).reshape((3, 4, 5))
>>> np.transpose(a, (-1, 0, -2)).shape
(5, 3, 4)"
numpy.matrix_transpose,Transposes a matrix (or a stack of matrices) x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array having shape (…, M, N) and whose two innermostdimensions form MxN matrices.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array containing the transpose for each matrix and having shape(…, N, M).'}]}]",">>> import numpy as np
>>> np.matrix_transpose([[1, 2], [3, 4]])
array([[1, 3],
       [2, 4]])
>>> np.matrix_transpose([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
array([[[1, 3],
        [2, 4]],
       [[5, 7],
        [6, 8]]])"
numpy.atleast_1d,Convert inputs to arrays with at least one dimension.,"[{'Parameters': [{'name': 'arys1, arys2, …', 'type': 'array_like', 'description': 'One or more input arrays.'}]}, {'Returns': [{'name': 'ret', 'type': 'ndarray', 'description': 'An array, or tuple of arrays, each with a.ndim >= 1.Copies are made only if necessary.'}]}]",">>> import numpy as np
>>> np.atleast_1d(1.0)
array([1.])
>>> x = np.arange(9.0).reshape(3,3)
>>> np.atleast_1d(x)
array([[0., 1., 2.],
       [3., 4., 5.],
       [6., 7., 8.]])
>>> np.atleast_1d(x) is x
True
>>> np.atleast_1d(1, [3, 4])
(array([1]), array([3, 4]))"
numpy.atleast_2d,View inputs as arrays with at least two dimensions.,"[{'Parameters': [{'name': 'arys1, arys2, …', 'type': 'array_like', 'description': 'One or more array-like sequences.  Non-array inputs are convertedto arrays.  Arrays that already have two or more dimensions arepreserved.'}]}, {'Returns': [{'name': 'res, res2, …', 'type': 'ndarray', 'description': 'An array, or tuple of arrays, each with a.ndim >= 2.Copies are avoided where possible, and views with two or moredimensions are returned.'}]}]",">>> import numpy as np
>>> np.atleast_2d(3.0)
array([[3.]])
>>> x = np.arange(3.0)
>>> np.atleast_2d(x)
array([[0., 1., 2.]])
>>> np.atleast_2d(x).base is x
True
>>> np.atleast_2d(1, [1, 2], [[1, 2]])
(array([[1]]), array([[1, 2]]), array([[1, 2]]))"
numpy.atleast_3d,View inputs as arrays with at least three dimensions.,"[{'Parameters': [{'name': 'arys1, arys2, …', 'type': 'array_like', 'description': 'One or more array-like sequences.  Non-array inputs are converted toarrays.  Arrays that already have three or more dimensions arepreserved.'}]}, {'Returns': [{'name': 'res1, res2, …', 'type': 'ndarray', 'description': 'An array, or tuple of arrays, each with a.ndim >= 3.  Copies areavoided where possible, and views with three or more dimensions arereturned.  For example, a 1-D array of shape (N,) becomes a viewof shape (1, N, 1), and a 2-D array of shape (M, N) becomes aview of shape (M, N, 1).'}]}]",">>> import numpy as np
>>> np.atleast_3d(3.0)
array([[[3.]]])
>>> x = np.arange(3.0)
>>> np.atleast_3d(x).shape
(1, 3, 1)
>>> x = np.arange(12.0).reshape(4,3)
>>> np.atleast_3d(x).shape
(4, 3, 1)
>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
True
>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
...     print(arr, arr.shape) 
...
[[[1]
  [2]]] (1, 2, 1)
[[[1]
  [2]]] (1, 2, 1)
[[[1 2]]] (1, 1, 2)"
numpy.broadcast,Produce an object that mimics broadcasting.,"[{'Parameters': [{'name': 'in1, in2, …', 'type': 'array_like', 'description': 'Input parameters.'}]}, {'Returns': [{'name': 'b', 'type': 'broadcast object', 'description': 'Broadcast the input parameters against one another, andreturn an object that encapsulates the result.Amongst others, it has shape and nd properties, andmay be used as an iterator.'}]}, {'Attributes': [{'name': 'index', 'type': None, 'description': 'current index in broadcasted result'}, {'name': 'iters', 'type': None, 'description': 'tuple of iterators along self’s “components.”'}, {'name': 'nd', 'type': None, 'description': 'Number of dimensions of broadcasted result.'}, {'name': 'ndim', 'type': None, 'description': 'Number of dimensions of broadcasted result.'}, {'name': 'numiter', 'type': None, 'description': 'Number of iterators possessed by the broadcasted result.'}, {'name': 'shape', 'type': None, 'description': 'Shape of broadcasted result.'}, {'name': 'size', 'type': None, 'description': 'Total size of broadcasted result.'}]}]",">>> import numpy as np
>>> x = np.array([[1], [2], [3]])
>>> y = np.array([4, 5, 6])
>>> b = np.broadcast(x, y)
>>> out = np.empty(b.shape)
>>> out.flat = [u+v for (u,v) in b]
>>> out
array([[5.,  6.,  7.],
       [6.,  7.,  8.],
       [7.,  8.,  9.]])
>>> x + y
array([[5, 6, 7],
       [6, 7, 8],
       [7, 8, 9]])"
numpy.broadcast_to,Broadcast an array to a new shape.,"[{'Parameters': [{'name': 'array', 'type': 'array_like', 'description': 'The array to broadcast.'}, {'name': 'shape', 'type': 'tuple or int', 'description': 'The shape of the desired array. A single integer i is interpretedas (i,).'}, {'name': 'subok', 'type': 'bool, optional', 'description': 'If True, then sub-classes will be passed-through, otherwisethe returned array will be forced to be a base-class array (default).'}]}, {'Returns': [{'name': 'broadcast', 'type': 'array', 'description': 'A readonly view on the original array with the given shape. It istypically not contiguous. Furthermore, more than one element of abroadcasted array may refer to a single memory location.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the array is not compatible with the new shape according to NumPy’sbroadcasting rules.'}]}]",">>> import numpy as np
>>> x = np.array([1, 2, 3])
>>> np.broadcast_to(x, (3, 3))
array([[1, 2, 3],
       [1, 2, 3],
       [1, 2, 3]])"
numpy.broadcast_arrays,Broadcast any number of arrays against each other.,"[{'Parameters': [{'name': '*args', 'type': 'array_likes', 'description': 'The arrays to broadcast.'}, {'name': 'subok', 'type': 'bool, optional', 'description': 'If True, then sub-classes will be passed-through, otherwisethe returned arrays will be forced to be a base-class array (default).'}]}, {'Returns': [{'name': 'broadcasted', 'type': 'tuple of arrays', 'description': 'These arrays are views on the original arrays.  They are typicallynot contiguous.  Furthermore, more than one element of abroadcasted array may refer to a single memory location. If you needto write to the arrays, make copies first. While you can set thewritable flag True, writing to a single output value may end upchanging more than one location in the output array.Deprecated since version 1.17: The output is currently marked so that if written to, a deprecationwarning will be emitted. A future version will set thewritable flag False so writing to it will raise an error.'}]}]",">>> import numpy as np
>>> x = np.array([[1,2,3]])
>>> y = np.array([[4],[5]])
>>> np.broadcast_arrays(x, y)
(array([[1, 2, 3],
        [1, 2, 3]]),
 array([[4, 4, 4],
        [5, 5, 5]]))
>>> [np.array(a) for a in np.broadcast_arrays(x, y)]
[array([[1, 2, 3],
        [1, 2, 3]]),
 array([[4, 4, 4],
        [5, 5, 5]])]"
numpy.expand_dims,Expand the shape of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int or tuple of ints', 'description': 'Position in the expanded axes where the new axis (or axes) is placed.Deprecated since version 1.13.0: Passing an axis where axis > a.ndim will be treated asaxis == a.ndim, and passing axis < -a.ndim - 1 willbe treated as axis == 0. This behavior is deprecated.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray', 'description': 'View of a with the number of dimensions increased.'}]}]",">>> import numpy as np
>>> x = np.array([1, 2])
>>> x.shape
(2,)
>>> y = np.expand_dims(x, axis=0)
>>> y
array([[1, 2]])
>>> y.shape
(1, 2)
>>> y = np.expand_dims(x, axis=1)
>>> y
array([[1],
       [2]])
>>> y.shape
(2, 1)
>>> y = np.expand_dims(x, axis=(0, 1))
>>> y
array([[[1, 2]]])
>>> y = np.expand_dims(x, axis=(2, 0))
>>> y
array([[[1],
        [2]]])
>>> np.newaxis is None
True"
numpy.squeeze,Remove axes of length one from a.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Selects a subset of the entries of length one in theshape. If an axis is selected with shape entry greater thanone, an error is raised.'}]}, {'Returns': [{'name': 'squeezed', 'type': 'ndarray', 'description': 'The input array, but with all or a subset of thedimensions of length 1 removed. This is always a itselfor a view into a. Note that if all axes are squeezed,the result is a 0d array and not a scalar.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If axis is not None, and an axis being squeezed is not of length 1'}]}]",">>> import numpy as np
>>> x = np.array([[[0], [1], [2]]])
>>> x.shape
(1, 3, 1)
>>> np.squeeze(x).shape
(3,)
>>> np.squeeze(x, axis=0).shape
(3, 1)
>>> np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size
not equal to one
>>> np.squeeze(x, axis=2).shape
(1, 3)
>>> x = np.array([[1234]])
>>> x.shape
(1, 1)
>>> np.squeeze(x)
array(1234)  # 0d array
>>> np.squeeze(x).shape
()
>>> np.squeeze(x)[()]
1234"
numpy.asarray,Convert the input to an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data, in any form that can be converted to an array.  Thisincludes lists, lists of tuples, tuples, tuples of tuples, tuplesof lists and ndarrays.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.‘C’ row-major (C-style),‘F’ column-major (Fortran-style) memory representation.‘A’ (any) means ‘F’ if a is Fortran contiguous, ‘C’ otherwise‘K’ (keep) preserve input orderDefaults to ‘K’.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If True, then the object is copied. If None then the object iscopied only if needed, i.e. if __array__ returns a copy, if objis a nested sequence, or if a copy is needed to satisfy any ofthe other requirements (dtype, order, etc.).For False it raises a ValueError if a copy cannot be avoided.Default: None.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array interpretation of a.  No copy is performed if the inputis already an ndarray with matching dtype and order.  If a is asubclass of ndarray, a base class ndarray is returned.'}]}]",">>> a = [1, 2]
>>> import numpy as np
>>> np.asarray(a)
array([1, 2])
>>> a = np.array([1, 2])
>>> np.asarray(a) is a
True
>>> a = np.array([1, 2], dtype=np.float32)
>>> np.shares_memory(np.asarray(a, dtype=np.float32), a)
True
>>> np.shares_memory(np.asarray(a, dtype=np.float64), a)
False
>>> issubclass(np.recarray, np.ndarray)
True
>>> a = np.array([(1., 2), (3., 4)], dtype='f4,i4').view(np.recarray)
>>> np.asarray(a) is a
False
>>> np.asanyarray(a) is a
True"
numpy.asanyarray,"Convert the input to an ndarray, but pass ndarray subclasses through.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data, in any form that can be converted to an array.  Thisincludes scalars, lists, lists of tuples, tuples, tuples of tuples,tuples of lists, and ndarrays.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.‘C’ row-major (C-style),‘F’ column-major (Fortran-style) memory representation.‘A’ (any) means ‘F’ if a is Fortran contiguous, ‘C’ otherwise‘K’ (keep) preserve input orderDefaults to ‘C’.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.1.0.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If True, then the object is copied. If None then the object iscopied only if needed, i.e. if __array__ returns a copy, if objis a nested sequence, or if a copy is needed to satisfy any ofthe other requirements (dtype, order, etc.).For False it raises a ValueError if a copy cannot be avoided.Default: None.New in version 2.1.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or an ndarray subclass', 'description': 'Array interpretation of a.  If a is an ndarray or a subclassof ndarray, it is returned as-is and no copy is performed.'}]}]",">>> a = [1, 2]
>>> import numpy as np
>>> np.asanyarray(a)
array([1, 2])
>>> a = np.array([(1., 2), (3., 4)], dtype='f4,i4').view(np.recarray)
>>> np.asanyarray(a) is a
True"
numpy.asmatrix,Interpret the input as a matrix.,"[{'Parameters': [{'name': 'data', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'dtype', 'type': 'data-type', 'description': 'Data-type of the output matrix.'}]}, {'Returns': [{'name': 'mat', 'type': 'matrix', 'description': 'data interpreted as a matrix.'}]}]",">>> import numpy as np
>>> x = np.array([[1, 2], [3, 4]])
>>> m = np.asmatrix(x)
>>> x[0,0] = 5
>>> m
matrix([[5, 2],
        [3, 4]])"
numpy.asfortranarray,Return an array (ndim >= 1) laid out in Fortran order in memory.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'dtype', 'type': 'str or dtype object, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The input a in Fortran, or column-major, order.'}]}]",">>> import numpy as np
>>> x = np.ones((2, 3), order='C')
>>> x.flags['C_CONTIGUOUS']
True
>>> y = np.asfortranarray(x)
>>> y.flags['F_CONTIGUOUS']
True
>>> np.may_share_memory(x, y)
False
>>> x = np.ones((2, 3), order='F')
>>> x.flags['F_CONTIGUOUS']
True
>>> y = np.asfortranarray(x)
>>> x is y
True"
numpy.ascontiguousarray,Return a contiguous array (ndim >= 1) in memory (C order).,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'dtype', 'type': 'str or dtype object, optional', 'description': 'Data-type of returned array.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Contiguous array of same shape and content as a, with type dtypeif specified.'}]}]",">>> import numpy as np
>>> x = np.ones((2, 3), order='F')
>>> x.flags['F_CONTIGUOUS']
True
>>> y = np.ascontiguousarray(x)
>>> y.flags['C_CONTIGUOUS']
True
>>> np.may_share_memory(x, y)
False
>>> x = np.ones((2, 3), order='C')
>>> x.flags['C_CONTIGUOUS']
True
>>> y = np.ascontiguousarray(x)
>>> x is y
True"
numpy.asarray_chkfinite,"Convert the input to an array, checking for NaNs or Infs.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data, in any form that can be converted to an array.  Thisincludes lists, lists of tuples, tuples, tuples of tuples, tuplesof lists and ndarrays.  Success requires no NaNs or Infs.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.‘C’ row-major (C-style),‘F’ column-major (Fortran-style) memory representation.‘A’ (any) means ‘F’ if a is Fortran contiguous, ‘C’ otherwise‘K’ (keep) preserve input orderDefaults to ‘C’.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array interpretation of a.  No copy is performed if the inputis already an ndarray.  If a is a subclass of ndarray, a baseclass ndarray is returned.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'Raises ValueError if a contains NaN (Not a Number) or Inf (Infinity).'}]}]",">>> import numpy as np
>>> a = [1, 2]
>>> np.asarray_chkfinite(a, dtype=float)
array([1., 2.])
>>> a = [1, 2, np.inf]
>>> try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print('ValueError')
...
ValueError"
numpy.require,Return an ndarray of the provided type that satisfies requirements.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The object to be converted to a type-and-requirement-satisfying array.'}, {'name': 'dtype', 'type': 'data-type', 'description': 'The required data-type. If None preserve the current dtype. If yourapplication requires the data to be in native byteorder, includea byteorder specification as a part of the dtype specification.'}, {'name': 'requirements', 'type': 'str or sequence of str', 'description': 'The requirements list can be any of the following‘F_CONTIGUOUS’ (‘F’) - ensure a Fortran-contiguous array‘C_CONTIGUOUS’ (‘C’) - ensure a C-contiguous array‘ALIGNED’ (‘A’)      - ensure a data-type aligned array‘WRITEABLE’ (‘W’)    - ensure a writable array‘OWNDATA’ (‘O’)      - ensure an array that owns its own data‘ENSUREARRAY’, (‘E’) - ensure a base array, instead of a subclass'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array with specified requirements and type if given.'}]}]",">>> import numpy as np
>>> x = np.arange(6).reshape(2,3)
>>> x.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
>>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])
>>> y.flags
  C_CONTIGUOUS : False
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False"
numpy.concatenate,Join a sequence of arrays along an existing axis.,"[{'Parameters': [{'name': 'a1, a2, …', 'type': 'sequence of array_like', 'description': 'The arrays must have the same shape, except in the dimensioncorresponding to axis (the first, by default).'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which the arrays will be joined.  If axis is None,arrays are flattened before use.  Default is 0.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the destination to place the result. The shape must becorrect, matching that of what concatenate would have returned if noout argument were specified.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.20.0.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.For a description of the options, please see casting.New in version 1.20.0.'}]}, {'Returns': [{'name': 'res', 'type': 'ndarray', 'description': 'The concatenated array.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> b = np.array([[5, 6]])
>>> np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
>>> np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])
>>> np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])
>>> a = np.ma.arange(3)
>>> a[1] = np.ma.masked
>>> b = np.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
array([2, 3, 4])
>>> np.concatenate([a, b])
masked_array(data=[0, 1, 2, 2, 3, 4],
             mask=False,
       fill_value=999999)
>>> np.ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)"
numpy.concat,Join a sequence of arrays along an existing axis.,"[{'Parameters': [{'name': 'a1, a2, …', 'type': 'sequence of array_like', 'description': 'The arrays must have the same shape, except in the dimensioncorresponding to axis (the first, by default).'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which the arrays will be joined.  If axis is None,arrays are flattened before use.  Default is 0.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the destination to place the result. The shape must becorrect, matching that of what concatenate would have returned if noout argument were specified.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.20.0.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.For a description of the options, please see casting.New in version 1.20.0.'}]}, {'Returns': [{'name': 'res', 'type': 'ndarray', 'description': 'The concatenated array.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> b = np.array([[5, 6]])
>>> np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
>>> np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])
>>> np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])
>>> a = np.ma.arange(3)
>>> a[1] = np.ma.masked
>>> b = np.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
array([2, 3, 4])
>>> np.concatenate([a, b])
masked_array(data=[0, 1, 2, 2, 3, 4],
             mask=False,
       fill_value=999999)
>>> np.ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)"
numpy.stack,Join a sequence of arrays along a new axis.,"[{'Parameters': [{'name': 'arrays', 'type': 'sequence of ndarrays', 'description': 'Each array must have the same shape. In the case of a single ndarrayarray_like input, it will be treated as a sequence of arrays; i.e.,each element along the zeroth axis is treated as a separate array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis in the result array along which the input arrays are stacked.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the destination to place the result. The shape must becorrect, matching that of what stack would have returned if noout argument were specified.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.24.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.New in version 1.24.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The stacked array has one more dimension than the input arrays.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng()
>>> arrays = [rng.normal(size=(3,4)) for _ in range(10)]
>>> np.stack(arrays, axis=0).shape
(10, 3, 4)
>>> np.stack(arrays, axis=1).shape
(3, 10, 4)
>>> np.stack(arrays, axis=2).shape
(3, 4, 10)
>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.stack((a, b))
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.stack((a, b), axis=-1)
array([[1, 4],
       [2, 5],
       [3, 6]])"
numpy.block,Assemble an nd-array from nested lists of blocks.,"[{'Parameters': [{'name': 'arrays', 'type': 'nested list of array_like or scalars (but not tuples)', 'description': 'If passed a single ndarray or scalar (a nested list of depth 0), thisis returned unmodified (and not copied).Elements shapes must match along the appropriate axes (withoutbroadcasting), but leading 1s will be prepended to the shape asnecessary to make the dimensions match.'}]}, {'Returns': [{'name': 'block_array', 'type': 'ndarray', 'description': 'The array assembled from the given blocks.The dimensionality of the output is equal to the greatest of:the dimensionality of all the inputsthe depth to which the input list is nested'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If list depths are mismatched - for instance, [[a, b], c] isillegal, and should be spelt [[a, b], [c]]If lists are empty - for instance, [[a, b], []]'}]}]",">>> import numpy as np
>>> A = np.eye(2) * 2
>>> B = np.eye(3) * 3
>>> np.block([
...     [A,               np.zeros((2, 3))],
...     [np.ones((3, 2)), B               ]
... ])
array([[2., 0., 0., 0., 0.],
       [0., 2., 0., 0., 0.],
       [1., 1., 3., 0., 0.],
       [1., 1., 0., 3., 0.],
       [1., 1., 0., 0., 3.]])
>>> np.block([1, 2, 3])              # hstack([1, 2, 3])
array([1, 2, 3])
>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.block([a, b, 10])             # hstack([a, b, 10])
array([ 1,  2,  3,  4,  5,  6, 10])
>>> A = np.ones((2, 2), int)
>>> B = 2 * A
>>> np.block([A, B])                 # hstack([A, B])
array([[1, 1, 2, 2],
       [1, 1, 2, 2]])
>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.block([[a], [b]])             # vstack([a, b])
array([[1, 2, 3],
       [4, 5, 6]])
>>> A = np.ones((2, 2), int)
>>> B = 2 * A
>>> np.block([[A], [B]])             # vstack([A, B])
array([[1, 1],
       [1, 1],
       [2, 2],
       [2, 2]])
>>> a = np.array(0)
>>> b = np.array([1])
>>> np.block([a])                    # atleast_1d(a)
array([0])
>>> np.block([b])                    # atleast_1d(b)
array([1])
>>> np.block([[a]])                  # atleast_2d(a)
array([[0]])
>>> np.block([[b]])                  # atleast_2d(b)
array([[1]])"
numpy.vstack,Stack arrays in sequence vertically (row wise).,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of ndarrays', 'description': 'The arrays must have the same shape along all but the first axis.1-D arrays must have the same length. In the case of a singlearray_like input, it will be treated as a sequence of arrays; i.e.,each element along the zeroth axis is treated as a separate array.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.24.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.New in version 1.24.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The array formed by stacking the given arrays, will be at least 2-D.'}]}]",">>> import numpy as np
>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.vstack((a,b))
array([[1, 2, 3],
       [4, 5, 6]])
>>> a = np.array([[1], [2], [3]])
>>> b = np.array([[4], [5], [6]])
>>> np.vstack((a,b))
array([[1],
       [2],
       [3],
       [4],
       [5],
       [6]])"
numpy.hstack,Stack arrays in sequence horizontally (column wise).,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of ndarrays', 'description': 'The arrays must have the same shape along all but the second axis,except 1-D arrays which can be any length. In the case of a singlearray_like input, it will be treated as a sequence of arrays; i.e.,each element along the zeroth axis is treated as a separate array.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.24.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.New in version 1.24.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The array formed by stacking the given arrays.'}]}]",">>> import numpy as np
>>> a = np.array((1,2,3))
>>> b = np.array((4,5,6))
>>> np.hstack((a,b))
array([1, 2, 3, 4, 5, 6])
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[4],[5],[6]])
>>> np.hstack((a,b))
array([[1, 4],
       [2, 5],
       [3, 6]])"
numpy.dstack,Stack arrays in sequence depth wise (along third axis).,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of arrays', 'description': 'The arrays must have the same shape along all but the third axis.1-D or 2-D arrays must have the same shape.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The array formed by stacking the given arrays, will be at least 3-D.'}]}]",">>> import numpy as np
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.dstack((a,b))
array([[[1, 2],
        [2, 3],
        [3, 4]]])
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[2],[3],[4]])
>>> np.dstack((a,b))
array([[[1, 2]],
       [[2, 3]],
       [[3, 4]]])"
numpy.column_stack,Stack 1-D arrays as columns into a 2-D array.,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of 1-D or 2-D arrays.', 'description': 'Arrays to stack. All of them must have the same first dimension.'}]}, {'Returns': [{'name': 'stacked', 'type': '2-D array', 'description': 'The array formed by stacking the given arrays.'}]}]",">>> import numpy as np
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.column_stack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])"
numpy.split,Split an array into multiple sub-arrays as views into ary.,"[{'Parameters': [{'name': 'ary', 'type': 'ndarray', 'description': 'Array to be divided into sub-arrays.'}, {'name': 'indices_or_sections', 'type': 'int or 1-D array', 'description': 'If indices_or_sections is an integer, N, the array will be dividedinto N equal arrays along axis.  If such a split is not possible,an error is raised.If indices_or_sections is a 1-D array of sorted integers, the entriesindicate where along axis the array is split.  For example,[2, 3] would, for axis=0, result inary[:2]ary[2:3]ary[3:]If an index exceeds the dimension of the array along axis,an empty sub-array is returned correspondingly.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which to split, default is 0.'}]}, {'Returns': [{'name': 'sub-arrays', 'type': 'list of ndarrays', 'description': 'A list of sub-arrays as views into ary.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If indices_or_sections is given as an integer, buta split does not result in equal division.'}]}]",">>> import numpy as np
>>> x = np.arange(9.0)
>>> np.split(x, 3)
[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]
>>> x = np.arange(8.0)
>>> np.split(x, [3, 5, 6, 10])
[array([0.,  1.,  2.]),
 array([3.,  4.]),
 array([5.]),
 array([6.,  7.]),
 array([], dtype=float64)]"
numpy.array_split,Split an array into multiple sub-arrays.,[],">>> import numpy as np
>>> x = np.arange(8.0)
>>> np.array_split(x, 3)
[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]
>>> x = np.arange(9)
>>> np.array_split(x, 4)
[array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])]"
numpy.dsplit,Split array into multiple sub-arrays along the 3rd axis (depth).,[],">>> import numpy as np
>>> x = np.arange(16.0).reshape(2, 2, 4)
>>> x
array([[[ 0.,   1.,   2.,   3.],
        [ 4.,   5.,   6.,   7.]],
       [[ 8.,   9.,  10.,  11.],
        [12.,  13.,  14.,  15.]]])
>>> np.dsplit(x, 2)
[array([[[ 0.,  1.],
        [ 4.,  5.]],
       [[ 8.,  9.],
        [12., 13.]]]), array([[[ 2.,  3.],
        [ 6.,  7.]],
       [[10., 11.],
        [14., 15.]]])]
>>> np.dsplit(x, np.array([3, 6]))
[array([[[ 0.,   1.,   2.],
        [ 4.,   5.,   6.]],
       [[ 8.,   9.,  10.],
        [12.,  13.,  14.]]]),
 array([[[ 3.],
        [ 7.]],
       [[11.],
        [15.]]]),
array([], shape=(2, 2, 0), dtype=float64)]"
numpy.hsplit,Split an array into multiple sub-arrays horizontally (column-wise).,[],">>> import numpy as np
>>> x = np.arange(16.0).reshape(4, 4)
>>> x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
>>> np.hsplit(x, 2)
[array([[  0.,   1.],
       [  4.,   5.],
       [  8.,   9.],
       [12.,  13.]]),
 array([[  2.,   3.],
       [  6.,   7.],
       [10.,  11.],
       [14.,  15.]])]
>>> np.hsplit(x, np.array([3, 6]))
[array([[ 0.,   1.,   2.],
       [ 4.,   5.,   6.],
       [ 8.,   9.,  10.],
       [12.,  13.,  14.]]),
 array([[ 3.],
       [ 7.],
       [11.],
       [15.]]),
 array([], shape=(4, 0), dtype=float64)]
>>> x = np.arange(8.0).reshape(2, 2, 2)
>>> x
array([[[0.,  1.],
        [2.,  3.]],
       [[4.,  5.],
        [6.,  7.]]])
>>> np.hsplit(x, 2)
[array([[[0.,  1.]],
       [[4.,  5.]]]),
 array([[[2.,  3.]],
       [[6.,  7.]]])]
>>> x = np.array([0, 1, 2, 3, 4, 5])
>>> np.hsplit(x, 2)
[array([0, 1, 2]), array([3, 4, 5])]"
numpy.vsplit,Split an array into multiple sub-arrays vertically (row-wise).,[],">>> import numpy as np
>>> x = np.arange(16.0).reshape(4, 4)
>>> x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
>>> np.vsplit(x, 2)
[array([[0., 1., 2., 3.],
        [4., 5., 6., 7.]]),
 array([[ 8.,  9., 10., 11.],
        [12., 13., 14., 15.]])]
>>> np.vsplit(x, np.array([3, 6]))
[array([[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.],
        [ 8.,  9., 10., 11.]]),
 array([[12., 13., 14., 15.]]),
 array([], shape=(0, 4), dtype=float64)]
>>> x = np.arange(8.0).reshape(2, 2, 2)
>>> x
array([[[0.,  1.],
        [2.,  3.]],
       [[4.,  5.],
        [6.,  7.]]])
>>> np.vsplit(x, 2)
[array([[[0., 1.],
         [2., 3.]]]),
 array([[[4., 5.],
         [6., 7.]]])]"
numpy.unstack,Split an array into a sequence of arrays along the given axis.,"[{'Parameters': [{'name': 'x', 'type': 'ndarray', 'description': 'The array to be unstacked.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the array will be split. Default: 0.'}]}, {'Returns': [{'name': 'unstacked', 'type': 'tuple of ndarrays', 'description': 'The unstacked arrays.'}]}]",">>> arr = np.arange(24).reshape((2, 3, 4))
>>> np.unstack(arr)
(array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]]),
 array([[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]))
>>> np.unstack(arr, axis=1)
(array([[ 0,  1,  2,  3],
        [12, 13, 14, 15]]),
 array([[ 4,  5,  6,  7],
        [16, 17, 18, 19]]),
 array([[ 8,  9, 10, 11],
        [20, 21, 22, 23]]))
>>> arr2 = np.stack(np.unstack(arr, axis=1), axis=1)
>>> arr2.shape
(2, 3, 4)
>>> np.all(arr == arr2)
np.True_"
numpy.tile,Construct an array by repeating A the number of times given by reps.,"[{'Parameters': [{'name': 'A', 'type': 'array_like', 'description': 'The input array.'}, {'name': 'reps', 'type': 'array_like', 'description': 'The number of repetitions of A along each axis.'}]}, {'Returns': [{'name': 'c', 'type': 'ndarray', 'description': 'The tiled output array.'}]}]",">>> import numpy as np
>>> a = np.array([0, 1, 2])
>>> np.tile(a, 2)
array([0, 1, 2, 0, 1, 2])
>>> np.tile(a, (2, 2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
>>> np.tile(a, (2, 1, 2))
array([[[0, 1, 2, 0, 1, 2]],
       [[0, 1, 2, 0, 1, 2]]])
>>> b = np.array([[1, 2], [3, 4]])
>>> np.tile(b, 2)
array([[1, 2, 1, 2],
       [3, 4, 3, 4]])
>>> np.tile(b, (2, 1))
array([[1, 2],
       [3, 4],
       [1, 2],
       [3, 4]])
>>> c = np.array([1,2,3,4])
>>> np.tile(c,(4,1))
array([[1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4]])"
numpy.repeat,Repeat each element of an array after themselves,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'repeats', 'type': 'int or array of ints', 'description': 'The number of repetitions for each element.  repeats is broadcastedto fit the shape of the given axis.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which to repeat values.  By default, use theflattened input array, and return a flat output array.'}]}, {'Returns': [{'name': 'repeated_array', 'type': 'ndarray', 'description': 'Output array which has the same shape as a, except alongthe given axis.'}]}]",">>> import numpy as np
>>> np.repeat(3, 4)
array([3, 3, 3, 3])
>>> x = np.array([[1,2],[3,4]])
>>> np.repeat(x, 2)
array([1, 1, 2, 2, 3, 3, 4, 4])
>>> np.repeat(x, 3, axis=1)
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])
>>> np.repeat(x, [1, 2], axis=0)
array([[1, 2],
       [3, 4],
       [3, 4]])"
numpy.delete,"Return a new array with sub-arrays along an axis deleted. For a one
dimensional array, this returns those entries not returned by
arr[obj].","[{'Parameters': [{'name': 'arr', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'obj', 'type': 'slice, int, array-like of ints or bools', 'description': 'Indicate indices of sub-arrays to remove along the specified axis.Changed in version 1.19.0: Boolean indices are now treated as a mask of elements to remove,rather than being cast to the integers 0 and 1.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which to delete the subarray defined by obj.If axis is None, obj is applied to the flattened array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'A copy of arr with the elements specified by obj removed. Notethat delete does not occur in-place. If axis is None, out isa flattened array.'}]}]",">>> arr = np.arange(12) + 1
>>> mask = np.ones(len(arr), dtype=bool)
>>> mask[[0,2,4]] = False
>>> result = arr[mask,...]
>>> import numpy as np
>>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
>>> arr
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
>>> np.delete(arr, 1, 0)
array([[ 1,  2,  3,  4],
       [ 9, 10, 11, 12]])
>>> np.delete(arr, np.s_[::2], 1)
array([[ 2,  4],
       [ 6,  8],
       [10, 12]])
>>> np.delete(arr, [1,3,5], None)
array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])"
numpy.insert,Insert values along the given axis before the given indices.,"[{'Parameters': [{'name': 'arr', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'obj', 'type': 'slice, int, array-like of ints or bools', 'description': 'Object that defines the index or indices before which values isinserted.Changed in version 2.1.2: Boolean indices are now treated as a mask of elements to insert,rather than being cast to the integers 0 and 1.Support for multiple insertions when obj is a single scalar or asequence with one element (similar to calling insert multipletimes).'}, {'name': 'values', 'type': 'array_like', 'description': 'Values to insert into arr. If the type of values is differentfrom that of arr, values is converted to the type of arr.values should be shaped so that arr[...,obj,...] = valuesis legal.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to insert values.  If axis is None then arris flattened first.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'A copy of arr with values inserted.  Note that insertdoes not occur in-place: a new array is returned. Ifaxis is None, out is a flattened array.'}]}]",">>> import numpy as np
>>> a = np.arange(6).reshape(3, 2)
>>> a
array([[0, 1],
       [2, 3],
       [4, 5]])
>>> np.insert(a, 1, 6)
array([0, 6, 1, 2, 3, 4, 5])
>>> np.insert(a, 1, 6, axis=1)
array([[0, 6, 1],
       [2, 6, 3],
       [4, 6, 5]])
>>> np.insert(a, [1], [[7],[8],[9]], axis=1)
array([[0, 7, 1],
       [2, 8, 3],
       [4, 9, 5]])
>>> np.insert(a, 1, [[7],[8],[9]], axis=1)
array([[0, 7, 8, 9, 1],
       [2, 7, 8, 9, 3],
       [4, 7, 8, 9, 5]])
>>> np.array_equal(np.insert(a, 1, [7, 8, 9], axis=1),
...                np.insert(a, [1], [[7],[8],[9]], axis=1))
True
>>> b = a.flatten()
>>> b
array([0, 1, 2, 3, 4, 5])
>>> np.insert(b, [2, 2], [6, 7])
array([0, 1, 6, 7, 2, 3, 4, 5])
>>> np.insert(b, slice(2, 4), [7, 8])
array([0, 1, 7, 2, 8, 3, 4, 5])
>>> np.insert(b, [2, 2], [7.13, False]) # type casting
array([0, 1, 7, 0, 2, 3, 4, 5])
>>> x = np.arange(8).reshape(2, 4)
>>> idx = (1, 3)
>>> np.insert(x, idx, 999, axis=1)
array([[  0, 999,   1,   2, 999,   3],
       [  4, 999,   5,   6, 999,   7]])"
numpy.append,Append values to the end of an array.,"[{'Parameters': [{'name': 'arr', 'type': 'array_like', 'description': 'Values are appended to a copy of this array.'}, {'name': 'values', 'type': 'array_like', 'description': 'These values are appended to a copy of arr.  It must be of thecorrect shape (the same shape as arr, excluding axis).  Ifaxis is not specified, values can be any shape and will beflattened before use.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which values are appended.  If axis is notgiven, both arr and values are flattened before use.'}]}, {'Returns': [{'name': 'append', 'type': 'ndarray', 'description': 'A copy of arr with values appended to axis.  Note thatappend does not occur in-place: a new array is allocated andfilled.  If axis is None, out is a flattened array.'}]}]",">>> import numpy as np
>>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
array([1, 2, 3, ..., 7, 8, 9])
>>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
Traceback (most recent call last):
    ...
ValueError: all the input arrays must have same number of dimensions, but
the array at index 0 has 2 dimension(s) and the array at index 1 has 1
dimension(s)
>>> a = np.array([1, 2], dtype=int)
>>> c = np.append(a, [])
>>> c
array([1., 2.])
>>> c.dtype
float64"
numpy.resize,Return a new array with the specified shape.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array to be resized.'}, {'name': 'new_shape', 'type': 'int or tuple of int', 'description': 'Shape of resized array.'}]}, {'Returns': [{'name': 'reshaped_array', 'type': 'ndarray', 'description': 'The new array is formed from the data in the old array, repeatedif necessary to fill out the required number of elements.  Thedata are repeated iterating over the array in C-order.'}]}]",">>> import numpy as np
>>> a = np.array([[0,1],[2,3]])
>>> np.resize(a,(2,3))
array([[0, 1, 2],
       [3, 0, 1]])
>>> np.resize(a,(1,4))
array([[0, 1, 2, 3]])
>>> np.resize(a,(2,4))
array([[0, 1, 2, 3],
       [0, 1, 2, 3]])"
numpy.trim_zeros,Remove values along a dimension which are zero along all other.,"[{'Parameters': [{'name': 'filt', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'trim', 'type': '{“fb”, “f”, “b”}, optional', 'description': 'A string with ‘f’ representing trim from front and ‘b’ to trim fromback. By default, zeros are trimmed on both sides.Front and back refer to the edges of a dimension, with “front” referingto the side with the lowest index 0, and “back” refering to the highestindex (or index -1).'}, {'name': 'axis', 'type': 'int or sequence, optional', 'description': 'If None, filt is cropped such, that the smallest bounding box isreturned that still contains all values which are not zero.If an axis is specified, filt will be sliced in that dimension onlyon the sides specified by trim. The remaining area will be thesmallest that still contains all values wich are not zero.'}]}, {'Returns': [{'name': 'trimmed', 'type': 'ndarray or sequence', 'description': 'The result of trimming the input. The number of dimensions and theinput data type are preserved.'}]}]",">>> import numpy as np
>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
>>> np.trim_zeros(a)
array([1, 2, 3, 0, 2, 1])
>>> np.trim_zeros(a, trim='b')
array([0, 0, 0, ..., 0, 2, 1])
>>> b = np.array([[0, 0, 2, 3, 0, 0],
...               [0, 1, 0, 3, 0, 0],
...               [0, 0, 0, 0, 0, 0]])
>>> np.trim_zeros(b)
array([[0, 2, 3],
       [1, 0, 3]])
>>> np.trim_zeros(b, axis=-1)
array([[0, 2, 3],
       [1, 0, 3],
       [0, 0, 0]])
>>> np.trim_zeros([0, 1, 2, 0])
[1, 2]"
numpy.unique,Find the unique elements of an array.,"[{'Parameters': [{'name': 'ar', 'type': 'array_like', 'description': 'Input array. Unless axis is specified, this will be flattened if itis not already 1-D.'}, {'name': 'return_index', 'type': 'bool, optional', 'description': 'If True, also return the indices of ar (along the specified axis,if provided, or in the flattened array) that result in the unique array.'}, {'name': 'return_inverse', 'type': 'bool, optional', 'description': 'If True, also return the indices of the unique array (for the specifiedaxis, if provided) that can be used to reconstruct ar.'}, {'name': 'return_counts', 'type': 'bool, optional', 'description': 'If True, also return the number of times each unique item appearsin ar.'}, {'name': 'axis', 'type': 'int or None, optional', 'description': 'The axis to operate on. If None, ar will be flattened. If an integer,the subarrays indexed by the given axis will be flattened and treatedas the elements of a 1-D array with the dimension of the given axis,see the notes for more details.  Object arrays or structured arraysthat contain objects are not supported if the axis kwarg is used. Thedefault is None.'}, {'name': 'equal_nan', 'type': 'bool, optional', 'description': 'If True, collapses multiple NaN values in the return array into one.New in version 1.24.'}]}, {'Returns': [{'name': 'unique', 'type': 'ndarray', 'description': 'The sorted unique values.'}, {'name': 'unique_indices', 'type': 'ndarray, optional', 'description': 'The indices of the first occurrences of the unique values in theoriginal array. Only provided if return_index is True.'}, {'name': 'unique_inverse', 'type': 'ndarray, optional', 'description': 'The indices to reconstruct the original array from theunique array. Only provided if return_inverse is True.'}, {'name': 'unique_counts', 'type': 'ndarray, optional', 'description': 'The number of times each of the unique values comes up in theoriginal array. Only provided if return_counts is True.'}]}]",">>> import numpy as np
>>> np.unique([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
>>> a = np.array([[1, 1], [2, 3]])
>>> np.unique(a)
array([1, 2, 3])
>>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
>>> np.unique(a, axis=0)
array([[1, 0, 0], [2, 3, 4]])
>>> a = np.array(['a', 'b', 'b', 'c', 'a'])
>>> u, indices = np.unique(a, return_index=True)
>>> u
array(['a', 'b', 'c'], dtype='<U1')
>>> indices
array([0, 1, 3])
>>> a[indices]
array(['a', 'b', 'c'], dtype='<U1')
>>> a = np.array([1, 2, 6, 4, 2, 3, 2])
>>> u, indices = np.unique(a, return_inverse=True)
>>> u
array([1, 2, 3, 4, 6])
>>> indices
array([0, 1, 4, 3, 1, 2, 1])
>>> u[indices]
array([1, 2, 6, 4, 2, 3, 2])
>>> a = np.array([1, 2, 6, 4, 2, 3, 2])
>>> values, counts = np.unique(a, return_counts=True)
>>> values
array([1, 2, 3, 4, 6])
>>> counts
array([1, 3, 1, 1, 1])
>>> np.repeat(values, counts)
array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved"
numpy.pad,Pad an array.,"[{'Parameters': [{'name': 'array', 'type': 'array_like of rank N', 'description': 'The array to pad.'}, {'name': 'pad_width', 'type': '{sequence, array_like, int}', 'description': 'Number of values padded to the edges of each axis.((before_1, after_1), ... (before_N, after_N)) unique pad widthsfor each axis.(before, after) or ((before, after),) yields same beforeand after pad for each axis.(pad,) or int is a shortcut for before = after = pad widthfor all axes.'}, {'name': 'mode', 'type': 'str or function, optional', 'description': 'One of the following string values or a user supplied function.‘constant’ (default)Pads with a constant value.‘edge’Pads with the edge values of array.‘linear_ramp’Pads with the linear ramp between end_value and thearray edge value.‘maximum’Pads with the maximum value of all or part of thevector along each axis.‘mean’Pads with the mean value of all or part of thevector along each axis.‘median’Pads with the median value of all or part of thevector along each axis.‘minimum’Pads with the minimum value of all or part of thevector along each axis.‘reflect’Pads with the reflection of the vector mirrored onthe first and last values of the vector along eachaxis.‘symmetric’Pads with the reflection of the vector mirroredalong the edge of the array.‘wrap’Pads with the wrap of the vector along the axis.The first values are used to pad the end and theend values are used to pad the beginning.‘empty’Pads with undefined values.<function>Padding function, see Notes.'}, {'name': '‘constant’ (default)', 'type': None, 'description': 'Pads with a constant value.'}, {'name': '‘edge’', 'type': None, 'description': 'Pads with the edge values of array.'}, {'name': '‘linear_ramp’', 'type': None, 'description': 'Pads with the linear ramp between end_value and thearray edge value.'}, {'name': '‘maximum’', 'type': None, 'description': 'Pads with the maximum value of all or part of thevector along each axis.'}, {'name': '‘mean’', 'type': None, 'description': 'Pads with the mean value of all or part of thevector along each axis.'}, {'name': '‘median’', 'type': None, 'description': 'Pads with the median value of all or part of thevector along each axis.'}, {'name': '‘minimum’', 'type': None, 'description': 'Pads with the minimum value of all or part of thevector along each axis.'}, {'name': '‘reflect’', 'type': None, 'description': 'Pads with the reflection of the vector mirrored onthe first and last values of the vector along eachaxis.'}, {'name': '‘symmetric’', 'type': None, 'description': 'Pads with the reflection of the vector mirroredalong the edge of the array.'}, {'name': '‘wrap’', 'type': None, 'description': 'Pads with the wrap of the vector along the axis.The first values are used to pad the end and theend values are used to pad the beginning.'}, {'name': '‘empty’', 'type': None, 'description': 'Pads with undefined values.'}, {'name': '<function>', 'type': None, 'description': 'Padding function, see Notes.'}, {'name': 'stat_length', 'type': 'sequence or int, optional', 'description': 'Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’.  Number ofvalues at edge of each axis used to calculate the statistic value.((before_1, after_1), ... (before_N, after_N)) unique statisticlengths for each axis.(before, after) or ((before, after),) yields same beforeand after statistic lengths for each axis.(stat_length,) or int is a shortcut forbefore = after = statistic length for all axes.Default is None, to use the entire axis.'}, {'name': 'constant_values', 'type': 'sequence or scalar, optional', 'description': 'Used in ‘constant’.  The values to set the padded values for eachaxis.((before_1, after_1), ... (before_N, after_N)) unique pad constantsfor each axis.(before, after) or ((before, after),) yields same beforeand after constants for each axis.(constant,) or constant is a shortcut forbefore = after = constant for all axes.Default is 0.'}, {'name': 'end_values', 'type': 'sequence or scalar, optional', 'description': 'Used in ‘linear_ramp’.  The values used for the ending value of thelinear_ramp and that will form the edge of the padded array.((before_1, after_1), ... (before_N, after_N)) unique end valuesfor each axis.(before, after) or ((before, after),) yields same beforeand after end values for each axis.(constant,) or constant is a shortcut forbefore = after = constant for all axes.Default is 0.'}, {'name': 'reflect_type', 'type': '{‘even’, ‘odd’}, optional', 'description': 'Used in ‘reflect’, and ‘symmetric’.  The ‘even’ style is thedefault with an unaltered reflection around the edge value.  Forthe ‘odd’ style, the extended part of the array is created bysubtracting the reflected values from two times the edge value.'}]}, {'Returns': [{'name': 'pad', 'type': 'ndarray', 'description': 'Padded array of rank equal to array with shape increasedaccording to pad_width.'}]}]",">>> import numpy as np
>>> a = [1, 2, 3, 4, 5]
>>> np.pad(a, (2, 3), 'constant', constant_values=(4, 6))
array([4, 4, 1, ..., 6, 6, 6])
>>> np.pad(a, (2, 3), 'edge')
array([1, 1, 1, ..., 5, 5, 5])
>>> np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])
>>> np.pad(a, (2,), 'maximum')
array([5, 5, 1, 2, 3, 4, 5, 5, 5])
>>> np.pad(a, (2,), 'mean')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])
>>> np.pad(a, (2,), 'median')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])
>>> a = [[1, 2], [3, 4]]
>>> np.pad(a, ((3, 2), (2, 3)), 'minimum')
array([[1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [3, 3, 3, 4, 3, 3, 3],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1]])
>>> a = [1, 2, 3, 4, 5]
>>> np.pad(a, (2, 3), 'reflect')
array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])
>>> np.pad(a, (2, 3), 'reflect', reflect_type='odd')
array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])
>>> np.pad(a, (2, 3), 'symmetric')
array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])
>>> np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])
>>> np.pad(a, (2, 3), 'wrap')
array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])
>>> def pad_with(vector, pad_width, iaxis, kwargs):
...     pad_value = kwargs.get('padder', 10)
...     vector[:pad_width[0]] = pad_value
...     vector[-pad_width[1]:] = pad_value
>>> a = np.arange(6)
>>> a = a.reshape((2, 3))
>>> np.pad(a, 2, pad_with)
array([[10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10,  0,  1,  2, 10, 10],
       [10, 10,  3,  4,  5, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10]])
>>> np.pad(a, 2, pad_with, padder=100)
array([[100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100,   0,   1,   2, 100, 100],
       [100, 100,   3,   4,   5, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100]])"
numpy.flip,Reverse the order of elements in an array along the given axis.,"[{'Parameters': [{'name': 'm', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which to flip over. The default,axis=None, will flip over all of the axes of the input array.If axis is negative it counts from the last to the first axis.If axis is a tuple of ints, flipping is performed on all of the axesspecified in the tuple.'}]}, {'Returns': [{'name': 'out', 'type': 'array_like', 'description': 'A view of m with the entries of axis reversed.  Since a view isreturned, this operation is done in constant time.'}]}]",">>> import numpy as np
>>> A = np.arange(8).reshape((2,2,2))
>>> A
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> np.flip(A, 0)
array([[[4, 5],
        [6, 7]],
       [[0, 1],
        [2, 3]]])
>>> np.flip(A, 1)
array([[[2, 3],
        [0, 1]],
       [[6, 7],
        [4, 5]]])
>>> np.flip(A)
array([[[7, 6],
        [5, 4]],
       [[3, 2],
        [1, 0]]])
>>> np.flip(A, (0, 2))
array([[[5, 4],
        [7, 6]],
       [[1, 0],
        [3, 2]]])
>>> rng = np.random.default_rng()
>>> A = rng.normal(size=(3,4,5))
>>> np.all(np.flip(A,2) == A[:,:,::-1,...])
True"
numpy.fliplr,Reverse the order of elements along axis 1 (left/right).,"[{'Parameters': [{'name': 'm', 'type': 'array_like', 'description': 'Input array, must be at least 2-D.'}]}, {'Returns': [{'name': 'f', 'type': 'ndarray', 'description': 'A view of m with the columns reversed.  Since a viewis returned, this operation is \\(\\mathcal O(1)\\).'}]}]",">>> import numpy as np
>>> A = np.diag([1.,2.,3.])
>>> A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
>>> np.fliplr(A)
array([[0.,  0.,  1.],
       [0.,  2.,  0.],
       [3.,  0.,  0.]])
>>> rng = np.random.default_rng()
>>> A = rng.normal(size=(2,3,5))
>>> np.all(np.fliplr(A) == A[:,::-1,...])
True"
numpy.flipud,Reverse the order of elements along axis 0 (up/down).,"[{'Parameters': [{'name': 'm', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'array_like', 'description': 'A view of m with the rows reversed.  Since a view isreturned, this operation is \\(\\mathcal O(1)\\).'}]}]",">>> import numpy as np
>>> A = np.diag([1.0, 2, 3])
>>> A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
>>> np.flipud(A)
array([[0.,  0.,  3.],
       [0.,  2.,  0.],
       [1.,  0.,  0.]])
>>> rng = np.random.default_rng()
>>> A = rng.normal(size=(2,3,5))
>>> np.all(np.flipud(A) == A[::-1,...])
True
>>> np.flipud([1,2])
array([2, 1])"
numpy.roll,Roll array elements along a given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'shift', 'type': 'int or tuple of ints', 'description': 'The number of places by which elements are shifted.  If a tuple,then axis must be a tuple of the same size, and each of thegiven axes is shifted by the corresponding number.  If an intwhile axis is a tuple of ints, then the same value is used forall given axes.'}, {'name': 'axis', 'type': 'int or tuple of ints, optional', 'description': 'Axis or axes along which elements are shifted.  By default, thearray is flattened before shifting, after which the originalshape is restored.'}]}, {'Returns': [{'name': 'res', 'type': 'ndarray', 'description': 'Output array, with the same shape as a.'}]}]",">>> import numpy as np
>>> x = np.arange(10)
>>> np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
>>> np.roll(x, -2)
array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])
>>> x2 = np.reshape(x, (2, 5))
>>> x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
>>> np.roll(x2, -1)
array([[1, 2, 3, 4, 5],
       [6, 7, 8, 9, 0]])
>>> np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, -1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])
>>> np.roll(x2, -1, axis=1)
array([[1, 2, 3, 4, 0],
       [6, 7, 8, 9, 5]])
>>> np.roll(x2, (1, 1), axis=(1, 0))
array([[9, 5, 6, 7, 8],
       [4, 0, 1, 2, 3]])
>>> np.roll(x2, (2, 1), axis=(1, 0))
array([[8, 9, 5, 6, 7],
       [3, 4, 0, 1, 2]])"
numpy.rot90,Rotate an array by 90 degrees in the plane specified by axes.,"[{'Parameters': [{'name': 'm', 'type': 'array_like', 'description': 'Array of two or more dimensions.'}, {'name': 'k', 'type': 'integer', 'description': 'Number of times the array is rotated by 90 degrees.'}, {'name': 'axes', 'type': '(2,) array_like', 'description': 'The array is rotated in the plane defined by the axes.Axes must be different.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'A rotated view of m.'}]}]",">>> import numpy as np
>>> m = np.array([[1,2],[3,4]], int)
>>> m
array([[1, 2],
       [3, 4]])
>>> np.rot90(m)
array([[2, 4],
       [1, 3]])
>>> np.rot90(m, 2)
array([[4, 3],
       [2, 1]])
>>> m = np.arange(8).reshape((2,2,2))
>>> np.rot90(m, 1, (1,2))
array([[[1, 3],
        [0, 2]],
       [[5, 7],
        [4, 6]]])"
numpy.unique,Find the unique elements of an array.,"[{'Parameters': [{'name': 'ar', 'type': 'array_like', 'description': 'Input array. Unless axis is specified, this will be flattened if itis not already 1-D.'}, {'name': 'return_index', 'type': 'bool, optional', 'description': 'If True, also return the indices of ar (along the specified axis,if provided, or in the flattened array) that result in the unique array.'}, {'name': 'return_inverse', 'type': 'bool, optional', 'description': 'If True, also return the indices of the unique array (for the specifiedaxis, if provided) that can be used to reconstruct ar.'}, {'name': 'return_counts', 'type': 'bool, optional', 'description': 'If True, also return the number of times each unique item appearsin ar.'}, {'name': 'axis', 'type': 'int or None, optional', 'description': 'The axis to operate on. If None, ar will be flattened. If an integer,the subarrays indexed by the given axis will be flattened and treatedas the elements of a 1-D array with the dimension of the given axis,see the notes for more details.  Object arrays or structured arraysthat contain objects are not supported if the axis kwarg is used. Thedefault is None.'}, {'name': 'equal_nan', 'type': 'bool, optional', 'description': 'If True, collapses multiple NaN values in the return array into one.New in version 1.24.'}]}, {'Returns': [{'name': 'unique', 'type': 'ndarray', 'description': 'The sorted unique values.'}, {'name': 'unique_indices', 'type': 'ndarray, optional', 'description': 'The indices of the first occurrences of the unique values in theoriginal array. Only provided if return_index is True.'}, {'name': 'unique_inverse', 'type': 'ndarray, optional', 'description': 'The indices to reconstruct the original array from theunique array. Only provided if return_inverse is True.'}, {'name': 'unique_counts', 'type': 'ndarray, optional', 'description': 'The number of times each of the unique values comes up in theoriginal array. Only provided if return_counts is True.'}]}]",">>> import numpy as np
>>> np.unique([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
>>> a = np.array([[1, 1], [2, 3]])
>>> np.unique(a)
array([1, 2, 3])
>>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
>>> np.unique(a, axis=0)
array([[1, 0, 0], [2, 3, 4]])
>>> a = np.array(['a', 'b', 'b', 'c', 'a'])
>>> u, indices = np.unique(a, return_index=True)
>>> u
array(['a', 'b', 'c'], dtype='<U1')
>>> indices
array([0, 1, 3])
>>> a[indices]
array(['a', 'b', 'c'], dtype='<U1')
>>> a = np.array([1, 2, 6, 4, 2, 3, 2])
>>> u, indices = np.unique(a, return_inverse=True)
>>> u
array([1, 2, 3, 4, 6])
>>> indices
array([0, 1, 4, 3, 1, 2, 1])
>>> u[indices]
array([1, 2, 6, 4, 2, 3, 2])
>>> a = np.array([1, 2, 6, 4, 2, 3, 2])
>>> values, counts = np.unique(a, return_counts=True)
>>> values
array([1, 2, 3, 4, 6])
>>> counts
array([1, 3, 1, 1, 1])
>>> np.repeat(values, counts)
array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved"
numpy.unique_all,"Find the unique elements of an array, and counts, inverse, and indices.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array. It will be flattened if it is not already 1-D.'}]}, {'Returns': [{'name': 'out', 'type': 'namedtuple', 'description': 'The result containing:values - The unique elements of an input array.indices - The first occurring indices for each unique element.inverse_indices - The indices from the set of unique elementsthat reconstruct x.counts - The corresponding counts for each unique element.'}]}]",">>> import numpy as np
>>> x = [1, 1, 2]
>>> uniq = np.unique_all(x)
>>> uniq.values
array([1, 2])
>>> uniq.indices
array([0, 2])
>>> uniq.inverse_indices
array([0, 0, 1])
>>> uniq.counts
array([2, 1])"
numpy.unique_counts,Find the unique elements and counts of an input array x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array. It will be flattened if it is not already 1-D.'}]}, {'Returns': [{'name': 'out', 'type': 'namedtuple', 'description': 'The result containing:values - The unique elements of an input array.counts - The corresponding counts for each unique element.'}]}]",">>> import numpy as np
>>> x = [1, 1, 2]
>>> uniq = np.unique_counts(x)
>>> uniq.values
array([1, 2])
>>> uniq.counts
array([2, 1])"
numpy.unique_inverse,Find the unique elements of x and indices to reconstruct x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array. It will be flattened if it is not already 1-D.'}]}, {'Returns': [{'name': 'out', 'type': 'namedtuple', 'description': 'The result containing:values - The unique elements of an input array.inverse_indices - The indices from the set of unique elementsthat reconstruct x.'}]}]",">>> import numpy as np
>>> x = [1, 1, 2]
>>> uniq = np.unique_inverse(x)
>>> uniq.values
array([1, 2])
>>> uniq.inverse_indices
array([0, 0, 1])"
numpy.unique_values,Returns the unique elements of an input array x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array. It will be flattened if it is not already 1-D.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The unique elements of an input array.'}]}]",">>> import numpy as np
>>> np.unique_values([1, 1, 2])
array([1, 2])"
numpy.in1d,Test whether each element of a 1-D array is also present in a second array.,"[{'Parameters': [{'name': 'ar1', 'type': '(M,) array_like', 'description': 'Input array.'}, {'name': 'ar2', 'type': 'array_like', 'description': 'The values against which to test each value of ar1.'}, {'name': 'assume_unique', 'type': 'bool, optional', 'description': 'If True, the input arrays are both assumed to be unique, whichcan speed up the calculation.  Default is False.'}, {'name': 'invert', 'type': 'bool, optional', 'description': 'If True, the values in the returned array are inverted (that is,False where an element of ar1 is in ar2 and True otherwise).Default is False. np.in1d(a, b, invert=True) is equivalentto (but is faster than) np.invert(in1d(a, b)).'}, {'name': 'kind', 'type': '{None, ‘sort’, ‘table’}, optional', 'description': 'The algorithm to use. This will not affect the final result,but will affect the speed and memory use. The default, None,will select automatically based on memory considerations.If ‘sort’, will use a mergesort-based approach. This will havea memory usage of roughly 6 times the sum of the sizes ofar1 and ar2, not accounting for size of dtypes.If ‘table’, will use a lookup table approach similarto a counting sort. This is only available for boolean andinteger arrays. This will have a memory usage of thesize of ar1 plus the max-min value of ar2. assume_uniquehas no effect when the ‘table’ option is used.If None, will automatically choose ‘table’ ifthe required memory allocation is less than or equal to6 times the sum of the sizes of ar1 and ar2,otherwise will use ‘sort’. This is done to not usea large amount of memory by default, even though‘table’ may be faster in most cases. If ‘table’ is chosen,assume_unique will have no effect.'}]}, {'Returns': [{'name': 'in1d', 'type': '(M,) ndarray, bool', 'description': 'The values ar1[in1d] are in ar2.'}]}]",">>> import numpy as np
>>> test = np.array([0, 1, 2, 5, 0])
>>> states = [0, 2]
>>> mask = np.in1d(test, states)
>>> mask
array([ True, False,  True, False,  True])
>>> test[mask]
array([0, 2, 0])
>>> mask = np.in1d(test, states, invert=True)
>>> mask
array([False,  True, False,  True, False])
>>> test[mask]
array([1, 5])"
numpy.intersect1d,Find the intersection of two arrays.,"[{'Parameters': [{'name': 'ar1, ar2', 'type': 'array_like', 'description': 'Input arrays. Will be flattened if not already 1D.'}, {'name': 'assume_unique', 'type': 'bool', 'description': 'If True, the input arrays are both assumed to be unique, whichcan speed up the calculation.  If True but ar1 or ar2 are notunique, incorrect results and out-of-bounds indices could result.Default is False.'}, {'name': 'return_indices', 'type': 'bool', 'description': 'If True, the indices which correspond to the intersection of the twoarrays are returned. The first instance of a value is used if there aremultiple. Default is False.'}]}, {'Returns': [{'name': 'intersect1d', 'type': 'ndarray', 'description': 'Sorted 1D array of common and unique elements.'}, {'name': 'comm1', 'type': 'ndarray', 'description': 'The indices of the first occurrences of the common values in ar1.Only provided if return_indices is True.'}, {'name': 'comm2', 'type': 'ndarray', 'description': 'The indices of the first occurrences of the common values in ar2.Only provided if return_indices is True.'}]}]",">>> import numpy as np
>>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
array([1, 3])
>>> from functools import reduce
>>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([3])
>>> x = np.array([1, 1, 2, 3, 4])
>>> y = np.array([2, 1, 4, 6])
>>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
>>> x_ind, y_ind
(array([0, 2, 4]), array([1, 0, 2]))
>>> xy, x[x_ind], y[y_ind]
(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))"
numpy.isin,"Calculates element in test_elements, broadcasting over element only.
Returns a boolean array of the same shape as element that is True
where an element of element is in test_elements and False otherwise.","[{'Parameters': [{'name': 'element', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'test_elements', 'type': 'array_like', 'description': 'The values against which to test each value of element.This argument is flattened if it is an array or array_like.See notes for behavior with non-array-like parameters.'}, {'name': 'assume_unique', 'type': 'bool, optional', 'description': 'If True, the input arrays are both assumed to be unique, whichcan speed up the calculation.  Default is False.'}, {'name': 'invert', 'type': 'bool, optional', 'description': 'If True, the values in the returned array are inverted, as ifcalculating element not in test_elements. Default is False.np.isin(a, b, invert=True) is equivalent to (but fasterthan) np.invert(np.isin(a, b)).'}, {'name': 'kind', 'type': '{None, ‘sort’, ‘table’}, optional', 'description': 'The algorithm to use. This will not affect the final result,but will affect the speed and memory use. The default, None,will select automatically based on memory considerations.If ‘sort’, will use a mergesort-based approach. This will havea memory usage of roughly 6 times the sum of the sizes ofelement and test_elements, not accounting for size of dtypes.If ‘table’, will use a lookup table approach similarto a counting sort. This is only available for boolean andinteger arrays. This will have a memory usage of thesize of element plus the max-min value of test_elements.assume_unique has no effect when the ‘table’ option is used.If None, will automatically choose ‘table’ ifthe required memory allocation is less than or equal to6 times the sum of the sizes of element and test_elements,otherwise will use ‘sort’. This is done to not usea large amount of memory by default, even though‘table’ may be faster in most cases. If ‘table’ is chosen,assume_unique will have no effect.'}]}, {'Returns': [{'name': 'isin', 'type': 'ndarray, bool', 'description': 'Has the same shape as element. The values element[isin]are in test_elements.'}]}]",">>> import numpy as np
>>> element = 2*np.arange(4).reshape((2, 2))
>>> element
array([[0, 2],
       [4, 6]])
>>> test_elements = [1, 2, 4, 8]
>>> mask = np.isin(element, test_elements)
>>> mask
array([[False,  True],
       [ True, False]])
>>> element[mask]
array([2, 4])
>>> np.nonzero(mask)
(array([0, 1]), array([1, 0]))
>>> mask = np.isin(element, test_elements, invert=True)
>>> mask
array([[ True, False],
       [False,  True]])
>>> element[mask]
array([0, 6])
>>> test_set = {1, 2, 4, 8}
>>> np.isin(element, test_set)
array([[False, False],
       [False, False]])
>>> np.isin(element, list(test_set))
array([[False,  True],
       [ True, False]])"
numpy.setdiff1d,Find the set difference of two arrays.,"[{'Parameters': [{'name': 'ar1', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'ar2', 'type': 'array_like', 'description': 'Input comparison array.'}, {'name': 'assume_unique', 'type': 'bool', 'description': 'If True, the input arrays are both assumed to be unique, whichcan speed up the calculation.  Default is False.'}]}, {'Returns': [{'name': 'setdiff1d', 'type': 'ndarray', 'description': '1D array of values in ar1 that are not in ar2. The resultis sorted when assume_unique=False, but otherwise only sortedif the input is sorted.'}]}]",">>> import numpy as np
>>> a = np.array([1, 2, 3, 2, 4, 1])
>>> b = np.array([3, 4, 5, 6])
>>> np.setdiff1d(a, b)
array([1, 2])"
numpy.setxor1d,Find the set exclusive-or of two arrays.,"[{'Parameters': [{'name': 'ar1, ar2', 'type': 'array_like', 'description': 'Input arrays.'}, {'name': 'assume_unique', 'type': 'bool', 'description': 'If True, the input arrays are both assumed to be unique, whichcan speed up the calculation. Default is False.'}]}, {'Returns': [{'name': 'setxor1d', 'type': 'ndarray', 'description': 'Sorted 1D array of unique values that are in only one of the inputarrays.'}]}]",">>> import numpy as np
>>> a = np.array([1, 2, 3, 2, 4])
>>> b = np.array([2, 3, 5, 7, 5])
>>> np.setxor1d(a,b)
array([1, 4, 5, 7])"
numpy.union1d,Find the union of two arrays.,"[{'Parameters': [{'name': 'ar1, ar2', 'type': 'array_like', 'description': 'Input arrays. They are flattened if they are not already 1D.'}]}, {'Returns': [{'name': 'union1d', 'type': 'ndarray', 'description': 'Unique, sorted union of the input arrays.'}]}]",">>> import numpy as np
>>> np.union1d([-1, 0, 1], [-2, 0, 2])
array([-2, -1,  0,  1,  2])
>>> from functools import reduce
>>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([1, 2, 3, 4, 6])"
numpy.seterr,Set how floating-point errors are handled.,"[{'Parameters': [{'name': 'all', 'type': '{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional', 'description': 'Set treatment for all types of floating-point errors at once:ignore: Take no action when the exception occurs.warn: Print a RuntimeWarning (via the Python warningsmodule).raise: Raise a FloatingPointError.call: Call a function specified using the seterrcall function.print: Print a warning directly to stdout.log: Record error in a Log object specified by seterrcall.The default is not to change the current behavior.'}, {'name': 'divide', 'type': '{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional', 'description': 'Treatment for division by zero.'}, {'name': 'over', 'type': '{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional', 'description': 'Treatment for floating-point overflow.'}, {'name': 'under', 'type': '{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional', 'description': 'Treatment for floating-point underflow.'}, {'name': 'invalid', 'type': '{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional', 'description': 'Treatment for invalid floating-point operation.'}]}, {'Returns': [{'name': 'old_settings', 'type': 'dict', 'description': 'Dictionary containing the old settings.'}]}]",">>> import numpy as np
>>> orig_settings = np.seterr(all='ignore')  # seterr to known value
>>> np.int16(32000) * np.int16(3)
np.int16(30464)
>>> np.seterr(over='raise')
{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
>>> old_settings = np.seterr(all='warn', over='raise')
>>> np.int16(32000) * np.int16(3)
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
FloatingPointError: overflow encountered in scalar multiply
>>> old_settings = np.seterr(all='print')
>>> np.geterr()
{'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}
>>> np.int16(32000) * np.int16(3)
np.int16(30464)
>>> np.seterr(**orig_settings)  # restore original
{'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}"
numpy.geterr,Get the current way of handling floating-point errors.,"[{'Returns': [{'name': 'res', 'type': 'dict', 'description': 'A dictionary with keys “divide”, “over”, “under”, and “invalid”,whose values are from the strings “ignore”, “print”, “log”, “warn”,“raise”, and “call”. The keys represent possible floating-pointexceptions, and the values define how these exceptions are handled.'}]}]",">>> import numpy as np
>>> np.geterr()
{'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}
>>> np.arange(3.) / np.arange(3.)  
array([nan,  1.,  1.])
RuntimeWarning: invalid value encountered in divide
>>> oldsettings = np.seterr(all='warn', invalid='raise')
>>> np.geterr()
{'divide': 'warn', 'over': 'warn', 'under': 'warn', 'invalid': 'raise'}
>>> np.arange(3.) / np.arange(3.)
Traceback (most recent call last):
  ...
FloatingPointError: invalid value encountered in divide
>>> oldsettings = np.seterr(**oldsettings)  # restore original"
numpy.seterrcall,Set the floating-point error callback function or log object.,"[{'Parameters': [{'name': 'func', 'type': 'callable f(err, flag) or object with write method', 'description': 'Function to call upon floating-point errors (‘call’-mode) orobject whose ‘write’ method is used to log such message (‘log’-mode).The call function takes two arguments. The first is a string describingthe type of error (such as “divide by zero”, “overflow”, “underflow”,or “invalid value”), and the second is the status flag.  The flag is abyte, whose four least-significant bits indicate the type of error, oneof “divide”, “over”, “under”, “invalid”:[0 0 0 0 divide over under invalid]In other words, flags = divide + 2*over + 4*under + 8*invalid.If an object is provided, its write method should take one argument,a string.'}]}, {'Returns': [{'name': 'h', 'type': 'callable, log instance or None', 'description': 'The old error handler.'}]}]",">>> def err_handler(type, flag):
...     print(""Floating point error (%s), with flag %s"" % (type, flag))
...
>>> import numpy as np
>>> orig_handler = np.seterrcall(err_handler)
>>> orig_err = np.seterr(all='call')
>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([inf, inf, inf])
>>> np.seterrcall(orig_handler)
<function err_handler at 0x...>
>>> np.seterr(**orig_err)
{'divide': 'call', 'over': 'call', 'under': 'call', 'invalid': 'call'}
>>> class Log:
...     def write(self, msg):
...         print(""LOG: %s"" % msg)
...
>>> log = Log()
>>> saved_handler = np.seterrcall(log)
>>> save_err = np.seterr(all='log')
>>> np.array([1, 2, 3]) / 0.0
LOG: Warning: divide by zero encountered in divide
array([inf, inf, inf])
>>> np.seterrcall(orig_handler)
<numpy.Log object at 0x...>
>>> np.seterr(**orig_err)
{'divide': 'log', 'over': 'log', 'under': 'log', 'invalid': 'log'}"
numpy.geterrcall,Return the current callback function used on floating-point errors.,"[{'Returns': [{'name': 'errobj', 'type': 'callable, log instance or None', 'description': 'The current error handler. If no handler was set through seterrcall,None is returned.'}]}]",">>> import numpy as np
>>> np.geterrcall()  # we did not yet set a handler, returns None
>>> orig_settings = np.seterr(all='call')
>>> def err_handler(type, flag):
...     print(""Floating point error (%s), with flag %s"" % (type, flag))
>>> old_handler = np.seterrcall(err_handler)
>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([inf, inf, inf])
>>> cur_handler = np.geterrcall()
>>> cur_handler is err_handler
True
>>> old_settings = np.seterr(**orig_settings)  # restore original
>>> old_handler = np.seterrcall(None)  # restore original"
numpy.errstate,Context manager for floating-point error handling.,"[{'Parameters': [{'name': 'kwargs', 'type': '{divide, over, under, invalid}', 'description': 'Keyword arguments. The valid keywords are the possible floating-pointexceptions. Each keyword should have a string value that defines thetreatment for the particular error. Possible values are{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}.'}]}]",">>> import numpy as np
>>> olderr = np.seterr(all='ignore')  # Set error handling to known state.
>>> np.arange(3) / 0.
array([nan, inf, inf])
>>> with np.errstate(divide='ignore'):
...     np.arange(3) / 0.
array([nan, inf, inf])
>>> np.sqrt(-1)
np.float64(nan)
>>> with np.errstate(invalid='raise'):
...     np.sqrt(-1)
Traceback (most recent call last):
  File ""<stdin>"", line 2, in <module>
FloatingPointError: invalid value encountered in sqrt
>>> np.geterr()
{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
>>> olderr = np.seterr(**olderr)  # restore original state"
numpy.polynomial.legendre.Legendre,A Legendre series class.,"[{'Parameters': [{'name': 'coef', 'type': 'array_like', 'description': 'Legendre coefficients in order of increasing degree, i.e.,(1, 2, 3) gives 1*P_0(x) + 2*P_1(x) + 3*P_2(x).'}, {'name': 'domain', 'type': '(2,) array_like, optional', 'description': 'Domain to use. The interval [domain[0], domain[1]] is mappedto the interval [window[0], window[1]] by shifting and scaling.The default value is [-1., 1.].'}, {'name': 'window', 'type': '(2,) array_like, optional', 'description': 'Window, see domain for its use. The default value is [-1., 1.].'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol used to represent the independent variable in stringrepresentations of the polynomial expression, e.g. for printing.The symbol must be a valid Python identifier. Default value is ‘x’.New in version 1.24.'}]}, {'Attributes': [{'name': 'symbol', 'type': None, 'description': ''}]}]",
numpy.polynomial.legendre.Legendre.__call__,method,[],
numpy.polynomial.legendre.Legendre.basis,method,"[{'Parameters': [{'name': 'deg', 'type': 'int', 'description': 'Degree of the basis polynomial for the series. Must be >= 0.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series with the coefficient of the deg term set to one andall others zero.'}]}]",
numpy.polynomial.legendre.Legendre.cast,method,"[{'Parameters': [{'name': 'series', 'type': 'series', 'description': 'The series instance to be converted.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series of the same kind as the calling class and equal toseries when evaluated.'}]}]",
numpy.polynomial.legendre.Legendre.convert,method,"[{'Parameters': [{'name': 'domain', 'type': 'array_like, optional', 'description': 'The domain of the converted series. If the value is None,the default domain of kind is used.'}, {'name': 'kind', 'type': 'class, optional', 'description': 'The polynomial series type class to which the current instanceshould be converted. If kind is None, then the class of thecurrent instance is used.'}, {'name': 'window', 'type': 'array_like, optional', 'description': 'The window of the converted series. If the value is None,the default window of kind is used.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'The returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.'}]}]",
numpy.polynomial.legendre.Legendre.copy,method,"[{'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Copy of self.'}]}]",
numpy.polynomial.legendre.Legendre.cutdeg,method,"[{'Parameters': [{'name': 'deg', 'type': 'non-negative int', 'description': 'The series is reduced to degree deg by discarding the highorder terms. The value of deg must be a non-negative integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with reduced degree.'}]}]",
numpy.polynomial.legendre.Legendre.degree,method,"[{'Returns': [{'name': 'degree', 'type': 'int', 'description': 'Degree of the series, one less than the number of coefficients.'}]}]",">>> poly = np.polynomial.Polynomial([1, 7, 4])
>>> print(poly)
1.0 + 7.0·x + 4.0·x²
>>> poly.degree()
2
>>> poly = np.polynomial.Polynomial([1, 7, 0])
>>> print(poly)
1.0 + 7.0·x + 0.0·x²
>>> poly.degree()
2
>>> poly.trim().degree()
1"
numpy.polynomial.legendre.Legendre.deriv,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'Find the derivative of order m.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the derivative. The domain is the sameas the domain of the differentiated series.'}]}]",
numpy.polynomial.legendre.Legendre.fit,method,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (M,)', 'description': 'x-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'y', 'type': 'array_like, shape (M,)', 'description': 'y-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'deg', 'type': 'int or 1-D array_like', 'description': 'Degree(s) of the fitting polynomials. If deg is a single integerall terms up to and including the deg’th term are included in thefit. For NumPy versions >= 1.11.0 a list of integers specifying thedegrees of the terms to include may be used instead.'}, {'name': 'domain', 'type': '{None, [beg, end], []}, optional', 'description': 'Domain to use for the returned series. If None,then a minimal domain that covers the points x is chosen.  If[] the class domain is used. The default value was theclass domain in NumPy 1.4 and None in later versions.The [] option was added in numpy 1.5.0.'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Relative condition number of the fit. Singular values smallerthan this relative to the largest singular value will beignored. The default value is len(x)*eps, where eps is therelative precision of the float type, about 2e-16 in mostcases.'}, {'name': 'full', 'type': 'bool, optional', 'description': 'Switch determining nature of return value. When it is False(the default) just the coefficients are returned, when Truediagnostic information from the singular value decomposition isalso returned.'}, {'name': 'w', 'type': 'array_like, shape (M,), optional', 'description': 'Weights. If not None, the weight w[i] applies to the unsquaredresidual y[i] - y_hat[i] at x[i]. Ideally the weights arechosen so that the errors of the products w[i]*y[i] all havethe same variance.  When using inverse-variance weighting, usew[i] = 1/sigma(y[i]).  The default value is None.'}, {'name': 'window', 'type': '{[beg, end]}, optional', 'description': 'Window to use for the returned series. The defaultvalue is the default class domain'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.'}, {'name': '[resid, rank, sv, rcond]', 'type': 'list', 'description': 'These values are only returned if full == Trueresid – sum of squared residuals of the least squares fitrank – the numerical rank of the scaled Vandermonde matrixsv – singular values of the scaled Vandermonde matrixrcond – value of rcond.For more details, see linalg.lstsq.'}]}]",
numpy.polynomial.legendre.Legendre.fromroots,method,"[{'Parameters': [{'name': 'roots', 'type': 'array_like', 'description': 'List of roots.'}, {'name': 'domain', 'type': '{[], None, array_like}, optional', 'description': 'Domain for the resulting series. If None the domain is theinterval from the smallest root to the largest. If [] thedomain is the class domain. The default is [].'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'Window for the returned series. If None the class window isused. The default is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series with the specified roots.'}]}]",
numpy.polynomial.legendre.Legendre.has_samecoef,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the coef attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the coefficients are the same, False otherwise.'}]}]",
numpy.polynomial.legendre.Legendre.has_samedomain,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the domain attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the domains are the same, False otherwise.'}]}]",
numpy.polynomial.legendre.Legendre.has_sametype,method,"[{'Parameters': [{'name': 'other', 'type': 'object', 'description': 'Class instance.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if other is same class as self'}]}]",
numpy.polynomial.legendre.Legendre.has_samewindow,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the window attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the windows are the same, False otherwise.'}]}]",
numpy.polynomial.legendre.Legendre.identity,method,"[{'Parameters': [{'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series of representing the identity.'}]}]",
numpy.polynomial.legendre.Legendre.integ,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'The number of integrations to perform.'}, {'name': 'k', 'type': 'array_like', 'description': 'Integration constants. The first constant is applied to thefirst integration, the second to the second, and so on. Thelist of values must less than or equal to m in length and anymissing values are set to zero.'}, {'name': 'lbnd', 'type': 'Scalar', 'description': 'The lower bound of the definite integral.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the integral. The domain is the sameas the domain of the integrated series.'}]}]",
numpy.polynomial.legendre.Legendre.linspace,method,"[{'Parameters': [{'name': 'n', 'type': 'int, optional', 'description': 'Number of point pairs to return. The default value is 100.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If not None, the specified domain is used instead of that ofthe calling instance. It should be of the form [beg,end].The default is None which case the class domain is used.'}]}, {'Returns': [{'name': 'x, y', 'type': 'ndarray', 'description': 'x is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.'}]}]",
numpy.polynomial.legendre.Legendre.mapparms,method,"[{'Returns': [{'name': 'off, scl', 'type': 'float or complex', 'description': 'The mapping function is defined by off + scl*x.'}]}]",
numpy.polynomial.legendre.Legendre.roots,method,"[{'Returns': [{'name': 'roots', 'type': 'ndarray', 'description': 'Array containing the roots of the series.'}]}]",
numpy.polynomial.legendre.Legendre.trim,method,"[{'Parameters': [{'name': 'tol', 'type': 'non-negative number.', 'description': 'All trailing coefficients less than tol will be removed.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with trimmed coefficients.'}]}]",
numpy.polynomial.legendre.Legendre.truncate,method,"[{'Parameters': [{'name': 'size', 'type': 'positive int', 'description': 'The series is reduced to length size by discarding the highdegree terms. The value of size must be a positive integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with truncated coefficients.'}]}]",
class numpy.random.SFC64(seed=None),BitGenerator for Chris Doty-Humphrey’s Small Fast Chaotic PRNG.,"[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like[ints], SeedSequence}, optional', 'description': 'A seed to initialize the BitGenerator. If None, then fresh,unpredictable entropy will be pulled from the OS. If an int orarray_like[ints] is passed, then it will be passed toSeedSequence to derive the initial BitGenerator state. One may alsopass in a SeedSequence instance.'}]}]",
numpy.random.SFC64.state,attribute,"[{'Returns': [{'name': 'state', 'type': 'dict', 'description': 'Dictionary containing the information required to describe thestate of the PRNG'}]}]",
numpy.random.SFC64.cffi,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.random.SFC64.ctypes,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.empty,"Return a new array of given shape and type, without initializing entries.","[{'Parameters': [{'name': 'shape', 'type': 'int or tuple of int', 'description': 'Shape of the empty array, e.g., (2, 3) or 2.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Desired output data-type for the array, e.g, numpy.int8. Default isnumpy.float64.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional, default: ‘C’', 'description': 'Whether to store multi-dimensional data in row-major(C-style) or column-major (Fortran-style) order inmemory.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of uninitialized (arbitrary) data of the given shape, dtype, andorder.  Object arrays will be initialized to None.'}]}]",">>> import numpy as np
>>> np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized
>>> np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #uninitialized"
numpy.empty_like,Return a new array with the same shape and type as a given array.,"[{'Parameters': [{'name': 'prototype', 'type': 'array_like', 'description': 'The shape and data-type of prototype define these same attributesof the returned array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Overrides the data type of the result.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, or ‘K’}, optional', 'description': 'Overrides the memory layout of the result. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if prototype is Fortrancontiguous, ‘C’ otherwise. ‘K’ means match the layout of prototypeas closely as possible.'}, {'name': 'subok', 'type': 'bool, optional.', 'description': 'If True, then the newly created array will use the sub-classtype of prototype, otherwise it will be a base-class array. Defaultsto True.'}, {'name': 'shape', 'type': 'int or sequence of ints, optional.', 'description': 'Overrides the shape of the result. If order=’K’ and the number ofdimensions is unchanged, will try to keep order, otherwise,order=’C’ is implied.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of uninitialized (arbitrary) data with the sameshape and type as prototype.'}]}]",">>> import numpy as np
>>> a = ([1,2,3], [4,5,6])                         # a is array-like
>>> np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
>>> np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])"
numpy.eye,Return a 2-D array with ones on the diagonal and zeros elsewhere.,"[{'Parameters': [{'name': 'N', 'type': 'int', 'description': 'Number of rows in the output.'}, {'name': 'M', 'type': 'int, optional', 'description': 'Number of columns in the output. If None, defaults to N.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Index of the diagonal: 0 (the default) refers to the main diagonal,a positive value refers to an upper diagonal, and a negative valueto a lower diagonal.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the returned array.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Whether the output should be stored in row-major (C-style) orcolumn-major (Fortran-style) order in memory.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'I', 'type': 'ndarray of shape (N,M)', 'description': 'An array where all elements are equal to zero, except for the k-thdiagonal, whose values are equal to one.'}]}]",">>> import numpy as np
>>> np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])
>>> np.eye(3, k=1)
array([[0.,  1.,  0.],
       [0.,  0.,  1.],
       [0.,  0.,  0.]])"
numpy.identity,Return the identity array.,"[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'Number of rows (and columns) in n x n output.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the output.  Defaults to float.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'n x n array with its main diagonal set to one,and all other elements 0.'}]}]",">>> import numpy as np
>>> np.identity(3)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])"
numpy.ones,"Return a new array of given shape and type, filled with ones.","[{'Parameters': [{'name': 'shape', 'type': 'int or sequence of ints', 'description': 'Shape of the new array, e.g., (2, 3) or 2.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The desired data-type for the array, e.g., numpy.int8.  Default isnumpy.float64.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional, default: C', 'description': 'Whether to store multi-dimensional data in row-major(C-style) or column-major (Fortran-style) order inmemory.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of ones with the given shape, dtype, and order.'}]}]",">>> import numpy as np
>>> np.ones(5)
array([1., 1., 1., 1., 1.])
>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])
>>> np.ones((2, 1))
array([[1.],
       [1.]])
>>> s = (2,2)
>>> np.ones(s)
array([[1.,  1.],
       [1.,  1.]])"
numpy.ones_like,Return an array of ones with the same shape and type as a given array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The shape and data-type of a define these same attributes ofthe returned array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Overrides the data type of the result.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, or ‘K’}, optional', 'description': 'Overrides the memory layout of the result. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible.'}, {'name': 'subok', 'type': 'bool, optional.', 'description': 'If True, then the newly created array will use the sub-classtype of a, otherwise it will be a base-class array. Defaultsto True.'}, {'name': 'shape', 'type': 'int or sequence of ints, optional.', 'description': 'Overrides the shape of the result. If order=’K’ and the number ofdimensions is unchanged, will try to keep order, otherwise,order=’C’ is implied.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of ones with the same shape and type as a.'}]}]",">>> import numpy as np
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])
>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.ones_like(y)
array([1.,  1.,  1.])"
numpy.zeros,"Return a new array of given shape and type, filled with zeros.","[{'Parameters': [{'name': 'shape', 'type': 'int or tuple of ints', 'description': 'Shape of the new array, e.g., (2, 3) or 2.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The desired data-type for the array, e.g., numpy.int8.  Default isnumpy.float64.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional, default: ‘C’', 'description': 'Whether to store multi-dimensional data in row-major(C-style) or column-major (Fortran-style) order inmemory.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of zeros with the given shape, dtype, and order.'}]}]",">>> import numpy as np
>>> np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])
>>> np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])
>>> np.zeros((2, 1))
array([[ 0.],
       [ 0.]])
>>> s = (2,2)
>>> np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])
>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '<i4'), ('y', '<i4')])"
numpy.zeros_like,Return an array of zeros with the same shape and type as a given array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The shape and data-type of a define these same attributes ofthe returned array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Overrides the data type of the result.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, or ‘K’}, optional', 'description': 'Overrides the memory layout of the result. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible.'}, {'name': 'subok', 'type': 'bool, optional.', 'description': 'If True, then the newly created array will use the sub-classtype of a, otherwise it will be a base-class array. Defaultsto True.'}, {'name': 'shape', 'type': 'int or sequence of ints, optional.', 'description': 'Overrides the shape of the result. If order=’K’ and the number ofdimensions is unchanged, will try to keep order, otherwise,order=’C’ is implied.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of zeros with the same shape and type as a.'}]}]",">>> import numpy as np
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])
>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.zeros_like(y)
array([0.,  0.,  0.])"
numpy.full,"Return a new array of given shape and type, filled with fill_value.","[{'Parameters': [{'name': 'shape', 'type': 'int or sequence of ints', 'description': 'Shape of the new array, e.g., (2, 3) or 2.'}, {'name': 'fill_value', 'type': 'scalar or array_like', 'description': 'Fill value.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The desired data-type for the array  The default, None, meansnp.array(fill_value).dtype.'}, {'name': 'The desired data-type for the array  The default, None, means', 'type': None, 'description': 'np.array(fill_value).dtype.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Whether to store multidimensional data in C- or Fortran-contiguous(row- or column-wise) order in memory.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of fill_value with the given shape, dtype, and order.'}]}]",">>> import numpy as np
>>> np.full((2, 2), np.inf)
array([[inf, inf],
       [inf, inf]])
>>> np.full((2, 2), 10)
array([[10, 10],
       [10, 10]])
>>> np.full((2, 2), [1, 2])
array([[1, 2],
       [1, 2]])"
numpy.full_like,Return a full array with the same shape and type as a given array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The shape and data-type of a define these same attributes ofthe returned array.'}, {'name': 'fill_value', 'type': 'array_like', 'description': 'Fill value.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Overrides the data type of the result.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, or ‘K’}, optional', 'description': 'Overrides the memory layout of the result. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible.'}, {'name': 'subok', 'type': 'bool, optional.', 'description': 'If True, then the newly created array will use the sub-classtype of a, otherwise it will be a base-class array. Defaultsto True.'}, {'name': 'shape', 'type': 'int or sequence of ints, optional.', 'description': 'Overrides the shape of the result. If order=’K’ and the number ofdimensions is unchanged, will try to keep order, otherwise,order=’C’ is implied.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array of fill_value with the same shape and type as a.'}]}]",">>> import numpy as np
>>> x = np.arange(6, dtype=int)
>>> np.full_like(x, 1)
array([1, 1, 1, 1, 1, 1])
>>> np.full_like(x, 0.1)
array([0, 0, 0, 0, 0, 0])
>>> np.full_like(x, 0.1, dtype=np.double)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
>>> np.full_like(x, np.nan, dtype=np.double)
array([nan, nan, nan, nan, nan, nan])
>>> y = np.arange(6, dtype=np.double)
>>> np.full_like(y, 0.1)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
>>> y = np.zeros([2, 2, 3], dtype=int)
>>> np.full_like(y, [0, 0, 255])
array([[[  0,   0, 255],
        [  0,   0, 255]],
       [[  0,   0, 255],
        [  0,   0, 255]]])"
numpy.array,Create an array.,"[{'Parameters': [{'name': 'object', 'type': 'array_like', 'description': 'An array, any object exposing the array interface, an object whose__array__ method returns an array, or any (nested) sequence.If object is a scalar, a 0-dimensional array containing object isreturned.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The desired data-type for the array. If not given, NumPy will try to usea default dtype that can represent the values (by applying promotionrules when necessary.)'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If True (default), then the array data is copied. If None,a copy will only be made if __array__ returns a copy, if obj isa nested sequence, or if a copy is needed to satisfy any of the otherrequirements (dtype, order, etc.). Note that any copy ofthe data is shallow, i.e., for arrays with object dtype, the newarray will point to the same objects. See Examples for ndarray.copy.For False it raises a ValueError if a copy cannot be avoided.Default: True.'}, {'name': 'order', 'type': '{‘K’, ‘A’, ‘C’, ‘F’}, optional', 'description': 'Specify the memory layout of the array. If object is not an array, thenewly created array will be in C order (row major) unless ‘F’ isspecified, in which case it will be in Fortran order (column major).If object is an array the following holds.orderno copycopy=True‘K’unchangedF & C order preserved, otherwise most similar order‘A’unchangedF order if input is F and not C, otherwise C order‘C’C orderC order‘F’F orderF orderWhen copy=None and a copy is made for other reasons, the result isthe same as if copy=True, with some exceptions for ‘A’, see theNotes section. The default order is ‘K’.'}, {'name': 'subok', 'type': 'bool, optional', 'description': 'If True, then sub-classes will be passed-through, otherwisethe returned array will be forced to be a base-class array (default).'}, {'name': 'ndmin', 'type': 'int, optional', 'description': 'Specifies the minimum number of dimensions that the resultingarray should have.  Ones will be prepended to the shape asneeded to meet this requirement.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array object satisfying the specified requirements.'}]}]",">>> import numpy as np
>>> np.array([1, 2, 3])
array([1, 2, 3])
>>> np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])
>>> np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])
>>> np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])
>>> np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])
>>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
>>> x['a']
array([1, 3], dtype=int32)
>>> np.array(np.asmatrix('1 2; 3 4'))
array([[1, 2],
       [3, 4]])
>>> np.array(np.asmatrix('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])"
numpy.asarray,Convert the input to an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data, in any form that can be converted to an array.  Thisincludes lists, lists of tuples, tuples, tuples of tuples, tuplesof lists and ndarrays.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.‘C’ row-major (C-style),‘F’ column-major (Fortran-style) memory representation.‘A’ (any) means ‘F’ if a is Fortran contiguous, ‘C’ otherwise‘K’ (keep) preserve input orderDefaults to ‘K’.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If True, then the object is copied. If None then the object iscopied only if needed, i.e. if __array__ returns a copy, if objis a nested sequence, or if a copy is needed to satisfy any ofthe other requirements (dtype, order, etc.).For False it raises a ValueError if a copy cannot be avoided.Default: None.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Array interpretation of a.  No copy is performed if the inputis already an ndarray with matching dtype and order.  If a is asubclass of ndarray, a base class ndarray is returned.'}]}]",">>> a = [1, 2]
>>> import numpy as np
>>> np.asarray(a)
array([1, 2])
>>> a = np.array([1, 2])
>>> np.asarray(a) is a
True
>>> a = np.array([1, 2], dtype=np.float32)
>>> np.shares_memory(np.asarray(a, dtype=np.float32), a)
True
>>> np.shares_memory(np.asarray(a, dtype=np.float64), a)
False
>>> issubclass(np.recarray, np.ndarray)
True
>>> a = np.array([(1., 2), (3., 4)], dtype='f4,i4').view(np.recarray)
>>> np.asarray(a) is a
False
>>> np.asanyarray(a) is a
True"
numpy.asanyarray,"Convert the input to an ndarray, but pass ndarray subclasses through.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data, in any form that can be converted to an array.  Thisincludes scalars, lists, lists of tuples, tuples, tuples of tuples,tuples of lists, and ndarrays.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Memory layout.  ‘A’ and ‘K’ depend on the order of input array a.‘C’ row-major (C-style),‘F’ column-major (Fortran-style) memory representation.‘A’ (any) means ‘F’ if a is Fortran contiguous, ‘C’ otherwise‘K’ (keep) preserve input orderDefaults to ‘C’.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.1.0.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If True, then the object is copied. If None then the object iscopied only if needed, i.e. if __array__ returns a copy, if objis a nested sequence, or if a copy is needed to satisfy any ofthe other requirements (dtype, order, etc.).For False it raises a ValueError if a copy cannot be avoided.Default: None.New in version 2.1.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or an ndarray subclass', 'description': 'Array interpretation of a.  If a is an ndarray or a subclassof ndarray, it is returned as-is and no copy is performed.'}]}]",">>> a = [1, 2]
>>> import numpy as np
>>> np.asanyarray(a)
array([1, 2])
>>> a = np.array([(1., 2), (3., 4)], dtype='f4,i4').view(np.recarray)
>>> np.asanyarray(a) is a
True"
numpy.ascontiguousarray,Return a contiguous array (ndim >= 1) in memory (C order).,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'dtype', 'type': 'str or dtype object, optional', 'description': 'Data-type of returned array.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Contiguous array of same shape and content as a, with type dtypeif specified.'}]}]",">>> import numpy as np
>>> x = np.ones((2, 3), order='F')
>>> x.flags['F_CONTIGUOUS']
True
>>> y = np.ascontiguousarray(x)
>>> y.flags['C_CONTIGUOUS']
True
>>> np.may_share_memory(x, y)
False
>>> x = np.ones((2, 3), order='C')
>>> x.flags['C_CONTIGUOUS']
True
>>> y = np.ascontiguousarray(x)
>>> x is y
True"
numpy.asmatrix,Interpret the input as a matrix.,"[{'Parameters': [{'name': 'data', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'dtype', 'type': 'data-type', 'description': 'Data-type of the output matrix.'}]}, {'Returns': [{'name': 'mat', 'type': 'matrix', 'description': 'data interpreted as a matrix.'}]}]",">>> import numpy as np
>>> x = np.array([[1, 2], [3, 4]])
>>> m = np.asmatrix(x)
>>> x[0,0] = 5
>>> m
matrix([[5, 2],
        [3, 4]])"
numpy.astype,Copies an array to a specified data type.,"[{'Parameters': [{'name': 'x', 'type': 'ndarray', 'description': 'Input NumPy array to cast. array_likes are explicitly notsupported here.'}, {'name': 'dtype', 'type': 'dtype', 'description': 'Data type of the result.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Specifies whether to copy an array when the specified dtype matchesthe data type of the input array x. If True, a newly allocatedarray must always be returned. If False and the specified dtypematches the data type of the input array, the input array must bereturned; otherwise, a newly allocated array must be returned.Defaults to True.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the returned array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.1.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array having the specified data type.'}]}]",">>> import numpy as np
>>> arr = np.array([1, 2, 3]); arr
array([1, 2, 3])
>>> np.astype(arr, np.float64)
array([1., 2., 3.])
>>> arr = np.array([1, 2, 3])
>>> arr_noncpy = np.astype(arr, arr.dtype, copy=False)
>>> np.shares_memory(arr, arr_noncpy)
True"
numpy.copy,Return an array copy of the given object.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Controls the memory layout of the copy. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible. (Note that this function and ndarray.copy are verysimilar, but have different default values for their order=arguments.)'}, {'name': 'subok', 'type': 'bool, optional', 'description': 'If True, then sub-classes will be passed-through, otherwise thereturned array will be forced to be a base-class array (defaults to False).'}]}, {'Returns': [{'name': 'arr', 'type': 'ndarray', 'description': 'Array interpretation of a.'}]}]",">>> np.array(a, copy=True)
>>> import numpy as np
>>> x = np.array([1, 2, 3])
>>> y = x
>>> z = np.copy(x)
>>> x[0] = 10
>>> x[0] == y[0]
True
>>> x[0] == z[0]
False
>>> a = np.array([1, 2, 3])
>>> a.flags[""WRITEABLE""] = False
>>> b = np.copy(a)
>>> b.flags[""WRITEABLE""]
True
>>> b[0] = 3
>>> b
array([3, 2, 3])"
numpy.frombuffer,Interpret a buffer as a 1-dimensional array.,"[{'Parameters': [{'name': 'buffer', 'type': 'buffer_like', 'description': 'An object that exposes the buffer interface.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the returned array; default: float.'}, {'name': 'count', 'type': 'int, optional', 'description': 'Number of items to read. -1 means all data in the buffer.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Start reading the buffer from this offset (in bytes); default: 0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': ''}]}]",">>> import numpy as np
>>> s = b'hello world'
>>> np.frombuffer(s, dtype='S1', count=5, offset=6)
array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')
>>> np.frombuffer(b'\x01\x02', dtype=np.uint8)
array([1, 2], dtype=uint8)
>>> np.frombuffer(b'\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
array([1, 2, 3], dtype=uint8)"
numpy.from_dlpack,"Create a NumPy array from an object implementing the __dlpack__
protocol. Generally, the returned NumPy array is a read-only view
of the input object. See [1] and [2] for more details.","[{'Parameters': [{'name': 'x', 'type': 'object', 'description': 'A Python object that implements the __dlpack__ and__dlpack_device__ methods.'}, {'name': 'device', 'type': 'device, optional', 'description': 'Device on which to place the created array. Default: None.Must be ""cpu"" if passed which may allow importing an arraythat is not already CPU available.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Boolean indicating whether or not to copy the input. If True,the copy will be made. If False, the function will never copy,and will raise BufferError in case a copy is deemed necessary.Passing it requests a copy from the exporter who may or may notimplement the capability.If None, the function will reuse the existing memory buffer ifpossible and copy otherwise. Default: None.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': ''}]}]",">>> import torch  
>>> x = torch.arange(10)  
>>> # create a view of the torch tensor ""x"" in NumPy
>>> y = np.from_dlpack(x)"
numpy.fromfile,Construct an array from data in a text or binary file.,"[{'Parameters': [{'name': 'file', 'type': 'file or str or Path', 'description': 'Open file object or filename.'}, {'name': 'dtype', 'type': 'data-type', 'description': 'Data type of the returned array.For binary files, it is used to determine the size and byte-orderof the items in the file.Most builtin numeric types are supported and extension types may be supported.'}, {'name': 'count', 'type': 'int', 'description': 'Number of items to read. -1 means all items (i.e., the completefile).'}, {'name': 'sep', 'type': 'str', 'description': 'Separator between items if file is a text file.Empty (“”) separator means the file should be treated as binary.Spaces (” “) in the separator match zero or more whitespace characters.A separator consisting only of spaces must match at least onewhitespace.'}, {'name': 'offset', 'type': 'int', 'description': 'The offset (in bytes) from the file’s current position. Defaults to 0.Only permitted for binary files.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}]",">>> import numpy as np
>>> dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),
...                ('temp', float)])
>>> x = np.zeros((1,), dtype=dt)
>>> x['time']['min'] = 10; x['temp'] = 98.25
>>> x
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
>>> import tempfile
>>> fname = tempfile.mkstemp()[1]
>>> x.tofile(fname)
>>> np.fromfile(fname, dtype=dt)
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
>>> np.save(fname, x)
>>> np.load(fname + '.npy')
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])"
numpy.fromfunction,Construct an array by executing a function over each coordinate.,"[{'Parameters': [{'name': 'function', 'type': 'callable', 'description': 'The function is called with N parameters, where N is the rank ofshape.  Each parameter represents the coordinates of the arrayvarying along a specific axis.  For example, if shapewere (2, 2), then the parameters would bearray([[0, 0], [1, 1]]) and array([[0, 1], [0, 1]])'}, {'name': 'shape', 'type': '(N,) tuple of ints', 'description': 'Shape of the output array, which also determines the shape ofthe coordinate arrays passed to function.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the coordinate arrays passed to function.By default, dtype is float.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'fromfunction', 'type': 'any', 'description': 'The result of the call to function is passed back directly.Therefore the shape of fromfunction is completely determined byfunction.  If function returns a scalar value, the shape offromfunction would not match the shape parameter.'}]}]",">>> import numpy as np
>>> np.fromfunction(lambda i, j: i, (2, 2), dtype=float)
array([[0., 0.],
       [1., 1.]])
>>> np.fromfunction(lambda i, j: j, (2, 2), dtype=float)
array([[0., 1.],
       [0., 1.]])
>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])
>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])"
numpy.fromiter,Create a new 1-dimensional array from an iterable object.,"[{'Parameters': [{'name': 'iter', 'type': 'iterable object', 'description': 'An iterable object providing data for the array.'}, {'name': 'dtype', 'type': 'data-type', 'description': 'The data-type of the returned array.Changed in version 1.23: Object and subarray dtypes are now supported (note that the finalresult is not 1-D for a subarray dtype).'}, {'name': 'count', 'type': 'int, optional', 'description': 'The number of items to read from iterable.  The default is -1,which means all data is read.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The output array.'}]}]",">>> import numpy as np
>>> iterable = (x*x for x in range(5))
>>> np.fromiter(iterable, float)
array([  0.,   1.,   4.,   9.,  16.])
>>> iterable = ((x+1, x+2) for x in range(5))
>>> np.fromiter(iterable, dtype=np.dtype((int, 2)))
array([[1, 2],
       [2, 3],
       [3, 4],
       [4, 5],
       [5, 6]])"
numpy.fromstring,A new 1-D array initialized from text data in a string.,"[{'Parameters': [{'name': 'string', 'type': 'str', 'description': 'A string containing the data.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The data type of the array; default: float.  For binary input data,the data must be in exactly this format. Most builtin numeric types aresupported and extension types may be supported.'}, {'name': 'count', 'type': 'int, optional', 'description': 'Read this number of dtype elements from the data.  If this isnegative (the default), the count will be determined from thelength of the data.'}, {'name': 'sep', 'type': 'str, optional', 'description': ""The string separating numbers in the data; extra whitespace betweenelements is also ignored.Deprecated since version 1.14: Passing sep='', the default, is deprecated since it willtrigger the deprecated binary mode of this function. This modeinterprets string as binary bytes, rather than ASCII text withdecimal numbers, an operation which is better speltfrombuffer(string, dtype, count). If string contains unicodetext, the binary mode of fromstring will first encode it intobytes using utf-8, which will not produce sane results.""}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'arr', 'type': 'ndarray', 'description': 'The constructed array.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the string is not the correct size to satisfy the requesteddtype and count.'}]}]",">>> import numpy as np
>>> np.fromstring('1 2', dtype=int, sep=' ')
array([1, 2])
>>> np.fromstring('1, 2', dtype=int, sep=',')
array([1, 2])"
numpy.loadtxt,Load data from a text file.,"[{'Parameters': [{'name': 'fname', 'type': 'file, str, pathlib.Path, list of str, generator', 'description': 'File, filename, list, or generator to read.  If the filenameextension is .gz or .bz2, the file is first decompressed. Notethat generators must return bytes or strings. The stringsin a list or produced by a generator are treated as lines.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the resulting array; default: float.  If this is astructured data-type, the resulting array will be 1-dimensional, andeach row will be interpreted as an element of the array.  In thiscase, the number of columns used must match the number of fields inthe data-type.'}, {'name': 'comments', 'type': 'str or sequence of str or None, optional', 'description': 'The characters or list of characters used to indicate the start of acomment. None implies no comments. For backwards compatibility, bytestrings will be decoded as ‘latin1’. The default is ‘#’.'}, {'name': 'delimiter', 'type': 'str, optional', 'description': 'The character used to separate the values. For backwards compatibility,byte strings will be decoded as ‘latin1’. The default is whitespace.Changed in version 1.23.0: Only single character delimiters are supported. Newline characterscannot be used as the delimiter.'}, {'name': 'converters', 'type': 'dict or callable, optional', 'description': 'Converter functions to customize value parsing. If converters iscallable, the function is applied to all columns, else it must be adict that maps column number to a parser function.See examples for further details.Default: None.Changed in version 1.23.0: The ability to pass a single callable to be applied to all columnswas added.'}, {'name': 'skiprows', 'type': 'int, optional', 'description': 'Skip the first skiprows lines, including comments; default: 0.'}, {'name': 'usecols', 'type': 'int or sequence, optional', 'description': 'Which columns to read, with 0 being the first. For example,usecols = (1,4,5) will extract the 2nd, 5th and 6th columns.The default, None, results in all columns being read.'}, {'name': 'unpack', 'type': 'bool, optional', 'description': 'If True, the returned array is transposed, so that arguments may beunpacked using x, y, z = loadtxt(...).  When used with astructured data-type, arrays are returned for each field.Default is False.'}, {'name': 'ndmin', 'type': 'int, optional', 'description': 'The returned array will have at least ndmin dimensions.Otherwise mono-dimensional axes will be squeezed.Legal values: 0 (default), 1 or 2.'}, {'name': 'encoding', 'type': 'str, optional', 'description': ""Encoding used to decode the inputfile. Does not apply to input streams.The special value ‘bytes’ enables backward compatibility workaroundsthat ensures you receive byte arrays as results if possible and passes‘latin1’ encoded strings to converters. Override this value to receiveunicode arrays and pass strings as input to converters.  If set to Nonethe system default is used. The default value is ‘bytes’.Changed in version 2.0: Before NumPy 2, the default was 'bytes' for Python 2compatibility. The default is now None.""}, {'name': 'max_rows', 'type': 'int, optional', 'description': 'Read max_rows rows of content after skiprows lines. The default isto read all the rows. Note that empty rows containing no data such asempty lines and comment lines are not counted towards max_rows,while such lines are counted in skiprows.Changed in version 1.23.0: Lines containing no data, including comment lines (e.g., linesstarting with ‘#’ or as specified via comments) are not countedtowards max_rows.'}, {'name': 'quotechar', 'type': 'unicode character or None, optional', 'description': 'The character used to denote the start and end of a quoted item.Occurrences of the delimiter or comment characters are ignored withina quoted item. The default value is quotechar=None, which meansquoting support is disabled.If two consecutive instances of quotechar are found within a quotedfield, the first is treated as an escape character. See examples.New in version 1.23.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Data read from the text file.'}]}]",">>> import numpy as np
>>> from io import StringIO   # StringIO behaves like a file object
>>> c = StringIO(""0 1\n2 3"")
>>> np.loadtxt(c)
array([[0., 1.],
       [2., 3.]])
>>> d = StringIO(""M 21 72\nF 35 58"")
>>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
...                      'formats': ('S1', 'i4', 'f4')})
array([(b'M', 21, 72.), (b'F', 35, 58.)],
      dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])
>>> c = StringIO(""1,0,2\n3,0,4"")
>>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)
>>> x
array([1., 3.])
>>> y
array([2., 4.])
>>> s = StringIO(""1.618, 2.296\n3.141, 4.669\n"")
>>> conv = {
...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0
...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1
... }
>>> np.loadtxt(s, delimiter="","", converters=conv)
array([[1., 3.],
       [3., 5.]])
>>> s = StringIO(""0xDE 0xAD\n0xC0 0xDE"")
>>> import functools
>>> conv = functools.partial(int, base=16)
>>> np.loadtxt(s, converters=conv)
array([[222., 173.],
       [192., 222.]])
>>> s = StringIO(""10.01 31.25-\n19.22 64.31\n17.57- 63.94"")
>>> def conv(fld):
...     return -float(fld[:-1]) if fld.endswith(""-"") else float(fld)
...
>>> np.loadtxt(s, converters=conv)
array([[ 10.01, -31.25],
       [ 19.22,  64.31],
       [-17.57,  63.94]])
>>> s = StringIO(""1 2.7 100_000"")
>>> np.loadtxt(s, converters=float)
array([1.e+00, 2.7e+00, 1.e+05])
>>> def conv(val):
...     try:
...         return float(val)
...     except ValueError:
...         return float.fromhex(val)
>>> s = StringIO(""1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2"")
>>> np.loadtxt(s, delimiter="","", converters=conv)
array([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])
>>> s = StringIO(""10.01 31.25-\n19.22 64.31\n17.57- 63.94"")
>>> conv = lambda x: -float(x[:-1]) if x.endswith(""-"") else float(x)
>>> np.loadtxt(s, converters=conv)
array([[ 10.01, -31.25],
       [ 19.22,  64.31],
       [-17.57,  63.94]])
>>> s = StringIO('""alpha, #42"", 10.0\n""beta, #64"", 2.0\n')
>>> dtype = np.dtype([(""label"", ""U12""), (""value"", float)])
>>> np.loadtxt(s, dtype=dtype, delimiter="","", quotechar='""')
array([('alpha, #42', 10.), ('beta, #64',  2.)],
      dtype=[('label', '<U12'), ('value', '<f8')])
>>> s = StringIO('""alpha, #42""       10.0\n""beta, #64"" 2.0\n')
>>> dtype = np.dtype([(""label"", ""U12""), (""value"", float)])
>>> np.loadtxt(s, dtype=dtype, delimiter=None, quotechar='""')
array([('alpha, #42', 10.), ('beta, #64',  2.)],
      dtype=[('label', '<U12'), ('value', '<f8')])
>>> s = StringIO('""Hello, my name is """"Monty""""!""')
>>> np.loadtxt(s, dtype=""U"", delimiter="","", quotechar='""')
array('Hello, my name is ""Monty""!', dtype='<U26')
>>> d = StringIO(""1 2\n2 4\n3 9 12\n4 16 20"")
>>> np.loadtxt(d, usecols=(0, 1))
array([[ 1.,  2.],
       [ 2.,  4.],
       [ 3.,  9.],
       [ 4., 16.]])"
numpy.rec.array,Construct a record array from a wide-variety of objects.,"[{'Parameters': [{'name': 'obj', 'type': 'any', 'description': 'Input object. See Notes for details on how various input types aretreated.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Valid dtype for array.'}, {'name': 'shape', 'type': 'int or tuple of ints, optional', 'description': 'Shape of each array.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Position in the file or buffer to start reading from.'}, {'name': 'strides', 'type': 'tuple of ints, optional', 'description': 'Buffer (buf) is interpreted according to these strides (stridesdefine how many bytes each array element, row, column, etc.occupy in memory).'}, {'name': 'formats, names, titles, aligned, byteorder', 'type': None, 'description': 'If dtype is None, these arguments are passed tonumpy.format_parser to construct a dtype. See that function fordetailed documentation.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Whether to copy the input object (True), or to use a reference instead.This option only applies when the input is an ndarray or recarray.Defaults to True.'}]}, {'Returns': [{'name': 'np.recarray', 'type': None, 'description': 'Record array created from the specified object.'}]}]",">>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> a
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> np.rec.array(a)
rec.array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]],
          dtype=int64)
>>> b = [(1, 1), (2, 4), (3, 9)]
>>> c = np.rec.array(b, formats = ['i2', 'f2'], names = ('x', 'y'))
>>> c
rec.array([(1, 1.), (2, 4.), (3, 9.)],
          dtype=[('x', '<i2'), ('y', '<f2')])
>>> c.x
array([1, 2, 3], dtype=int16)
>>> c.y
array([1.,  4.,  9.], dtype=float16)
>>> r = np.rec.array(['abc','def'], names=['col1','col2'])
>>> print(r.col1)
abc
>>> r.col1
array('abc', dtype='<U3')
>>> r.col2
array('def', dtype='<U3')"
numpy.rec.fromarrays,Create a record array from a (flat) list of arrays,"[{'Parameters': [{'name': 'arrayList', 'type': 'list or tuple', 'description': 'List of array-like objects (such as lists, tuples,and ndarrays).'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'valid dtype for all arrays'}, {'name': 'shape', 'type': 'int or tuple of ints, optional', 'description': 'Shape of the resulting array. If not provided, inferred fromarrayList[0].'}, {'name': 'formats, names, titles, aligned, byteorder', 'type': None, 'description': 'If dtype is None, these arguments are passed tonumpy.rec.format_parser to construct a dtype. See that function fordetailed documentation.'}]}, {'Returns': [{'name': 'np.recarray', 'type': None, 'description': 'Record array consisting of given arrayList columns.'}]}]",">>> x1=np.array([1,2,3,4])
>>> x2=np.array(['a','dd','xyz','12'])
>>> x3=np.array([1.1,2,3,4])
>>> r = np.rec.fromarrays([x1,x2,x3],names='a,b,c')
>>> print(r[1])
(2, 'dd', 2.0) # may vary
>>> x1[1]=34
>>> r.a
array([1, 2, 3, 4])
>>> x1 = np.array([1, 2, 3, 4])
>>> x2 = np.array(['a', 'dd', 'xyz', '12'])
>>> x3 = np.array([1.1, 2, 3,4])
>>> r = np.rec.fromarrays(
...     [x1, x2, x3],
...     dtype=np.dtype([('a', np.int32), ('b', 'S3'), ('c', np.float32)]))
>>> r
rec.array([(1, b'a', 1.1), (2, b'dd', 2. ), (3, b'xyz', 3. ),
           (4, b'12', 4. )],
          dtype=[('a', '<i4'), ('b', 'S3'), ('c', '<f4')])"
numpy.rec.fromrecords,Create a recarray from a list of records in text form.,"[{'Parameters': [{'name': 'recList', 'type': 'sequence', 'description': 'data in the same field may be heterogeneous - they will be promotedto the highest data type.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'valid dtype for all arrays'}, {'name': 'shape', 'type': 'int or tuple of ints, optional', 'description': 'shape of each array.'}, {'name': 'formats, names, titles, aligned, byteorder', 'type': None, 'description': 'If dtype is None, these arguments are passed tonumpy.format_parser to construct a dtype. See that function fordetailed documentation.If both formats and dtype are None, then this will auto-detectformats. Use list of tuples rather than list of lists for fasterprocessing.'}]}, {'Returns': [{'name': 'np.recarray', 'type': None, 'description': 'record array consisting of given recList rows.'}]}]",">>> r=np.rec.fromrecords([(456,'dbe',1.2),(2,'de',1.3)],
... names='col1,col2,col3')
>>> print(r[0])
(456, 'dbe', 1.2)
>>> r.col1
array([456,   2])
>>> r.col2
array(['dbe', 'de'], dtype='<U3')
>>> import pickle
>>> pickle.loads(pickle.dumps(r))
rec.array([(456, 'dbe', 1.2), (  2, 'de', 1.3)],
          dtype=[('col1', '<i8'), ('col2', '<U3'), ('col3', '<f8')])"
numpy.rec.fromstring,Create a record array from binary data,"[{'Parameters': [{'name': 'datastring', 'type': 'bytes-like', 'description': 'Buffer of binary data'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Valid dtype for all arrays'}, {'name': 'shape', 'type': 'int or tuple of ints, optional', 'description': 'Shape of each array.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Position in the buffer to start reading from.'}, {'name': 'formats, names, titles, aligned, byteorder', 'type': None, 'description': 'If dtype is None, these arguments are passed tonumpy.format_parser to construct a dtype. See that function fordetailed documentation.'}]}, {'Returns': [{'name': 'np.recarray', 'type': None, 'description': 'Record array view into the data in datastring. This will be readonlyif datastring is readonly.'}]}]",">>> a = b'\x01\x02\x03abc'
>>> np.rec.fromstring(a, dtype='u1,u1,u1,S3')
rec.array([(1, 2, 3, b'abc')],
        dtype=[('f0', 'u1'), ('f1', 'u1'), ('f2', 'u1'), ('f3', 'S3')])
>>> grades_dtype = [('Name', (np.str_, 10)), ('Marks', np.float64),
...                 ('GradeLevel', np.int32)]
>>> grades_array = np.array([('Sam', 33.3, 3), ('Mike', 44.4, 5),
...                         ('Aadi', 66.6, 6)], dtype=grades_dtype)
>>> np.rec.fromstring(grades_array.tobytes(), dtype=grades_dtype)
rec.array([('Sam', 33.3, 3), ('Mike', 44.4, 5), ('Aadi', 66.6, 6)],
        dtype=[('Name', '<U10'), ('Marks', '<f8'), ('GradeLevel', '<i4')])
>>> s = '\x01\x02\x03abc'
>>> np.rec.fromstring(s, dtype='u1,u1,u1,S3')
Traceback (most recent call last):
   ...
TypeError: a bytes-like object is required, not 'str'"
numpy.rec.fromfile,Create an array from binary file data,"[{'Parameters': [{'name': 'fd', 'type': 'str or file type', 'description': 'If file is a string or a path-like object then that file is opened,else it is assumed to be a file object. The file object mustsupport random access (i.e. it must have tell and seek methods).'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'valid dtype for all arrays'}, {'name': 'shape', 'type': 'int or tuple of ints, optional', 'description': 'shape of each array.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Position in the file to start reading from.'}, {'name': 'formats, names, titles, aligned, byteorder', 'type': None, 'description': 'If dtype is None, these arguments are passed tonumpy.format_parser to construct a dtype. See that function fordetailed documentation'}]}, {'Returns': [{'name': 'np.recarray', 'type': None, 'description': 'record array consisting of data enclosed in file.'}]}]",">>> from tempfile import TemporaryFile
>>> a = np.empty(10,dtype='f8,i4,a5')
>>> a[5] = (0.5,10,'abcde')
>>>
>>> fd=TemporaryFile()
>>> a = a.view(a.dtype.newbyteorder('<'))
>>> a.tofile(fd)
>>>
>>> _ = fd.seek(0)
>>> r=np.rec.fromfile(fd, formats='f8,i4,a5', shape=10,
... byteorder='<')
>>> print(r[5])
(0.5, 10, b'abcde')
>>> r.shape
(10,)"
numpy.char.array,Create a chararray.,"[{'Parameters': [{'name': 'obj', 'type': 'array of str or unicode-like', 'description': ''}, {'name': 'itemsize', 'type': 'int, optional', 'description': 'itemsize is the number of characters per scalar in theresulting array.  If itemsize is None, and obj is anobject array or a Python list, the itemsize will beautomatically determined.  If itemsize is provided and objis of type str or unicode, then the obj string will bechunked into itemsize pieces.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If true (default), then the object is copied.  Otherwise, a copywill only be made if __array__ returns a copy, if obj is anested sequence, or if a copy is needed to satisfy any of the otherrequirements (itemsize, unicode, order, etc.).'}, {'name': 'unicode', 'type': 'bool, optional', 'description': 'When true, the resulting chararray can contain Unicodecharacters, when false only 8-bit characters.  If unicode isNone and obj is one of the following:a chararray,an ndarray of type str_ or bytes_a Python str or bytes object,then the unicode setting of the output array will beautomatically determined.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’}, optional', 'description': 'Specify the order of the array.  If order is ‘C’ (default), then thearray will be in C-contiguous order (last-index varies thefastest).  If order is ‘F’, then the returned arraywill be in Fortran-contiguous order (first-index varies thefastest).  If order is ‘A’, then the returned array maybe in any order (either C-, Fortran-contiguous, or evendiscontiguous).'}]}]",">>> import numpy as np
>>> char_array = np.char.array(['hello', 'world', 'numpy','array'])
>>> char_array
chararray(['hello', 'world', 'numpy', 'array'], dtype='<U5')"
numpy.char.asarray,"Convert the input to a chararray, copying the data only if
necessary.","[{'Parameters': [{'name': 'obj', 'type': 'array of str or unicode-like', 'description': ''}, {'name': 'itemsize', 'type': 'int, optional', 'description': 'itemsize is the number of characters per scalar in theresulting array.  If itemsize is None, and obj is anobject array or a Python list, the itemsize will beautomatically determined.  If itemsize is provided and objis of type str or unicode, then the obj string will bechunked into itemsize pieces.'}, {'name': 'unicode', 'type': 'bool, optional', 'description': 'When true, the resulting chararray can contain Unicodecharacters, when false only 8-bit characters.  If unicode isNone and obj is one of the following:a chararray,an ndarray of type str_ or unicode_a Python str or unicode object,then the unicode setting of the output array will beautomatically determined.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Specify the order of the array.  If order is ‘C’ (default), then thearray will be in C-contiguous order (last-index varies thefastest).  If order is ‘F’, then the returned arraywill be in Fortran-contiguous order (first-index varies thefastest).'}]}]",">>> import numpy as np
>>> np.char.asarray(['hello', 'world'])
chararray(['hello', 'world'], dtype='<U5')"
numpy.char.chararray,Provides a convenient view on arrays of string and unicode values.,"[{'Parameters': [{'name': 'shape', 'type': 'tuple', 'description': 'Shape of the array.'}, {'name': 'itemsize', 'type': 'int, optional', 'description': 'Length of each array element, in number of characters. Default is 1.'}, {'name': 'unicode', 'type': 'bool, optional', 'description': 'Are the array elements of type unicode (True) or string (False).Default is False.'}, {'name': 'buffer', 'type': 'object exposing the buffer interface or str, optional', 'description': 'Memory address of the start of the array data.  Default is None,in which case a new array is created.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Fixed stride displacement from the beginning of an axis?Default is 0. Needs to be >=0.'}, {'name': 'strides', 'type': 'array_like of ints, optional', 'description': 'Strides for the array (see strides forfull description). Default is None.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'The order in which the array data is stored in memory: ‘C’ ->“row major” order (the default), ‘F’ -> “column major”(Fortran) order.'}]}, {'Attributes': [{'name': 'T', 'type': None, 'description': 'View of the transposed array.'}, {'name': 'base', 'type': None, 'description': 'Base object if memory is from some other object.'}, {'name': 'ctypes', 'type': None, 'description': 'An object to simplify the interaction of the array with the ctypes module.'}, {'name': 'data', 'type': None, 'description': 'Python buffer object pointing to the start of the array’s data.'}, {'name': 'device', 'type': None, 'description': ''}, {'name': 'dtype', 'type': None, 'description': 'Data-type of the array’s elements.'}, {'name': 'flags', 'type': None, 'description': 'Information about the memory layout of the array.'}, {'name': 'flat', 'type': None, 'description': 'A 1-D iterator over the array.'}, {'name': 'imag', 'type': None, 'description': 'The imaginary part of the array.'}, {'name': 'itemset', 'type': None, 'description': ''}, {'name': 'itemsize', 'type': None, 'description': 'Length of one array element in bytes.'}, {'name': 'mT', 'type': None, 'description': 'View of the matrix transposed array.'}, {'name': 'nbytes', 'type': None, 'description': 'Total bytes consumed by the elements of the array.'}, {'name': 'ndim', 'type': None, 'description': 'Number of array dimensions.'}, {'name': 'newbyteorder', 'type': None, 'description': ''}, {'name': 'ptp', 'type': None, 'description': ''}, {'name': 'real', 'type': None, 'description': 'The real part of the array.'}, {'name': 'shape', 'type': None, 'description': 'Tuple of array dimensions.'}, {'name': 'size', 'type': None, 'description': 'Number of elements in the array.'}, {'name': 'strides', 'type': None, 'description': 'Tuple of bytes to step in each dimension when traversing an array.'}]}]",">>> import numpy as np
>>> charar = np.char.chararray((3, 3))
>>> charar[:] = 'a'
>>> charar
chararray([[b'a', b'a', b'a'],
           [b'a', b'a', b'a'],
           [b'a', b'a', b'a']], dtype='|S1')
>>> charar = np.char.chararray(charar.shape, itemsize=5)
>>> charar[:] = 'abc'
>>> charar
chararray([[b'abc', b'abc', b'abc'],
           [b'abc', b'abc', b'abc'],
           [b'abc', b'abc', b'abc']], dtype='|S5')"
numpy.arange,Return evenly spaced values within a given interval.,"[{'Parameters': [{'name': 'start', 'type': 'integer or real, optional', 'description': 'Start of interval.  The interval includes this value.  The defaultstart value is 0.'}, {'name': 'stop', 'type': 'integer or real', 'description': 'End of interval.  The interval does not include this value, exceptin some cases where step is not an integer and floating pointround-off affects the length of out.'}, {'name': 'step', 'type': 'integer or real, optional', 'description': 'Spacing between values.  For any output out, this is the distancebetween two adjacent values, out[i+1] - out[i].  The defaultstep size is 1.  If step is specified as a position argument,start must also be given.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'The type of the output array.  If dtype is not given, infer the datatype from the other input arguments.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'arange', 'type': 'ndarray', 'description': 'Array of evenly spaced values.For floating point arguments, the length of the result isceil((stop - start)/step).  Because of floating point overflow,this rule may result in the last element of out being greaterthan stop.'}]}]",">>> import numpy as np
>>> np.arange(3)
array([0, 1, 2])
>>> np.arange(3.0)
array([ 0.,  1.,  2.])
>>> np.arange(3,7)
array([3, 4, 5, 6])
>>> np.arange(3,7,2)
array([3, 5])"
numpy.linspace,Return evenly spaced numbers over a specified interval.,"[{'Parameters': [{'name': 'start', 'type': 'array_like', 'description': 'The starting value of the sequence.'}, {'name': 'stop', 'type': 'array_like', 'description': 'The end value of the sequence, unless endpoint is set to False.In that case, the sequence consists of all but the last of num + 1evenly spaced samples, so that stop is excluded.  Note that the stepsize changes when endpoint is False.'}, {'name': 'num', 'type': 'int, optional', 'description': 'Number of samples to generate. Default is 50. Must be non-negative.'}, {'name': 'endpoint', 'type': 'bool, optional', 'description': 'If True, stop is the last sample. Otherwise, it is not included.Default is True.'}, {'name': 'retstep', 'type': 'bool, optional', 'description': 'If True, return (samples, step), where step is the spacingbetween samples.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'The type of the output array.  If dtype is not given, the data typeis inferred from start and stop. The inferred dtype will never bean integer; float is chosen even if the arguments would produce anarray of integers.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis in the result to store the samples.  Relevant only if startor stop are array-like.  By default (0), the samples will be along anew axis inserted at the beginning. Use -1 to get an axis at the end.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray', 'description': 'There are num equally spaced samples in the closed interval[start, stop] or the half-open interval [start, stop)(depending on whether endpoint is True or False).'}, {'name': 'step', 'type': 'float, optional', 'description': 'Only returned if retstep is TrueSize of spacing between samples.'}]}]",">>> import numpy as np
>>> np.linspace(2.0, 3.0, num=5)
array([2.  , 2.25, 2.5 , 2.75, 3.  ])
>>> np.linspace(2.0, 3.0, num=5, endpoint=False)
array([2. ,  2.2,  2.4,  2.6,  2.8])
>>> np.linspace(2.0, 3.0, num=5, retstep=True)
(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
>>> import matplotlib.pyplot as plt
>>> N = 8
>>> y = np.zeros(N)
>>> x1 = np.linspace(0, 10, N, endpoint=True)
>>> x2 = np.linspace(0, 10, N, endpoint=False)
>>> plt.plot(x1, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.plot(x2, y + 0.5, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.ylim([-0.5, 1])
(-0.5, 1)
>>> plt.show()"
numpy.logspace,Return numbers spaced evenly on a log scale.,"[{'Parameters': [{'name': 'start', 'type': 'array_like', 'description': 'base ** start is the starting value of the sequence.'}, {'name': 'stop', 'type': 'array_like', 'description': 'base ** stop is the final value of the sequence, unless endpointis False.  In that case, num + 1 values are spaced over theinterval in log-space, of which all but the last (a sequence oflength num) are returned.'}, {'name': 'num', 'type': 'integer, optional', 'description': 'Number of samples to generate.  Default is 50.'}, {'name': 'endpoint', 'type': 'boolean, optional', 'description': 'If true, stop is the last sample. Otherwise, it is not included.Default is True.'}, {'name': 'base', 'type': 'array_like, optional', 'description': 'The base of the log space. The step size between the elements inln(samples) / ln(base) (or log_base(samples)) is uniform.Default is 10.0.'}, {'name': 'dtype', 'type': 'dtype', 'description': 'The type of the output array.  If dtype is not given, the data typeis inferred from start and stop. The inferred type will never bean integer; float is chosen even if the arguments would produce anarray of integers.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis in the result to store the samples.  Relevant only if start,stop, or base are array-like.  By default (0), the samples will bealong a new axis inserted at the beginning. Use -1 to get an axis atthe end.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray', 'description': 'num samples, equally spaced on a log scale.'}]}]",">>> y = np.linspace(start, stop, num=num, endpoint=endpoint)
... 
>>> power(base, y).astype(dtype)
...
>>> import numpy as np
>>> np.logspace(2.0, 3.0, num=4)
array([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])
>>> np.logspace(2.0, 3.0, num=4, endpoint=False)
array([100.        ,  177.827941  ,  316.22776602,  562.34132519])
>>> np.logspace(2.0, 3.0, num=4, base=2.0)
array([4.        ,  5.0396842 ,  6.34960421,  8.        ])
>>> np.logspace(2.0, 3.0, num=4, base=[2.0, 3.0], axis=-1)
array([[ 4.        ,  5.0396842 ,  6.34960421,  8.        ],
       [ 9.        , 12.98024613, 18.72075441, 27.        ]])
>>> import matplotlib.pyplot as plt
>>> N = 10
>>> x1 = np.logspace(0.1, 1, N, endpoint=True)
>>> x2 = np.logspace(0.1, 1, N, endpoint=False)
>>> y = np.zeros(N)
>>> plt.plot(x1, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.plot(x2, y + 0.5, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.ylim([-0.5, 1])
(-0.5, 1)
>>> plt.show()"
numpy.geomspace,Return numbers spaced evenly on a log scale (a geometric progression).,"[{'Parameters': [{'name': 'start', 'type': 'array_like', 'description': 'The starting value of the sequence.'}, {'name': 'stop', 'type': 'array_like', 'description': 'The final value of the sequence, unless endpoint is False.In that case, num + 1 values are spaced over theinterval in log-space, of which all but the last (a sequence oflength num) are returned.'}, {'name': 'num', 'type': 'integer, optional', 'description': 'Number of samples to generate.  Default is 50.'}, {'name': 'endpoint', 'type': 'boolean, optional', 'description': 'If true, stop is the last sample. Otherwise, it is not included.Default is True.'}, {'name': 'dtype', 'type': 'dtype', 'description': 'The type of the output array.  If dtype is not given, the data typeis inferred from start and stop. The inferred dtype will never bean integer; float is chosen even if the arguments would produce anarray of integers.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis in the result to store the samples.  Relevant only if startor stop are array-like.  By default (0), the samples will be along anew axis inserted at the beginning. Use -1 to get an axis at the end.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray', 'description': 'num samples, equally spaced on a log scale.'}]}]",">>> import numpy as np
>>> np.geomspace(1, 1000, num=4)
array([    1.,    10.,   100.,  1000.])
>>> np.geomspace(1, 1000, num=3, endpoint=False)
array([   1.,   10.,  100.])
>>> np.geomspace(1, 1000, num=4, endpoint=False)
array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])
>>> np.geomspace(1, 256, num=9)
array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])
>>> np.geomspace(1, 256, num=9, dtype=int)
array([  1,   2,   4,   7,  16,  32,  63, 127, 256])
>>> np.around(np.geomspace(1, 256, num=9)).astype(int)
array([  1,   2,   4,   8,  16,  32,  64, 128, 256])
>>> np.geomspace(1000, 1, num=4)
array([1000.,  100.,   10.,    1.])
>>> np.geomspace(-1000, -1, num=4)
array([-1000.,  -100.,   -10.,    -1.])
>>> np.geomspace(1j, 1000j, num=4)  # Straight line
array([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])
>>> np.geomspace(-1+0j, 1+0j, num=5)  # Circle
array([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,
        6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,
        1.00000000e+00+0.00000000e+00j])
>>> import matplotlib.pyplot as plt
>>> N = 10
>>> y = np.zeros(N)
>>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.axis([0.5, 2000, 0, 3])
[0.5, 2000, 0, 3]
>>> plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')
>>> plt.show()"
numpy.meshgrid,Return a tuple of coordinate matrices from coordinate vectors.,"[{'Parameters': [{'name': 'x1, x2,…, xn', 'type': 'array_like', 'description': '1-D arrays representing the coordinates of a grid.'}, {'name': 'indexing', 'type': '{‘xy’, ‘ij’}, optional', 'description': 'Cartesian (‘xy’, default) or matrix (‘ij’) indexing of output.See Notes for more details.'}, {'name': 'sparse', 'type': 'bool, optional', 'description': 'If True the shape of the returned coordinate array for dimension iis reduced from (N1, ..., Ni, ... Nn) to(1, ..., 1, Ni, 1, ..., 1).  These sparse coordinate grids areintended to be use with Broadcasting.  When allcoordinates are used in an expression, broadcasting still leads to afully-dimensonal result array.Default is False.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If False, a view into the original arrays are returned in order toconserve memory.  Default is True.  Please note thatsparse=False, copy=False will likely return non-contiguousarrays.  Furthermore, more than one element of a broadcast arraymay refer to a single memory location.  If you need to write to thearrays, make copies first.'}]}, {'Returns': [{'name': 'X1, X2,…, XN', 'type': 'tuple of ndarrays', 'description': 'For vectors x1, x2,…, xn with lengths Ni=len(xi),returns (N1, N2, N3,..., Nn) shaped arrays if indexing=’ij’or (N2, N1, N3,..., Nn) shaped arrays if indexing=’xy’with the elements of xi repeated to fill the matrix alongthe first dimension for x1, the second for x2 and so on.'}]}]",">>> import numpy as np
>>> nx, ny = (3, 2)
>>> x = np.linspace(0, 1, nx)
>>> y = np.linspace(0, 1, ny)
>>> xv, yv = np.meshgrid(x, y)
>>> xv
array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])
>>> yv
array([[0.,  0.,  0.],
       [1.,  1.,  1.]])
>>> import matplotlib.pyplot as plt
>>> plt.plot(xv, yv, marker='o', color='k', linestyle='none')
>>> plt.show()
>>> xv, yv = np.meshgrid(x, y, sparse=True)
>>> xv
array([[0. ,  0.5,  1. ]])
>>> yv
array([[0.],
       [1.]])
>>> x = np.linspace(-5, 5, 101)
>>> y = np.linspace(-5, 5, 101)
>>> # full coordinate arrays
>>> xx, yy = np.meshgrid(x, y)
>>> zz = np.sqrt(xx**2 + yy**2)
>>> xx.shape, yy.shape, zz.shape
((101, 101), (101, 101), (101, 101))
>>> # sparse coordinate arrays
>>> xs, ys = np.meshgrid(x, y, sparse=True)
>>> zs = np.sqrt(xs**2 + ys**2)
>>> xs.shape, ys.shape, zs.shape
((1, 101), (101, 1), (101, 101))
>>> np.array_equal(zz, zs)
True
>>> h = plt.contourf(x, y, zs)
>>> plt.axis('scaled')
>>> plt.colorbar()
>>> plt.show()"
numpy.mgrid,An instance which returns a dense multi-dimensional “meshgrid”.,"[{'Returns': [{'name': 'mesh-grid', 'type': 'ndarray', 'description': 'A single array, containing a set of ndarrays all of the samedimensions. stacked along the first axis.'}]}]",">>> import numpy as np
>>> np.mgrid[0:5, 0:5]
array([[[0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1],
        [2, 2, 2, 2, 2],
        [3, 3, 3, 3, 3],
        [4, 4, 4, 4, 4]],
       [[0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4]]])
>>> np.mgrid[-1:1:5j]
array([-1. , -0.5,  0. ,  0.5,  1. ])
>>> np.mgrid[0:4].shape
(4,)
>>> np.mgrid[0:4, 0:5].shape
(2, 4, 5)
>>> np.mgrid[0:4, 0:5, 0:6].shape
(3, 4, 5, 6)"
numpy.ogrid,An instance which returns an open multi-dimensional “meshgrid”.,"[{'Returns': [{'name': 'mesh-grid', 'type': 'ndarray or tuple of ndarrays', 'description': 'If the input is a single slice, returns an array.If the input is multiple slices, returns a tuple of arrays, withonly one dimension not equal to 1.'}]}]",">>> from numpy import ogrid
>>> ogrid[-1:1:5j]
array([-1. , -0.5,  0. ,  0.5,  1. ])
>>> ogrid[0:5, 0:5]
(array([[0],
        [1],
        [2],
        [3],
        [4]]),
 array([[0, 1, 2, 3, 4]]))"
numpy.diag,Extract a diagonal or construct a diagonal array.,"[{'Parameters': [{'name': 'v', 'type': 'array_like', 'description': 'If v is a 2-D array, return a copy of its k-th diagonal.If v is a 1-D array, return a 2-D array with v on the k-thdiagonal.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal in question. The default is 0. Use k>0 for diagonalsabove the main diagonal, and k<0 for diagonals below the maindiagonal.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The extracted diagonal or constructed diagonal array.'}]}]",">>> import numpy as np
>>> x = np.arange(9).reshape((3,3))
>>> x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.diag(x)
array([0, 4, 8])
>>> np.diag(x, k=1)
array([1, 5])
>>> np.diag(x, k=-1)
array([3, 7])
>>> np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])"
numpy.diagflat,Create a two-dimensional array with the flattened input as a diagonal.,"[{'Parameters': [{'name': 'v', 'type': 'array_like', 'description': 'Input data, which is flattened and set as the k-thdiagonal of the output.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal to set; 0, the default, corresponds to the “main” diagonal,a positive (negative) k giving the number of the diagonal above(below) the main.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The 2-D output array.'}]}]",">>> import numpy as np
>>> np.diagflat([[1,2], [3,4]])
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])
>>> np.diagflat([1,2], 1)
array([[0, 1, 0],
       [0, 0, 2],
       [0, 0, 0]])"
numpy.tri,An array with ones at and below the given diagonal and zeros elsewhere.,"[{'Parameters': [{'name': 'N', 'type': 'int', 'description': 'Number of rows in the array.'}, {'name': 'M', 'type': 'int, optional', 'description': 'Number of columns in the array.By default, M is taken equal to N.'}, {'name': 'k', 'type': 'int, optional', 'description': 'The sub-diagonal at and below which the array is filled.k = 0 is the main diagonal, while k < 0 is below it,and k > 0 is above.  The default is 0.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data type of the returned array.  The default is float.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'tri', 'type': 'ndarray of shape (N, M)', 'description': 'Array with its lower triangle filled with ones and zero elsewhere;in other words T[i,j] == 1 for j <= i + k, 0 otherwise.'}]}]",">>> import numpy as np
>>> np.tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])
>>> np.tri(3, 5, -1)
array([[0.,  0.,  0.,  0.,  0.],
       [1.,  0.,  0.,  0.,  0.],
       [1.,  1.,  0.,  0.,  0.]])"
numpy.tril,Lower triangle of an array.,"[{'Parameters': [{'name': 'm', 'type': 'array_like, shape (…, M, N)', 'description': 'Input array.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal above which to zero elements.  k = 0 (the default) is themain diagonal, k < 0 is below it and k > 0 is above.'}]}, {'Returns': [{'name': 'tril', 'type': 'ndarray, shape (…, M, N)', 'description': 'Lower triangle of m, of same shape and data-type as m.'}]}]",">>> import numpy as np
>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])
>>> np.tril(np.arange(3*4*5).reshape(3, 4, 5))
array([[[ 0,  0,  0,  0,  0],
        [ 5,  6,  0,  0,  0],
        [10, 11, 12,  0,  0],
        [15, 16, 17, 18,  0]],
       [[20,  0,  0,  0,  0],
        [25, 26,  0,  0,  0],
        [30, 31, 32,  0,  0],
        [35, 36, 37, 38,  0]],
       [[40,  0,  0,  0,  0],
        [45, 46,  0,  0,  0],
        [50, 51, 52,  0,  0],
        [55, 56, 57, 58,  0]]])"
numpy.triu,Upper triangle of an array.,[],">>> import numpy as np
>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])
>>> np.triu(np.arange(3*4*5).reshape(3, 4, 5))
array([[[ 0,  1,  2,  3,  4],
        [ 0,  6,  7,  8,  9],
        [ 0,  0, 12, 13, 14],
        [ 0,  0,  0, 18, 19]],
       [[20, 21, 22, 23, 24],
        [ 0, 26, 27, 28, 29],
        [ 0,  0, 32, 33, 34],
        [ 0,  0,  0, 38, 39]],
       [[40, 41, 42, 43, 44],
        [ 0, 46, 47, 48, 49],
        [ 0,  0, 52, 53, 54],
        [ 0,  0,  0, 58, 59]]])"
numpy.vander,Generate a Vandermonde matrix.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': '1-D input array.'}, {'name': 'N', 'type': 'int, optional', 'description': 'Number of columns in the output.  If N is not specified, a squarearray is returned (N = len(x)).'}, {'name': 'increasing', 'type': 'bool, optional', 'description': 'Order of the powers of the columns.  If True, the powers increasefrom left to right, if False (the default) they are reversed.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Vandermonde matrix.  If increasing is False, the first column isx^(N-1), the second x^(N-2) and so forth. If increasing isTrue, the columns are x^0, x^1, ..., x^(N-1).'}]}]",">>> import numpy as np
>>> x = np.array([1, 2, 3, 5])
>>> N = 3
>>> np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])
>>> np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])
>>> x = np.array([1, 2, 3, 5])
>>> np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
>>> np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])
>>> np.linalg.det(np.vander(x))
48.000000000000043 # may vary
>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48"
numpy.bmat,"Build a matrix object from a string, nested sequence, or array.","[{'Parameters': [{'name': 'obj', 'type': 'str or array_like', 'description': 'Input data. If a string, variables in the current scope may bereferenced by name.'}, {'name': 'ldict', 'type': 'dict, optional', 'description': 'A dictionary that replaces local operands in current frame.Ignored if obj is not a string or gdict is None.'}, {'name': 'gdict', 'type': 'dict, optional', 'description': 'A dictionary that replaces global operands in current frame.Ignored if obj is not a string.'}]}, {'Returns': [{'name': 'out', 'type': 'matrix', 'description': 'Returns a matrix object, which is a specialized 2-D array.'}]}]",">>> import numpy as np
>>> A = np.asmatrix('1 1; 1 1')
>>> B = np.asmatrix('2 2; 2 2')
>>> C = np.asmatrix('3 4; 5 6')
>>> D = np.asmatrix('7 8; 9 0')
>>> np.bmat([[A, B], [C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
>>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
>>> np.bmat('A,B; C,D')
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])"
numpy.dot,"Dot product of two arrays. Specifically,","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'First argument.'}, {'name': 'b', 'type': 'array_like', 'description': 'Second argument.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Output argument. This must have the exact kind that would be returnedif it was not used. In particular, it must have the right type, must beC-contiguous, and its dtype must be the dtype that would be returnedfor dot(a,b). This is a performance feature. Therefore, if theseconditions are not met, an exception is raised, instead of attemptingto be flexible.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'Returns the dot product of a and b.  If a and b are bothscalars or both 1-D arrays then a scalar is returned; otherwisean array is returned.If out is given, then it is returned.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the last dimension of a is not the same size asthe second-to-last dimension of b.'}]}]",">>> import numpy as np
>>> np.dot(3, 4)
12
>>> np.dot([2j, 3j], [2j, 3j])
(-13+0j)
>>> a = [[1, 0], [0, 1]]
>>> b = [[4, 1], [2, 2]]
>>> np.dot(a, b)
array([[4, 1],
       [2, 2]])
>>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
>>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
>>> np.dot(a, b)[2,3,2,1,2,2]
499128
>>> sum(a[2,3,2,:] * b[1,2,:,2])
499128"
numpy.linalg.multi_dot,"Compute the dot product of two or more arrays in a single function call,
while automatically selecting the fastest evaluation order.","[{'Parameters': [{'name': 'arrays', 'type': 'sequence of array_like', 'description': 'If the first argument is 1-D it is treated as row vector.If the last argument is 1-D it is treated as column vector.The other arguments must be 2-D.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Output argument. This must have the exact kind that would be returnedif it was not used. In particular, it must have the right type, must beC-contiguous, and its dtype must be the dtype that would be returnedfor dot(a, b). This is a performance feature. Therefore, if theseconditions are not met, an exception is raised, instead of attemptingto be flexible.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'Returns the dot product of the supplied arrays.'}]}]",
numpy.vdot,Return the dot product of two vectors.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'If a is complex the complex conjugate is taken before calculationof the dot product.'}, {'name': 'b', 'type': 'array_like', 'description': 'Second argument to the dot product.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'Dot product of a and b.  Can be an int, float, orcomplex depending on the types of a and b.'}]}]",">>> import numpy as np
>>> a = np.array([1+2j,3+4j])
>>> b = np.array([5+6j,7+8j])
>>> np.vdot(a, b)
(70-8j)
>>> np.vdot(b, a)
(70+8j)
>>> a = np.array([[1, 4], [5, 6]])
>>> b = np.array([[4, 1], [2, 2]])
>>> np.vdot(a, b)
30
>>> np.vdot(b, a)
30
>>> 1*4 + 4*1 + 5*2 + 6*2
30"
numpy.vecdot,Vector dot product of two arrays.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays, scalars not allowed.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'A location into which the result is stored. If provided, it must havethe broadcasted shape of x1 and x2 with the last axis removed.If not provided or None, a freshly-allocated array is used.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The vector dot product of the inputs.This is a scalar only when both x1, x2 are 1-d vectors.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the last dimension of x1 is not the same size asthe last dimension of x2.If a scalar value is passed in.'}]}]",">>> import numpy as np
>>> v = np.array([[0., 5., 0.], [0., 0., 10.], [0., 6., 8.]])
>>> n = np.array([0., 0.6, 0.8])
>>> np.vecdot(v, n)
array([ 3.,  8., 10.])"
numpy.linalg.vecdot,Computes the vector dot product.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'First input array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Second input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which to compute the dot product. Default: -1.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'The vector dot product of the input.'}]}]",">>> v = np.array([[0., 5., 0.], [0., 0., 10.], [0., 6., 8.]])
>>> n = np.array([0., 0.6, 0.8])
>>> np.linalg.vecdot(v, n)
array([ 3.,  8., 10.])"
numpy.inner,Inner product of two arrays.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'If a and b are nonscalar, their last dimensions must match.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'If a and b are bothscalars or both 1-D arrays then a scalar is returned; otherwisean array is returned.out.shape = (*a.shape[:-1], *b.shape[:-1])'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If both a and b are nonscalar and their last dimensions havedifferent sizes.'}]}]",">>> import numpy as np
>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2
>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> c = np.inner(a, b)
>>> c.shape
(2, 3)
>>> c
array([[ 14,  38,  62],
       [ 86, 110, 134]])
>>> a = np.arange(2).reshape((1,1,2))
>>> b = np.arange(6).reshape((3,2))
>>> c = np.inner(a, b)
>>> c.shape
(1, 1, 3)
>>> c
array([[[1, 3, 5]]])
>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])"
numpy.outer,Compute the outer product of two vectors.,"[{'Parameters': [{'name': 'a', 'type': '(M,) array_like', 'description': 'First input vector.  Input is flattened ifnot already 1-dimensional.'}, {'name': 'b', 'type': '(N,) array_like', 'description': 'Second input vector.  Input is flattened ifnot already 1-dimensional.'}, {'name': 'out', 'type': '(M, N) ndarray, optional', 'description': 'A location where the result is stored'}]}, {'Returns': [{'name': 'out', 'type': '(M, N) ndarray', 'description': 'out[i, j] = a[i] * b[j]'}]}]",">>> import numpy as np
>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)"
numpy.matmul,Matrix product of two arrays.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays, scalars not allowed.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that matches the signature (n,k),(k,m)->(n,m). If notprovided or None, a freshly-allocated array is returned.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The matrix product of the inputs.This is a scalar only when both x1, x2 are 1-d vectors.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the last dimension of x1 is not the same size asthe second-to-last dimension of x2.If a scalar value is passed in.'}]}]",">>> a = np.ones([9, 5, 7, 4])
>>> c = np.ones([9, 5, 4, 3])
>>> np.dot(a, c).shape
(9, 5, 7, 9, 5, 3)
>>> np.matmul(a, c).shape
(9, 5, 7, 3)
>>> # n is 7, k is 4, m is 3
>>> import numpy as np
>>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([[4, 1],
...               [2, 2]])
>>> np.matmul(a, b)
array([[4, 1],
       [2, 2]])
>>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([1, 2])
>>> np.matmul(a, b)
array([1, 2])
>>> np.matmul(b, a)
array([1, 2])
>>> a = np.arange(2 * 2 * 4).reshape((2, 2, 4))
>>> b = np.arange(2 * 2 * 4).reshape((2, 4, 2))
>>> np.matmul(a,b).shape
(2, 2, 2)
>>> np.matmul(a, b)[0, 1, 1]
98
>>> sum(a[0, 1, :] * b[0 , :, 1])
98
>>> np.matmul([2j, 3j], [2j, 3j])
(-13+0j)
>>> np.matmul([1,2], 3)
Traceback (most recent call last):
...
ValueError: matmul: Input operand 1 does not have enough dimensions ...
>>> x1 = np.array([2j, 3j])
>>> x2 = np.array([2j, 3j])
>>> x1 @ x2
(-13+0j)"
numpy.linalg.matmul,Computes the matrix product.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'The first input array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The second input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The matrix product of the inputs.This is a scalar only when both x1, x2 are 1-d vectors.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the last dimension of x1 is not the same size asthe second-to-last dimension of x2.If a scalar value is passed in.'}]}]",">>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([[4, 1],
...               [2, 2]])
>>> np.linalg.matmul(a, b)
array([[4, 1],
       [2, 2]])
>>> a = np.array([[1, 0],
...               [0, 1]])
>>> b = np.array([1, 2])
>>> np.linalg.matmul(a, b)
array([1, 2])
>>> np.linalg.matmul(b, a)
array([1, 2])
>>> a = np.arange(2 * 2 * 4).reshape((2, 2, 4))
>>> b = np.arange(2 * 2 * 4).reshape((2, 4, 2))
>>> np.linalg.matmul(a,b).shape
(2, 2, 2)
>>> np.linalg.matmul(a, b)[0, 1, 1]
98
>>> sum(a[0, 1, :] * b[0 , :, 1])
98
>>> np.linalg.matmul([2j, 3j], [2j, 3j])
(-13+0j)
>>> np.linalg.matmul([1,2], 3)
Traceback (most recent call last):
...
ValueError: matmul: Input operand 1 does not have enough dimensions ..."
numpy.matvec,Matrix-vector dot product of two arrays.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays, scalars not allowed.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'A location into which the result is stored. If provided, it must havethe broadcasted shape of x1 and x2 with the summation axisremoved. If not provided or None, a freshly-allocated array is used.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The matrix-vector product of the inputs.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the last dimensions of x1 and x2 are not the same size.If a scalar value is passed in.'}]}]",">>> a = np.array([[0., 1., 0.],
...               [-1., 0., 0.],
...               [0., 0., 1.]])
>>> v = np.array([[1., 0., 0.],
...               [0., 1., 0.],
...               [0., 0., 1.],
...               [0., 6., 8.]])
>>> np.matvec(a, v)
array([[ 0., -1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.],
       [ 6.,  0.,  8.]])"
numpy.vecmat,Vector-matrix dot product of two arrays.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays, scalars not allowed.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'A location into which the result is stored. If provided, it must havethe broadcasted shape of x1 and x2 with the summation axisremoved. If not provided or None, a freshly-allocated array is used.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The vector-matrix product of the inputs.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the last dimensions of x1 and the one-but-last dimension ofx2 are not the same size.If a scalar value is passed in.'}]}]",">>> v = np.array([0., 4., 2.])
>>> a = np.array([[1., 0., 0.],
...               [0., 1., 0.],
...               [0., 0., 0.]])
>>> np.vecmat(v, a)
array([ 0.,  4., 0.])"
numpy.tensordot,Compute tensor dot product along specified axes.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'Tensors to “dot”.'}, {'name': 'axes', 'type': 'int or (2,) array_like', 'description': 'integer_likeIf an int N, sum over the last N axes of a and the first N axesof b in order. The sizes of the corresponding axes must match.(2,) array_likeOr, a list of axes to be summed over, first sequence applying to a,second to b. Both elements array_like must be of the same length.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'The tensor dot product of the input.'}]}]",">>> a_0 = np.array([[1, 2], [3, 4]])
>>> b_0 = np.array([[5, 6], [7, 8]])
>>> c_0 = np.tensordot(a_0, b_0, axes=0)
>>> c_0.shape
(2, 2, 2, 2)
>>> c_0
array([[[[ 5,  6],
         [ 7,  8]],
        [[10, 12],
         [14, 16]]],
       [[[15, 18],
         [21, 24]],
        [[20, 24],
         [28, 32]]]])
>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
>>> c.shape
(5, 2)
>>> c
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> d = np.zeros((5,2))
>>> for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         d[i,j] += a[k,n,i] * b[n,k,j]
>>> c == d
array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]])
>>> a = np.array(range(1, 9))
>>> a.shape = (2, 2, 2)
>>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
>>> A.shape = (2, 2)
>>> a; A
array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
array([['a', 'b'],
       ['c', 'd']], dtype=object)
>>> np.tensordot(a, A) # third argument default is 2 for double-contraction
array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)
>>> np.tensordot(a, A, 1)
array([[['acc', 'bdd'],
        ['aaacccc', 'bbbdddd']],
       [['aaaaacccccc', 'bbbbbdddddd'],
        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)
>>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
array([[[[['a', 'b'],
          ['c', 'd']],
          ...
>>> np.tensordot(a, A, (0, 1))
array([[['abbbbb', 'cddddd'],
        ['aabbbbbb', 'ccdddddd']],
       [['aaabbbbbbb', 'cccddddddd'],
        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)
>>> np.tensordot(a, A, (2, 1))
array([[['abb', 'cdd'],
        ['aaabbbb', 'cccdddd']],
       [['aaaaabbbbbb', 'cccccdddddd'],
        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)
>>> np.tensordot(a, A, ((0, 1), (0, 1)))
array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)
>>> np.tensordot(a, A, ((2, 1), (1, 0)))
array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)"
numpy.linalg.tensordot,Compute tensor dot product along specified axes.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'Tensors to “dot”.'}, {'name': 'axes', 'type': 'int or (2,) array_like', 'description': 'integer_likeIf an int N, sum over the last N axes of a and the first N axesof b in order. The sizes of the corresponding axes must match.(2,) array_likeOr, a list of axes to be summed over, first sequence applying to a,second to b. Both elements array_like must be of the same length.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'The tensor dot product of the input.'}]}]",">>> a_0 = np.array([[1, 2], [3, 4]])
>>> b_0 = np.array([[5, 6], [7, 8]])
>>> c_0 = np.tensordot(a_0, b_0, axes=0)
>>> c_0.shape
(2, 2, 2, 2)
>>> c_0
array([[[[ 5,  6],
         [ 7,  8]],
        [[10, 12],
         [14, 16]]],
       [[[15, 18],
         [21, 24]],
        [[20, 24],
         [28, 32]]]])
>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
>>> c.shape
(5, 2)
>>> c
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> d = np.zeros((5,2))
>>> for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         d[i,j] += a[k,n,i] * b[n,k,j]
>>> c == d
array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]])
>>> a = np.array(range(1, 9))
>>> a.shape = (2, 2, 2)
>>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
>>> A.shape = (2, 2)
>>> a; A
array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
array([['a', 'b'],
       ['c', 'd']], dtype=object)
>>> np.tensordot(a, A) # third argument default is 2 for double-contraction
array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)
>>> np.tensordot(a, A, 1)
array([[['acc', 'bdd'],
        ['aaacccc', 'bbbdddd']],
       [['aaaaacccccc', 'bbbbbdddddd'],
        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)
>>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
array([[[[['a', 'b'],
          ['c', 'd']],
          ...
>>> np.tensordot(a, A, (0, 1))
array([[['abbbbb', 'cddddd'],
        ['aabbbbbb', 'ccdddddd']],
       [['aaabbbbbbb', 'cccddddddd'],
        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)
>>> np.tensordot(a, A, (2, 1))
array([[['abb', 'cdd'],
        ['aaabbbb', 'cccdddd']],
       [['aaaaabbbbbb', 'cccccdddddd'],
        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)
>>> np.tensordot(a, A, ((0, 1), (0, 1)))
array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)
>>> np.tensordot(a, A, ((2, 1), (1, 0)))
array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)"
numpy.einsum,Evaluates the Einstein summation convention on the operands.,"[{'Parameters': [{'name': 'subscripts', 'type': 'str', 'description': 'Specifies the subscripts for summation as comma separated list ofsubscript labels. An implicit (classical Einstein summation)calculation is performed unless the explicit indicator ‘->’ isincluded as well as subscript labels of the precise output form.'}, {'name': 'operands', 'type': 'list of array_like', 'description': 'These are the arrays for the operation.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the calculation is done into this array.'}, {'name': 'dtype', 'type': '{data-type, None}, optional', 'description': 'If provided, forces the calculation to use the data type specified.Note that you may have to also give a more liberal castingparameter to allow the conversions. Default is None.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Controls the memory layout of the output. ‘C’ means it shouldbe C contiguous. ‘F’ means it should be Fortran contiguous,‘A’ means it should be ‘F’ if the inputs are all ‘F’, ‘C’ otherwise.‘K’ means it should be as close to the layout as the inputs asis possible, including arbitrarily permuted axes.Default is ‘K’.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur.  Setting this to‘unsafe’ is not recommended, as it can adversely affect accumulations.‘no’ means the data types should not be cast at all.‘equiv’ means only byte-order changes are allowed.‘safe’ means only casts which can preserve values are allowed.‘same_kind’ means only safe casts or casts within a kind,like float64 to float32, are allowed.‘unsafe’ means any data conversions may be done.Default is ‘safe’.'}, {'name': 'optimize', 'type': '{False, True, ‘greedy’, ‘optimal’}, optional', 'description': 'Controls if intermediate optimization should occur. No optimizationwill occur if False and True will default to the ‘greedy’ algorithm.Also accepts an explicit contraction list from the np.einsum_pathfunction. See np.einsum_path for more details. Defaults to False.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'The calculation based on the Einstein summation convention.'}]}]",">>> a = np.arange(25).reshape(5,5)
>>> b = np.arange(5)
>>> c = np.arange(6).reshape(2,3)
>>> np.einsum('ii', a)
60
>>> np.einsum(a, [0,0])
60
>>> np.trace(a)
60
>>> np.einsum('ii->i', a)
array([ 0,  6, 12, 18, 24])
>>> np.einsum(a, [0,0], [0])
array([ 0,  6, 12, 18, 24])
>>> np.diag(a)
array([ 0,  6, 12, 18, 24])
>>> np.einsum('ij->i', a)
array([ 10,  35,  60,  85, 110])
>>> np.einsum(a, [0,1], [0])
array([ 10,  35,  60,  85, 110])
>>> np.sum(a, axis=1)
array([ 10,  35,  60,  85, 110])
>>> np.einsum('...j->...', a)
array([ 10,  35,  60,  85, 110])
>>> np.einsum(a, [Ellipsis,1], [Ellipsis])
array([ 10,  35,  60,  85, 110])
>>> np.einsum('ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.einsum('ij->ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.einsum(c, [1,0])
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.transpose(c)
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.einsum('i,i', b, b)
30
>>> np.einsum(b, [0], b, [0])
30
>>> np.inner(b,b)
30
>>> np.einsum('ij,j', a, b)
array([ 30,  80, 130, 180, 230])
>>> np.einsum(a, [0,1], b, [1])
array([ 30,  80, 130, 180, 230])
>>> np.dot(a, b)
array([ 30,  80, 130, 180, 230])
>>> np.einsum('...j,j', a, b)
array([ 30,  80, 130, 180, 230])
>>> np.einsum('..., ...', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.einsum(',ij', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.einsum(3, [Ellipsis], c, [Ellipsis])
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.multiply(3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.einsum('i,j', np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
>>> np.einsum(np.arange(2)+1, [0], b, [1])
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
>>> np.outer(np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> np.einsum('ijk,jil->kl', a, b)
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> np.tensordot(a,b, axes=([1,0],[0,1]))
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> a = np.zeros((3, 3))
>>> np.einsum('ii->i', a)[:] = 1
>>> a
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
>>> a = np.arange(6).reshape((3,2))
>>> b = np.arange(12).reshape((4,3))
>>> np.einsum('ki,jk->ij', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
>>> np.einsum('ki,...k->i...', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
>>> np.einsum('k...,jk', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
>>> a = np.ones(64).reshape(2,4,8)
>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)
>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a,
...         optimize='optimal')
>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')
>>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a,
...     optimize='optimal')[0]
>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)"
numpy.einsum_path,"Evaluates the lowest cost contraction order for an einsum expression by
considering the creation of intermediate arrays.","[{'Parameters': [{'name': 'subscripts', 'type': 'str', 'description': 'Specifies the subscripts for summation.'}, {'name': '*operands', 'type': 'list of array_like', 'description': 'These are the arrays for the operation.'}, {'name': 'optimize', 'type': '{bool, list, tuple, ‘greedy’, ‘optimal’}', 'description': 'Choose the type of path. If a tuple is provided, the second argument isassumed to be the maximum intermediate size created. If only a singleargument is provided the largest input or output array size is usedas a maximum intermediate size.if a list is given that starts with einsum_path, uses this as thecontraction pathif False no optimization is takenif True defaults to the ‘greedy’ algorithm‘optimal’ An algorithm that combinatorially explores all possibleways of contracting the listed tensors and chooses the least costlypath. Scales exponentially with the number of terms in thecontraction.‘greedy’ An algorithm that chooses the best pair contractionat each step. Effectively, this algorithm searches the largest inner,Hadamard, and then outer products at each step. Scales cubically withthe number of terms in the contraction. Equivalent to the ‘optimal’path for most contractions.Default is ‘greedy’.'}]}, {'Returns': [{'name': 'path', 'type': 'list of tuples', 'description': 'A list representation of the einsum path.'}, {'name': 'string_repr', 'type': 'str', 'description': 'A printable representation of the einsum path.'}]}]",">>> np.random.seed(123)
>>> a = np.random.rand(2, 2)
>>> b = np.random.rand(2, 5)
>>> c = np.random.rand(5, 2)
>>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy')
>>> print(path_info[0])
['einsum_path', (1, 2), (0, 1)]
>>> print(path_info[1])
  Complete contraction:  ij,jk,kl->il # may vary
         Naive scaling:  4
     Optimized scaling:  3
      Naive FLOP count:  1.600e+02
  Optimized FLOP count:  5.600e+01
   Theoretical speedup:  2.857
  Largest intermediate:  4.000e+00 elements
-------------------------------------------------------------------------
scaling                  current                                remaining
-------------------------------------------------------------------------
   3                   kl,jk->jl                                ij,jl->il
   3                   jl,ij->il                                   il->il
>>> I = np.random.rand(10, 10, 10, 10)
>>> C = np.random.rand(10, 10)
>>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,
...                            optimize='greedy')
>>> print(path_info[0])
['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]
>>> print(path_info[1])
  Complete contraction:  ea,fb,abcd,gc,hd->efgh # may vary
         Naive scaling:  8
     Optimized scaling:  5
      Naive FLOP count:  8.000e+08
  Optimized FLOP count:  8.000e+05
   Theoretical speedup:  1000.000
  Largest intermediate:  1.000e+04 elements
--------------------------------------------------------------------------
scaling                  current                                remaining
--------------------------------------------------------------------------
   5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh
   5               bcde,fb->cdef                         gc,hd,cdef->efgh
   5               cdef,gc->defg                            hd,defg->efgh
   5               defg,hd->efgh                               efgh->efgh"
numpy.linalg.matrix_power,Raise a square matrix to the (integer) power n.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'Matrix to be “powered”.'}, {'name': 'n', 'type': 'int', 'description': 'The exponent can be any integer or long integer, positive,negative, or zero.'}]}, {'Returns': [{'name': 'a**n', 'type': '(…, M, M) ndarray or matrix object', 'description': 'The return value is the same shape and type as M;if the exponent is positive or zero then the type of theelements is the same as those of M. If the exponent isnegative the elements are floating-point.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'For matrices that are not square or that (for negative powers) cannotbe inverted numerically.'}]}]",">>> import numpy as np
>>> from numpy.linalg import matrix_power
>>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
>>> matrix_power(i, 3) # should = -i
array([[ 0, -1],
       [ 1,  0]])
>>> matrix_power(i, 0)
array([[1, 0],
       [0, 1]])
>>> matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
array([[ 0.,  1.],
       [-1.,  0.]])
>>> q = np.zeros((4, 4))
>>> q[0:2, 0:2] = -i
>>> q[2:4, 2:4] = i
>>> q # one of the three quaternion units not equal to 1
array([[ 0., -1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.],
       [ 0.,  0., -1.,  0.]])
>>> matrix_power(q, 2) # = -np.eye(4)
array([[-1.,  0.,  0.,  0.],
       [ 0., -1.,  0.,  0.],
       [ 0.,  0., -1.,  0.],
       [ 0.,  0.,  0., -1.]])"
numpy.kron,Kronecker product of two arrays.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': ''}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': ''}]}]",">>> import numpy as np
>>> np.kron([1,10,100], [5,6,7])
array([  5,   6,   7, ..., 500, 600, 700])
>>> np.kron([5,6,7], [1,10,100])
array([  5,  50, 500, ...,   7,  70, 700])
>>> np.kron(np.eye(2), np.ones((2,2)))
array([[1.,  1.,  0.,  0.],
       [1.,  1.,  0.,  0.],
       [0.,  0.,  1.,  1.],
       [0.,  0.,  1.,  1.]])
>>> a = np.arange(100).reshape((2,5,2,5))
>>> b = np.arange(24).reshape((2,3,4))
>>> c = np.kron(a,b)
>>> c.shape
(2, 10, 6, 20)
>>> I = (1,3,0,2)
>>> J = (0,2,1)
>>> J1 = (0,) + J             # extend to ndim=4
>>> S1 = (1,) + b.shape
>>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))
>>> c[K] == a[I]*b[J]
True"
numpy.linalg.cross,Returns the cross product of 3-element vectors.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'The first input array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The second input array. Must be compatible with x1 for allnon-compute axes. The size of the axis over which to computethe cross-product must be the same size as the respective axisin x1.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis (dimension) of x1 and x2 containing the vectors forwhich to compute the cross-product. Default: -1.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array containing the cross products.'}]}]",">>> x = np.array([1, 2, 3])
>>> y = np.array([4, 5, 6])
>>> np.linalg.cross(x, y)
array([-3,  6, -3])
>>> x = np.array([[1,2,3], [4,5,6]])
>>> y = np.array([[4,5,6], [1,2,3]])
>>> np.linalg.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])
>>> x = np.array([[1, 2], [3, 4], [5, 6]])
>>> y = np.array([[4, 5], [6, 1], [2, 3]])
>>> np.linalg.cross(x, y, axis=0)
array([[-24,  6],
       [ 18, 24],
       [-6,  -18]])"
numpy.linalg.cholesky,Cholesky decomposition.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'Hermitian (symmetric if all elements are real), positive-definiteinput matrix.'}, {'name': 'upper', 'type': 'bool', 'description': 'If True, the result must be the upper-triangular Cholesky factor.If False, the result must be the lower-triangular Cholesky factor.Default: False.'}]}, {'Returns': [{'name': 'L', 'type': '(…, M, M) array_like', 'description': 'Lower or upper-triangular Cholesky factor of a. Returns a matrixobject if a is a matrix object.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If the decomposition fails, for example, if a is notpositive-definite.'}]}]",">>> import numpy as np
>>> A = np.array([[1,-2j],[2j,5]])
>>> A
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
>>> L = np.linalg.cholesky(A)
>>> L
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
>>> np.dot(L, L.T.conj()) # verify that L * L.H = A
array([[1.+0.j, 0.-2.j],
       [0.+2.j, 5.+0.j]])
>>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
>>> np.linalg.cholesky(A) # an ndarray object is returned
array([[1.+0.j, 0.+0.j],
       [0.+2.j, 1.+0.j]])
>>> # But a matrix object is returned if A is a matrix object
>>> np.linalg.cholesky(np.matrix(A))
matrix([[ 1.+0.j,  0.+0.j],
        [ 0.+2.j,  1.+0.j]])
>>> # The upper-triangular Cholesky factor can also be obtained.
>>> np.linalg.cholesky(A, upper=True)
array([[1.-0.j, 0.-2.j],
       [0.-0.j, 1.-0.j]])"
numpy.linalg.outer,Compute the outer product of two vectors.,"[{'Parameters': [{'name': 'x1', 'type': '(M,) array_like', 'description': 'One-dimensional input array of size N.Must have a numeric data type.'}, {'name': 'x2', 'type': '(N,) array_like', 'description': 'One-dimensional input array of size M.Must have a numeric data type.'}]}, {'Returns': [{'name': 'out', 'type': '(M, N) ndarray', 'description': 'out[i, j] = a[i] * b[j]'}]}]",">>> rl = np.linalg.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.linalg.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.linalg.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)"
numpy.linalg.qr,Compute the qr factorization of a matrix.,"[{'Parameters': [{'name': 'a', 'type': 'array_like, shape (…, M, N)', 'description': 'An array-like object with the dimensionality of at least 2.'}, {'name': 'mode', 'type': '{‘reduced’, ‘complete’, ‘r’, ‘raw’}, optional, default: ‘reduced’', 'description': 'If K = min(M, N), then‘reduced’  : returns Q, R with dimensions (…, M, K), (…, K, N)‘complete’ : returns Q, R with dimensions (…, M, M), (…, M, N)‘r’        : returns R only with dimensions (…, K, N)‘raw’      : returns h, tau with dimensions (…, N, M), (…, K,)The options ‘reduced’, ‘complete, and ‘raw’ are new in numpy 1.8,see the notes for more information. The default is ‘reduced’, and tomaintain backward compatibility with earlier versions of numpy bothit and the old default ‘full’ can be omitted. Note that array hreturned in ‘raw’ mode is transposed for calling Fortran. The‘economic’ mode is deprecated.  The modes ‘full’ and ‘economic’ maybe passed using only the first letter for backwards compatibility,but all others must be spelled out. See the Notes for moreexplanation.'}]}, {'Returns': [{'name': 'When mode is ‘reduced’ or ‘complete’, the result will be a namedtuple with', 'type': None, 'description': ''}, {'name': 'the attributes Q and R.', 'type': None, 'description': ''}, {'name': 'Q', 'type': 'ndarray of float or complex, optional', 'description': 'A matrix with orthonormal columns. When mode = ‘complete’ theresult is an orthogonal/unitary matrix depending on whether or nota is real/complex. The determinant may be either +/- 1 in thatcase. In case the number of dimensions in the input array isgreater than 2 then a stack of the matrices with above propertiesis returned.'}, {'name': 'R', 'type': 'ndarray of float or complex, optional', 'description': 'The upper-triangular matrix or a stack of upper-triangularmatrices if the number of dimensions in the input array is greaterthan 2.'}, {'name': '(h, tau)', 'type': 'ndarrays of np.double or np.cdouble, optional', 'description': 'The array h contains the Householder reflectors that generate qalong with r. The tau array contains scaling factors for thereflectors. In the deprecated  ‘economic’ mode only h is returned.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If factoring fails.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng()
>>> a = rng.normal(size=(9, 6))
>>> Q, R = np.linalg.qr(a)
>>> np.allclose(a, np.dot(Q, R))  # a does equal QR
True
>>> R2 = np.linalg.qr(a, mode='r')
>>> np.allclose(R, R2)  # mode='r' returns the same R as mode='full'
True
>>> a = np.random.normal(size=(3, 2, 2)) # Stack of 2 x 2 matrices as input
>>> Q, R = np.linalg.qr(a)
>>> Q.shape
(3, 2, 2)
>>> R.shape
(3, 2, 2)
>>> np.allclose(a, np.matmul(Q, R))
True
>>> A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
>>> A
array([[0, 1],
       [1, 1],
       [1, 1],
       [2, 1]])
>>> b = np.array([1, 2, 2, 3])
>>> Q, R = np.linalg.qr(A)
>>> p = np.dot(Q.T, b)
>>> np.dot(np.linalg.inv(R), p)
array([  1.,   1.])"
numpy.linalg.svd,Singular Value Decomposition.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, N) array_like', 'description': 'A real or complex array with a.ndim >= 2.'}, {'name': 'full_matrices', 'type': 'bool, optional', 'description': 'If True (default), u and vh have the shapes (..., M, M) and(..., N, N), respectively.  Otherwise, the shapes are(..., M, K) and (..., K, N), respectively, whereK = min(M, N).'}, {'name': 'compute_uv', 'type': 'bool, optional', 'description': 'Whether or not to compute u and vh in addition to s.  Trueby default.'}, {'name': 'hermitian', 'type': 'bool, optional', 'description': 'If True, a is assumed to be Hermitian (symmetric if real-valued),enabling a more efficient method for finding singular values.Defaults to False.'}]}, {'Returns': [{'name': 'When compute_uv is True, the result is a namedtuple with the following', 'type': None, 'description': ''}, {'name': 'attribute names:', 'type': None, 'description': ''}, {'name': 'U', 'type': '{ (…, M, M), (…, M, K) } array', 'description': 'Unitary array(s). The first a.ndim - 2 dimensions have the samesize as those of the input a. The size of the last two dimensionsdepends on the value of full_matrices. Only returned whencompute_uv is True.'}, {'name': 'S', 'type': '(…, K) array', 'description': 'Vector(s) with the singular values, within each vector sorted indescending order. The first a.ndim - 2 dimensions have the samesize as those of the input a.'}, {'name': 'Vh', 'type': '{ (…, N, N), (…, K, N) } array', 'description': 'Unitary array(s). The first a.ndim - 2 dimensions have the samesize as those of the input a. The size of the last two dimensionsdepends on the value of full_matrices. Only returned whencompute_uv is True.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If SVD computation does not converge.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng()
>>> a = rng.normal(size=(9, 6)) + 1j*rng.normal(size=(9, 6))
>>> b = rng.normal(size=(2, 7, 8, 3)) + 1j*rng.normal(size=(2, 7, 8, 3))
>>> U, S, Vh = np.linalg.svd(a, full_matrices=True)
>>> U.shape, S.shape, Vh.shape
((9, 9), (6,), (6, 6))
>>> np.allclose(a, np.dot(U[:, :6] * S, Vh))
True
>>> smat = np.zeros((9, 6), dtype=complex)
>>> smat[:6, :6] = np.diag(S)
>>> np.allclose(a, np.dot(U, np.dot(smat, Vh)))
True
>>> U, S, Vh = np.linalg.svd(a, full_matrices=False)
>>> U.shape, S.shape, Vh.shape
((9, 6), (6,), (6, 6))
>>> np.allclose(a, np.dot(U * S, Vh))
True
>>> smat = np.diag(S)
>>> np.allclose(a, np.dot(U, np.dot(smat, Vh)))
True
>>> U, S, Vh = np.linalg.svd(b, full_matrices=True)
>>> U.shape, S.shape, Vh.shape
((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
>>> np.allclose(b, np.matmul(U[..., :3] * S[..., None, :], Vh))
True
>>> np.allclose(b, np.matmul(U[..., :3], S[..., None] * Vh))
True
>>> U, S, Vh = np.linalg.svd(b, full_matrices=False)
>>> U.shape, S.shape, Vh.shape
((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
>>> np.allclose(b, np.matmul(U * S[..., None, :], Vh))
True
>>> np.allclose(b, np.matmul(U, S[..., None] * Vh))
True"
numpy.linalg.svdvals,"Returns the singular values of a matrix (or a stack of matrices) x.
When x is a stack of matrices, the function will compute the singular
values for each matrix in the stack.","[{'Parameters': [{'name': 'x', 'type': '(…, M, N) array_like', 'description': 'Input array having shape (…, M, N) and whose last twodimensions form matrices on which to perform singular valuedecomposition. Should have a floating-point data type.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array with shape (…, K) that contains the vector(s)of singular values of length K, where K = min(M, N).'}]}]",">>> np.linalg.svdvals([[1, 2, 3, 4, 5],
...                    [1, 4, 9, 16, 25],
...                    [1, 8, 27, 64, 125]])
array([146.68862757,   5.57510612,   0.60393245])
>>> s = np.linalg.svdvals([[1, 2, 3],
...                        [2, 4, 6],
...                        [-1, 1, -1]]); s
array([8.38434191e+00, 1.64402274e+00, 2.31534378e-16])
>>> np.count_nonzero(s > 1e-10)  # Matrix of rank 2
2"
numpy.linalg.eig,Compute the eigenvalues and right eigenvectors of a square array.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array', 'description': 'Matrices for which the eigenvalues and right eigenvectors willbe computed'}]}, {'Returns': [{'name': 'A namedtuple with the following attributes:', 'type': None, 'description': ''}, {'name': 'eigenvalues', 'type': '(…, M) array', 'description': 'The eigenvalues, each repeated according to its multiplicity.The eigenvalues are not necessarily ordered. The resultingarray will be of complex type, unless the imaginary part iszero in which case it will be cast to a real type. When ais real the resulting eigenvalues will be real (0 imaginarypart) or occur in conjugate pairs'}, {'name': 'eigenvectors', 'type': '(…, M, M) array', 'description': 'The normalized (unit “length”) eigenvectors, such that thecolumn eigenvectors[:,i] is the eigenvector corresponding to theeigenvalue eigenvalues[i].'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If the eigenvalue computation does not converge.'}]}]",">>> import numpy as np
>>> from numpy import linalg as LA
>>> eigenvalues, eigenvectors = LA.eig(np.diag((1, 2, 3)))
>>> eigenvalues
array([1., 2., 3.])
>>> eigenvectors
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
>>> eigenvalues, eigenvectors = LA.eig(np.array([[1, -1], [1, 1]]))
>>> eigenvalues
array([1.+1.j, 1.-1.j])
>>> eigenvectors
array([[0.70710678+0.j        , 0.70710678-0.j        ],
       [0.        -0.70710678j, 0.        +0.70710678j]])
>>> a = np.array([[1, 1j], [-1j, 1]])
>>> eigenvalues, eigenvectors = LA.eig(a)
>>> eigenvalues
array([2.+0.j, 0.+0.j])
>>> eigenvectors
array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary
       [ 0.70710678+0.j        , -0.        +0.70710678j]])
>>> a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
>>> # Theor. eigenvalues are 1 +/- 1e-9
>>> eigenvalues, eigenvectors = LA.eig(a)
>>> eigenvalues
array([1., 1.])
>>> eigenvectors
array([[1., 0.],
       [0., 1.]])"
numpy.linalg.eigh,"Return the eigenvalues and eigenvectors of a complex Hermitian
(conjugate symmetric) or a real symmetric matrix.","[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array', 'description': 'Hermitian or real symmetric matrices whose eigenvalues andeigenvectors are to be computed.'}, {'name': 'UPLO', 'type': '{‘L’, ‘U’}, optional', 'description': 'Specifies whether the calculation is done with the lower triangularpart of a (‘L’, default) or the upper triangular part (‘U’).Irrespective of this value only the real parts of the diagonal willbe considered in the computation to preserve the notion of a Hermitianmatrix. It therefore follows that the imaginary part of the diagonalwill always be treated as zero.'}]}, {'Returns': [{'name': 'A namedtuple with the following attributes:', 'type': None, 'description': ''}, {'name': 'eigenvalues', 'type': '(…, M) ndarray', 'description': 'The eigenvalues in ascending order, each repeated according toits multiplicity.'}, {'name': 'eigenvectors', 'type': '{(…, M, M) ndarray, (…, M, M) matrix}', 'description': 'The column eigenvectors[:, i] is the normalized eigenvectorcorresponding to the eigenvalue eigenvalues[i].  Will return amatrix object if a is a matrix object.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If the eigenvalue computation does not converge.'}]}]",">>> import numpy as np
>>> from numpy import linalg as LA
>>> a = np.array([[1, -2j], [2j, 5]])
>>> a
array([[ 1.+0.j, -0.-2.j],
       [ 0.+2.j,  5.+0.j]])
>>> eigenvalues, eigenvectors = LA.eigh(a)
>>> eigenvalues
array([0.17157288, 5.82842712])
>>> eigenvectors
array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
       [ 0.        +0.38268343j,  0.        -0.92387953j]])
>>> (np.dot(a, eigenvectors[:, 0]) -
... eigenvalues[0] * eigenvectors[:, 0])  # verify 1st eigenval/vec pair
array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])
>>> (np.dot(a, eigenvectors[:, 1]) -
... eigenvalues[1] * eigenvectors[:, 1])  # verify 2nd eigenval/vec pair
array([0.+0.j, 0.+0.j])
>>> A = np.matrix(a) # what happens if input is a matrix object
>>> A
matrix([[ 1.+0.j, -0.-2.j],
        [ 0.+2.j,  5.+0.j]])
>>> eigenvalues, eigenvectors = LA.eigh(A)
>>> eigenvalues
array([0.17157288, 5.82842712])
>>> eigenvectors
matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
        [ 0.        +0.38268343j,  0.        -0.92387953j]])
>>> # demonstrate the treatment of the imaginary part of the diagonal
>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
>>> a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
>>> # with UPLO='L' this is numerically equivalent to using LA.eig() with:
>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
>>> b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
>>> wa, va = LA.eigh(a)
>>> wb, vb = LA.eig(b)
>>> wa
array([1., 6.])
>>> wb
array([6.+0.j, 1.+0.j])
>>> va
array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary
       [ 0.        +0.89442719j,  0.        -0.4472136j ]])
>>> vb
array([[ 0.89442719+0.j       , -0.        +0.4472136j],
       [-0.        +0.4472136j,  0.89442719+0.j       ]])"
numpy.linalg.eigvals,Compute the eigenvalues of a general matrix.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'A complex- or real-valued matrix whose eigenvalues will be computed.'}]}, {'Returns': [{'name': 'w', 'type': '(…, M,) ndarray', 'description': 'The eigenvalues, each repeated according to its multiplicity.They are not necessarily ordered, nor are they necessarilyreal for real matrices.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If the eigenvalue computation does not converge.'}]}]",">>> import numpy as np
>>> from numpy import linalg as LA
>>> x = np.random.random()
>>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
>>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
(1.0, 1.0, 0.0)
>>> D = np.diag((-1,1))
>>> LA.eigvals(D)
array([-1.,  1.])
>>> A = np.dot(Q, D)
>>> A = np.dot(A, Q.T)
>>> LA.eigvals(A)
array([ 1., -1.]) # random"
numpy.linalg.eigvalsh,Compute the eigenvalues of a complex Hermitian or real symmetric matrix.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'A complex- or real-valued matrix whose eigenvalues are to becomputed.'}, {'name': 'UPLO', 'type': '{‘L’, ‘U’}, optional', 'description': 'Specifies whether the calculation is done with the lower triangularpart of a (‘L’, default) or the upper triangular part (‘U’).Irrespective of this value only the real parts of the diagonal willbe considered in the computation to preserve the notion of a Hermitianmatrix. It therefore follows that the imaginary part of the diagonalwill always be treated as zero.'}]}, {'Returns': [{'name': 'w', 'type': '(…, M,) ndarray', 'description': 'The eigenvalues in ascending order, each repeated according toits multiplicity.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If the eigenvalue computation does not converge.'}]}]",">>> import numpy as np
>>> from numpy import linalg as LA
>>> a = np.array([[1, -2j], [2j, 5]])
>>> LA.eigvalsh(a)
array([ 0.17157288,  5.82842712]) # may vary
>>> # demonstrate the treatment of the imaginary part of the diagonal
>>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
>>> a
array([[5.+2.j, 9.-2.j],
       [0.+2.j, 2.-1.j]])
>>> # with UPLO='L' this is numerically equivalent to using LA.eigvals()
>>> # with:
>>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
>>> b
array([[5.+0.j, 0.-2.j],
       [0.+2.j, 2.+0.j]])
>>> wa = LA.eigvalsh(a)
>>> wb = LA.eigvals(b)
>>> wa; wb
array([1., 6.])
array([6.+0.j, 1.+0.j])"
numpy.linalg.norm,Matrix or vector norm.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.  If axis is None, x must be 1-D or 2-D, unless ordis None. If both axis and ord are None, the 2-norm ofx.ravel will be returned.'}, {'name': 'ord', 'type': '{int, float, inf, -inf, ‘fro’, ‘nuc’}, optional', 'description': 'Order of the norm (see table under Notes for what values aresupported for matrices and vectors respectively). inf means numpy’sinf object. The default is None.'}, {'name': 'axis', 'type': '{None, int, 2-tuple of ints}, optional.', 'description': 'If axis is an integer, it specifies the axis of x along which tocompute the vector norms.  If axis is a 2-tuple, it specifies theaxes that hold 2-D matrices, and the matrix norms of these matricesare computed.  If axis is None then either a vector norm (when xis 1-D) or a matrix norm (when x is 2-D) is returned. The defaultis None.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are normed over are left in theresult as dimensions with size one.  With this option the result willbroadcast correctly against the original x.'}]}, {'Returns': [{'name': 'n', 'type': 'float or ndarray', 'description': 'Norm of the matrix or vector(s).'}]}]",">>> import numpy as np
>>> from numpy import linalg as LA
>>> a = np.arange(9) - 4
>>> a
array([-4, -3, -2, ...,  2,  3,  4])
>>> b = a.reshape((3, 3))
>>> b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])
>>> LA.norm(a)
7.745966692414834
>>> LA.norm(b)
7.745966692414834
>>> LA.norm(b, 'fro')
7.745966692414834
>>> LA.norm(a, np.inf)
4.0
>>> LA.norm(b, np.inf)
9.0
>>> LA.norm(a, -np.inf)
0.0
>>> LA.norm(b, -np.inf)
2.0
>>> LA.norm(a, 1)
20.0
>>> LA.norm(b, 1)
7.0
>>> LA.norm(a, -1)
-4.6566128774142013e-010
>>> LA.norm(b, -1)
6.0
>>> LA.norm(a, 2)
7.745966692414834
>>> LA.norm(b, 2)
7.3484692283495345
>>> LA.norm(a, -2)
0.0
>>> LA.norm(b, -2)
1.8570331885190563e-016 # may vary
>>> LA.norm(a, 3)
5.8480354764257312 # may vary
>>> LA.norm(a, -3)
0.0
>>> c = np.array([[ 1, 2, 3],
...               [-1, 1, 4]])
>>> LA.norm(c, axis=0)
array([ 1.41421356,  2.23606798,  5.        ])
>>> LA.norm(c, axis=1)
array([ 3.74165739,  4.24264069])
>>> LA.norm(c, ord=1, axis=1)
array([ 6.,  6.])
>>> m = np.arange(8).reshape(2,2,2)
>>> LA.norm(m, axis=(1,2))
array([  3.74165739,  11.22497216])
>>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
(3.7416573867739413, 11.224972160321824)"
numpy.linalg.matrix_norm,Computes the matrix norm of a matrix (or a stack of matrices) x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array having shape (…, M, N) and whose two innermostdimensions form MxN matrices.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are normed over are left inthe result as dimensions with size one. Default: False.'}, {'name': 'ord', 'type': '{1, -1, 2, -2, inf, -inf, ‘fro’, ‘nuc’}, optional', 'description': 'The order of the norm. For details see the table under Notesin numpy.linalg.norm.'}]}]",">>> from numpy import linalg as LA
>>> a = np.arange(9) - 4
>>> a
array([-4, -3, -2, ...,  2,  3,  4])
>>> b = a.reshape((3, 3))
>>> b
array([[-4, -3, -2],
       [-1,  0,  1],
       [ 2,  3,  4]])
>>> LA.matrix_norm(b)
7.745966692414834
>>> LA.matrix_norm(b, ord='fro')
7.745966692414834
>>> LA.matrix_norm(b, ord=np.inf)
9.0
>>> LA.matrix_norm(b, ord=-np.inf)
2.0
>>> LA.matrix_norm(b, ord=1)
7.0
>>> LA.matrix_norm(b, ord=-1)
6.0
>>> LA.matrix_norm(b, ord=2)
7.3484692283495345
>>> LA.matrix_norm(b, ord=-2)
1.8570331885190563e-016 # may vary"
numpy.linalg.vector_norm,Computes the vector norm of a vector (or batch of vectors) x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': '{None, int, 2-tuple of ints}, optional', 'description': 'If an integer, axis specifies the axis (dimension) along whichto compute vector norms. If an n-tuple, axis specifies the axes(dimensions) along which to compute batched vector norms. If None,the vector norm must be computed over all array values (i.e.,equivalent to computing the vector norm of a flattened array).Default: None.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are normed over are left inthe result as dimensions with size one. Default: False.'}, {'name': 'ord', 'type': '{int, float, inf, -inf}, optional', 'description': 'The order of the norm. For details see the table under Notesin numpy.linalg.norm.'}]}]",">>> from numpy import linalg as LA
>>> a = np.arange(9) + 1
>>> a
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b = a.reshape((3, 3))
>>> b
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> LA.vector_norm(b)
16.881943016134134
>>> LA.vector_norm(b, ord=np.inf)
9.0
>>> LA.vector_norm(b, ord=-np.inf)
1.0
>>> LA.vector_norm(b, ord=0)
9.0
>>> LA.vector_norm(b, ord=1)
45.0
>>> LA.vector_norm(b, ord=-1)
0.3534857623790153
>>> LA.vector_norm(b, ord=2)
16.881943016134134
>>> LA.vector_norm(b, ord=-2)
0.8058837395885292"
numpy.linalg.cond,Compute the condition number of a matrix.,"[{'Parameters': [{'name': 'x', 'type': '(…, M, N) array_like', 'description': 'The matrix whose condition number is sought.'}, {'name': 'p', 'type': '{None, 1, -1, 2, -2, inf, -inf, ‘fro’}, optional', 'description': 'Order of the norm used in the condition number computation:pnorm for matricesNone2-norm, computed directly using the SVD‘fro’Frobenius norminfmax(sum(abs(x), axis=1))-infmin(sum(abs(x), axis=1))1max(sum(abs(x), axis=0))-1min(sum(abs(x), axis=0))22-norm (largest sing. value)-2smallest singular valueinf means the numpy.inf object, and the Frobenius norm isthe root-of-sum-of-squares norm.'}]}, {'Returns': [{'name': 'c', 'type': '{float, inf}', 'description': 'The condition number of the matrix. May be infinite.'}]}]",">>> import numpy as np
>>> from numpy import linalg as LA
>>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
>>> a
array([[ 1,  0, -1],
       [ 0,  1,  0],
       [ 1,  0,  1]])
>>> LA.cond(a)
1.4142135623730951
>>> LA.cond(a, 'fro')
3.1622776601683795
>>> LA.cond(a, np.inf)
2.0
>>> LA.cond(a, -np.inf)
1.0
>>> LA.cond(a, 1)
2.0
>>> LA.cond(a, -1)
1.0
>>> LA.cond(a, 2)
1.4142135623730951
>>> LA.cond(a, -2)
0.70710678118654746 # may vary
>>> (min(LA.svd(a, compute_uv=False)) *
... min(LA.svd(LA.inv(a), compute_uv=False)))
0.70710678118654746 # may vary"
numpy.linalg.det,Compute the determinant of an array.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'Input array to compute determinants for.'}]}, {'Returns': [{'name': 'det', 'type': '(…) array_like', 'description': 'Determinant of a.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> np.linalg.det(a)
-2.0 # may vary
>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
>>> a.shape
(3, 2, 2)
>>> np.linalg.det(a)
array([-2., -3., -8.])"
numpy.linalg.matrix_rank,Return matrix rank of array using SVD method,"[{'Parameters': [{'name': 'A', 'type': '{(M,), (…, M, N)} array_like', 'description': 'Input vector or stack of matrices.'}, {'name': 'tol', 'type': '(…) array_like, float, optional', 'description': 'Threshold below which SVD values are considered zero. If tol isNone, and S is an array with singular values for M, andeps is the epsilon value for datatype of S, then tol isset to S.max() * max(M, N) * eps.'}, {'name': 'hermitian', 'type': 'bool, optional', 'description': 'If True, A is assumed to be Hermitian (symmetric if real-valued),enabling a more efficient method for finding singular values.Defaults to False.'}, {'name': 'rtol', 'type': '(…) array_like, float, optional', 'description': 'Parameter for the relative tolerance component. Only tol orrtol can be set at a time. Defaults to max(M, N) * eps.New in version 2.0.0.'}]}, {'Returns': [{'name': 'rank', 'type': '(…) array_like', 'description': 'Rank of A.'}]}]",">>> import numpy as np
>>> from numpy.linalg import matrix_rank
>>> matrix_rank(np.eye(4)) # Full rank matrix
4
>>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
>>> matrix_rank(I)
3
>>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
1
>>> matrix_rank(np.zeros((4,)))
0"
numpy.linalg.slogdet,Compute the sign and (natural) logarithm of the determinant of an array.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'Input array, has to be a square 2-D array.'}]}, {'Returns': [{'name': 'A namedtuple with the following attributes:', 'type': None, 'description': ''}, {'name': 'sign', 'type': '(…) array_like', 'description': 'A number representing the sign of the determinant. For a real matrix,this is 1, 0, or -1. For a complex matrix, this is a complex numberwith absolute value 1 (i.e., it is on the unit circle), or else 0.'}, {'name': 'logabsdet', 'type': '(…) array_like', 'description': 'The natural log of the absolute value of the determinant.'}, {'name': 'If the determinant is zero, then sign will be 0 and logabsdet', 'type': None, 'description': ''}, {'name': 'will be -inf. In all cases, the determinant is equal to', 'type': None, 'description': ''}, {'name': 'sign * np.exp(logabsdet).', 'type': None, 'description': ''}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> (sign, logabsdet) = np.linalg.slogdet(a)
>>> (sign, logabsdet)
(-1, 0.69314718055994529) # may vary
>>> sign * np.exp(logabsdet)
-2.0
>>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
>>> a.shape
(3, 2, 2)
>>> sign, logabsdet = np.linalg.slogdet(a)
>>> (sign, logabsdet)
(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
>>> sign * np.exp(logabsdet)
array([-2., -3., -8.])
>>> np.linalg.det(np.eye(500) * 0.1)
0.0
>>> np.linalg.slogdet(np.eye(500) * 0.1)
(1, -1151.2925464970228)"
numpy.trace,Return the sum along diagonals of the array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, from which the diagonals are taken.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Offset of the diagonal from the main diagonal. Can be both positiveand negative. Defaults to 0.'}, {'name': 'axis1, axis2', 'type': 'int, optional', 'description': 'Axes to be used as the first and second axis of the 2-D sub-arraysfrom which the diagonals should be taken. Defaults are the first twoaxes of a.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Determines the data-type of the returned array and of the accumulatorwhere the elements are summed. If dtype has the value None and a isof integer type of precision less than the default integerprecision, then the default integer precision is used. Otherwise,the precision is the same as that of a.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Array into which the output is placed. Its type is preserved andit must be of the right shape to hold the output.'}]}, {'Returns': [{'name': 'sum_along_diagonals', 'type': 'ndarray', 'description': 'If a is 2-D, the sum along the diagonal is returned.  If a haslarger dimensions, then an array of sums along diagonals is returned.'}]}]",">>> import numpy as np
>>> np.trace(np.eye(3))
3.0
>>> a = np.arange(8).reshape((2,2,2))
>>> np.trace(a)
array([6, 8])
>>> a = np.arange(24).reshape((2,2,2,3))
>>> np.trace(a).shape
(2, 3)"
numpy.linalg.trace,"Returns the sum along the specified diagonals of a matrix
(or a stack of matrices) x.","[{'Parameters': [{'name': 'x', 'type': '(…,M,N) array_like', 'description': 'Input array having shape (…, M, N) and whose innermost twodimensions form MxN matrices.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Offset specifying the off-diagonal relative to the main diagonal,where:* offset = 0: the main diagonal.* offset > 0: off-diagonal above the main diagonal.* offset < 0: off-diagonal below the main diagonal.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data type of the returned array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array containing the traces and whose shape is determined byremoving the last two dimensions and storing the traces in the lastarray dimension. For example, if x has rank k and shape:(I, J, K, …, L, M, N), then an output array has rank k-2 and shape:(I, J, K, …, L) where:out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])The returned array must have a data type as described by the dtypeparameter above.'}]}]",">>> np.linalg.trace(np.eye(3))
3.0
>>> a = np.arange(8).reshape((2, 2, 2))
>>> np.linalg.trace(a)
array([3, 11])
>>> a = np.arange(24).reshape((3, 2, 2, 2))
>>> np.linalg.trace(a).shape
(3, 2)
>>> a = np.arange(9).reshape((3, 3)); a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.linalg.trace(a, offset=1)  # First superdiagonal
6
>>> np.linalg.trace(a, offset=2)  # Second superdiagonal
2
>>> np.linalg.trace(a, offset=-1)  # First subdiagonal
10
>>> np.linalg.trace(a, offset=-2)  # Second subdiagonal
6"
numpy.linalg.solve,"Solve a linear matrix equation, or system of linear scalar equations.","[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'Coefficient matrix.'}, {'name': 'b', 'type': '{(M,), (…, M, K)}, array_like', 'description': 'Ordinate or “dependent variable” values.'}]}, {'Returns': [{'name': 'x', 'type': '{(…, M,), (…, M, K)} ndarray', 'description': 'Solution to the system a x = b.  Returned shape is (…, M) if b isshape (M,) and (…, M, K) if b is (…, M, K), where the “…” part isbroadcasted between a and b.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If a is singular or not square.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 5]])
>>> b = np.array([1, 2])
>>> x = np.linalg.solve(a, b)
>>> x
array([-1.,  1.])
>>> np.allclose(np.dot(a, x), b)
True"
numpy.linalg.tensorsolve,Solve the tensor equation a x = b for x.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Coefficient tensor, of shape b.shape + Q. Q, a tuple, equalsthe shape of that sub-tensor of a consisting of the appropriatenumber of its rightmost indices, and must be such thatprod(Q) == prod(b.shape) (in which sense a is said to be‘square’).'}, {'name': 'b', 'type': 'array_like', 'description': 'Right-hand tensor, which can be of any shape.'}, {'name': 'axes', 'type': 'tuple of ints, optional', 'description': 'Axes in a to reorder to the right, before inversion.If None (default), no reordering is done.'}]}, {'Returns': [{'name': 'x', 'type': 'ndarray, shape Q', 'description': ''}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If a is singular or not ‘square’ (in the above sense).'}]}]",">>> import numpy as np
>>> a = np.eye(2*3*4)
>>> a.shape = (2*3, 4, 2, 3, 4)
>>> rng = np.random.default_rng()
>>> b = rng.normal(size=(2*3, 4))
>>> x = np.linalg.tensorsolve(a, b)
>>> x.shape
(2, 3, 4)
>>> np.allclose(np.tensordot(a, x, axes=3), b)
True"
numpy.linalg.lstsq,Return the least-squares solution to a linear matrix equation.,"[{'Parameters': [{'name': 'a', 'type': '(M, N) array_like', 'description': '“Coefficient” matrix.'}, {'name': 'b', 'type': '{(M,), (M, K)} array_like', 'description': 'Ordinate or “dependent variable” values. If b is two-dimensional,the least-squares solution is calculated for each of the K columnsof b.'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Cut-off ratio for small singular values of a.For the purposes of rank determination, singular values are treatedas zero if they are smaller than rcond times the largest singularvalue of a.The default uses the machine precision times max(M, N).  Passing-1 will use machine precision.Changed in version 2.0: Previously, the default was -1, but a warning was given thatthis would change.'}]}, {'Returns': [{'name': 'x', 'type': '{(N,), (N, K)} ndarray', 'description': 'Least-squares solution. If b is two-dimensional,the solutions are in the K columns of x.'}, {'name': 'residuals', 'type': '{(1,), (K,), (0,)} ndarray', 'description': 'Sums of squared residuals: Squared Euclidean 2-norm for each column inb - a @ x.If the rank of a is < N or M <= N, this is an empty array.If b is 1-dimensional, this is a (1,) shape array.Otherwise the shape is (K,).'}, {'name': 'rank', 'type': 'int', 'description': 'Rank of matrix a.'}, {'name': 's', 'type': '(min(M, N),) ndarray', 'description': 'Singular values of a.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If computation does not converge.'}]}]",">>> import numpy as np
>>> x = np.array([0, 1, 2, 3])
>>> y = np.array([-1, 0.2, 0.9, 2.1])
>>> A = np.vstack([x, np.ones(len(x))]).T
>>> A
array([[ 0.,  1.],
       [ 1.,  1.],
       [ 2.,  1.],
       [ 3.,  1.]])
>>> m, c = np.linalg.lstsq(A, y)[0]
>>> m, c
(1.0 -0.95) # may vary
>>> import matplotlib.pyplot as plt
>>> _ = plt.plot(x, y, 'o', label='Original data', markersize=10)
>>> _ = plt.plot(x, m*x + c, 'r', label='Fitted line')
>>> _ = plt.legend()
>>> plt.show()"
numpy.linalg.inv,Compute the inverse of a matrix.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, M) array_like', 'description': 'Matrix to be inverted.'}]}, {'Returns': [{'name': 'ainv', 'type': '(…, M, M) ndarray or matrix', 'description': 'Inverse of the matrix a.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If a is not square or inversion fails.'}]}]",">>> import numpy as np
>>> from numpy.linalg import inv
>>> a = np.array([[1., 2.], [3., 4.]])
>>> ainv = inv(a)
>>> np.allclose(a @ ainv, np.eye(2))
True
>>> np.allclose(ainv @ a, np.eye(2))
True
>>> ainv = inv(np.matrix(a))
>>> ainv
matrix([[-2. ,  1. ],
        [ 1.5, -0.5]])
>>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
>>> inv(a)
array([[[-2.  ,  1.  ],
        [ 1.5 , -0.5 ]],
       [[-1.25,  0.75],
        [ 0.75, -0.25]]])
>>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
>>> inv(a)  # No errors raised
array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
   [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
   [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
>>> a @ inv(a)
array([[ 0.   , -0.5  ,  0.   ],  # may vary
       [-0.5  ,  0.625,  0.25 ],
       [ 0.   ,  0.   ,  1.   ]])
>>> from numpy.linalg import cond
>>> cond(a)
np.float64(8.659885634118668e+17)  # may vary
>>> from numpy.linalg import svd
>>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
>>> sigma.max()/sigma.min()
8.659885634118668e+17  # may vary"
numpy.linalg.pinv,Compute the (Moore-Penrose) pseudo-inverse of a matrix.,"[{'Parameters': [{'name': 'a', 'type': '(…, M, N) array_like', 'description': 'Matrix or stack of matrices to be pseudo-inverted.'}, {'name': 'rcond', 'type': '(…) array_like of float, optional', 'description': 'Cutoff for small singular values.Singular values less than or equal torcond * largest_singular_value are set to zero.Broadcasts against the stack of matrices. Default: 1e-15.'}, {'name': 'hermitian', 'type': 'bool, optional', 'description': 'If True, a is assumed to be Hermitian (symmetric if real-valued),enabling a more efficient method for finding singular values.Defaults to False.'}, {'name': 'rtol', 'type': '(…) array_like of float, optional', 'description': 'Same as rcond, but it’s an Array API compatible parameter name.Only rcond or rtol can be set at a time. If none of them areprovided then NumPy’s 1e-15 default is used. If rtol=Noneis passed then the API standard default is used.New in version 2.0.0.'}]}, {'Returns': [{'name': 'B', 'type': '(…, N, M) ndarray', 'description': 'The pseudo-inverse of a. If a is a matrix instance, then sois B.'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If the SVD computation does not converge.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng()
>>> a = rng.normal(size=(9, 6))
>>> B = np.linalg.pinv(a)
>>> np.allclose(a, np.dot(a, np.dot(B, a)))
True
>>> np.allclose(B, np.dot(B, np.dot(a, B)))
True"
numpy.linalg.tensorinv,Compute the ‘inverse’ of an N-dimensional array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Tensor to ‘invert’. Its shape must be ‘square’, i. e.,prod(a.shape[:ind]) == prod(a.shape[ind:]).'}, {'name': 'ind', 'type': 'int, optional', 'description': 'Number of first indices that are involved in the inverse sum.Must be a positive integer, default is 2.'}]}, {'Returns': [{'name': 'b', 'type': 'ndarray', 'description': 'a’s tensordot inverse, shape a.shape[ind:] + a.shape[:ind].'}]}, {'Raises': [{'name': 'LinAlgError', 'type': None, 'description': 'If a is singular or not ‘square’ (in the above sense).'}]}]",">>> import numpy as np
>>> a = np.eye(4*6)
>>> a.shape = (4, 6, 8, 3)
>>> ainv = np.linalg.tensorinv(a, ind=2)
>>> ainv.shape
(8, 3, 4, 6)
>>> rng = np.random.default_rng()
>>> b = rng.normal(size=(4, 6))
>>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
True
>>> a = np.eye(4*6)
>>> a.shape = (24, 8, 3)
>>> ainv = np.linalg.tensorinv(a, ind=1)
>>> ainv.shape
(8, 3, 24)
>>> rng = np.random.default_rng()
>>> b = rng.normal(size=24)
>>> np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
True"
numpy.diagonal,Return specified diagonals.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array from which the diagonals are taken.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Offset of the diagonal from the main diagonal.  Can be positive ornegative.  Defaults to main diagonal (0).'}, {'name': 'axis1', 'type': 'int, optional', 'description': 'Axis to be used as the first axis of the 2-D sub-arrays from whichthe diagonals should be taken.  Defaults to first axis (0).'}, {'name': 'axis2', 'type': 'int, optional', 'description': 'Axis to be used as the second axis of the 2-D sub-arrays fromwhich the diagonals should be taken. Defaults to second axis (1).'}]}, {'Returns': [{'name': 'array_of_diagonals', 'type': 'ndarray', 'description': 'If a is 2-D, then a 1-D array containing the diagonal and of thesame type as a is returned unless a is a matrix, in which casea 1-D array rather than a (2-D) matrix is returned in order tomaintain backward compatibility.If a.ndim > 2, then the dimensions specified by axis1 and axis2are removed, and a new axis inserted at the end corresponding to thediagonal.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the dimension of a is less than 2.'}]}]",">>> import numpy as np
>>> a = np.arange(4).reshape(2,2)
>>> a
array([[0, 1],
       [2, 3]])
>>> a.diagonal()
array([0, 3])
>>> a.diagonal(1)
array([1])
>>> a = np.arange(8).reshape(2,2,2); a
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> a.diagonal(0,  # Main diagonals of two arrays created by skipping
...            0,  # across the outer(left)-most axis last and
...            1)  # the ""middle"" (row) axis first.
array([[0, 6],
       [1, 7]])
>>> a[:,:,0]  # main diagonal is [0 6]
array([[0, 2],
       [4, 6]])
>>> a[:,:,1]  # main diagonal is [1 7]
array([[1, 3],
       [5, 7]])
>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.fliplr(a).diagonal()  # Horizontal flip
array([2, 4, 6])
>>> np.flipud(a).diagonal()  # Vertical flip
array([6, 4, 2])"
numpy.linalg.diagonal,Returns specified diagonals of a matrix (or a stack of matrices) x.,"[{'Parameters': [{'name': 'x', 'type': '(…,M,N) array_like', 'description': 'Input array having shape (…, M, N) and whose innermost twodimensions form MxN matrices.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Offset specifying the off-diagonal relative to the main diagonal,where:* offset = 0: the main diagonal.* offset > 0: off-diagonal above the main diagonal.* offset < 0: off-diagonal below the main diagonal.'}]}, {'Returns': [{'name': 'out', 'type': '(…,min(N,M)) ndarray', 'description': 'An array containing the diagonals and whose shape is determined byremoving the last two dimensions and appending a dimension equal tothe size of the resulting diagonals. The returned array must havethe same data type as x.'}]}]",">>> a = np.arange(4).reshape(2, 2); a
array([[0, 1],
       [2, 3]])
>>> np.linalg.diagonal(a)
array([0, 3])
>>> a = np.arange(8).reshape(2, 2, 2); a
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> np.linalg.diagonal(a)
array([[0, 3],
       [4, 7]])
>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.linalg.diagonal(a, offset=1)  # First superdiagonal
array([1, 5])
>>> np.linalg.diagonal(a, offset=2)  # Second superdiagonal
array([2])
>>> np.linalg.diagonal(a, offset=-1)  # First subdiagonal
array([3, 7])
>>> np.linalg.diagonal(a, offset=-2)  # Second subdiagonal
array([6])
>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.linalg.diagonal(np.fliplr(a))  # Horizontal flip
array([2, 4, 6])
>>> np.linalg.diagonal(np.flipud(a))  # Vertical flip
array([6, 4, 2])"
numpy.linalg.matrix_transpose,Transposes a matrix (or a stack of matrices) x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array having shape (…, M, N) and whose two innermostdimensions form MxN matrices.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array containing the transpose for each matrix and having shape(…, N, M).'}]}]",">>> import numpy as np
>>> np.matrix_transpose([[1, 2], [3, 4]])
array([[1, 3],
       [2, 4]])
>>> np.matrix_transpose([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
array([[[1, 3],
        [2, 4]],
       [[5, 7],
        [6, 8]]])"
numpy.linalg.LinAlgError,Generic Python-exception-derived object raised by linalg functions.,"[{'Parameters': [{'name': 'None', 'type': None, 'description': ''}]}]",">>> from numpy import linalg as LA
>>> LA.inv(np.zeros((2,2)))
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
  File ""...linalg.py"", line 350,
    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))
  File ""...linalg.py"", line 249,
    in solve
    raise LinAlgError('Singular matrix')
numpy.linalg.LinAlgError: Singular matrix"
numpy.testing.assert_allclose,"Raises an AssertionError if two objects are not equal up to desired
tolerance.","[{'Parameters': [{'name': 'actual', 'type': 'array_like', 'description': 'Array obtained.'}, {'name': 'desired', 'type': 'array_like', 'description': 'Array desired.'}, {'name': 'rtol', 'type': 'float, optional', 'description': 'Relative tolerance.'}, {'name': 'atol', 'type': 'float, optional', 'description': 'Absolute tolerance.'}, {'name': 'equal_nan', 'type': 'bool, optional.', 'description': 'If True, NaNs will compare equal.'}, {'name': 'err_msg', 'type': 'str, optional', 'description': 'The error message to be printed in case of failure.'}, {'name': 'verbose', 'type': 'bool, optional', 'description': 'If True, the conflicting values are appended to the error message.'}, {'name': 'strict', 'type': 'bool, optional', 'description': 'If True, raise an AssertionError when either the shape or the datatype of the arguments does not match. The special handling of scalarsmentioned in the Notes section is disabled.New in version 2.0.0.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If actual and desired are not equal up to specified precision.'}]}]",">>> x = [1e-5, 1e-3, 1e-1]
>>> y = np.arccos(np.cos(x))
>>> np.testing.assert_allclose(x, y, rtol=1e-5, atol=0)
>>> x = np.arange(3) * np.pi
>>> np.testing.assert_allclose(np.sin(x), 0, atol=1e-15)
>>> np.testing.assert_allclose(np.sin(x), 0, atol=1e-15, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Not equal to tolerance rtol=1e-07, atol=1e-15

(shapes (3,), () mismatch)
 ACTUAL: array([ 0.000000e+00,  1.224647e-16, -2.449294e-16])
 DESIRED: array(0)
>>> y = np.zeros(3, dtype=np.float32)
>>> np.testing.assert_allclose(np.sin(x), y, atol=1e-15, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Not equal to tolerance rtol=1e-07, atol=1e-15

(dtypes float64, float32 mismatch)
 ACTUAL: array([ 0.000000e+00,  1.224647e-16, -2.449294e-16])
 DESIRED: array([0., 0., 0.], dtype=float32)"
numpy.testing.assert_array_almost_equal_nulp,Compare two arrays relatively to their spacing.,"[{'Parameters': [{'name': 'x, y', 'type': 'array_like', 'description': 'Input arrays.'}, {'name': 'nulp', 'type': 'int, optional', 'description': 'The maximum number of unit in the last place for tolerance (see Notes).Default is 1.'}]}, {'Returns': [{'name': 'None', 'type': None, 'description': ''}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If the spacing between x and y for one or more elements is largerthan nulp.'}]}]",">>> x = np.array([1., 1e-10, 1e-20])
>>> eps = np.finfo(x.dtype).eps
>>> np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x)
>>> np.testing.assert_array_almost_equal_nulp(x, x*eps + x)
Traceback (most recent call last):
  ...
AssertionError: Arrays are not equal to 1 ULP (max is 2)"
numpy.testing.assert_array_max_ulp,Check that all items of arrays differ in at most N Units in the Last Place.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'Input arrays to be compared.'}, {'name': 'maxulp', 'type': 'int, optional', 'description': 'The maximum number of units in the last place that elements of a andb can differ. Default is 1.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data-type to convert a and b to if given. Default is None.'}]}, {'Returns': [{'name': 'ret', 'type': 'ndarray', 'description': 'Array containing number of representable floating point numbers betweenitems in a and b.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If one or more elements differ by more than maxulp.'}]}]",">>> a = np.linspace(0., 1., 100)
>>> res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))"
numpy.testing.assert_array_equal,Raises an AssertionError if two array_like objects are not equal.,"[{'Parameters': [{'name': 'actual', 'type': 'array_like', 'description': 'The actual object to check.'}, {'name': 'desired', 'type': 'array_like', 'description': 'The desired, expected object.'}, {'name': 'err_msg', 'type': 'str, optional', 'description': 'The error message to be printed in case of failure.'}, {'name': 'verbose', 'type': 'bool, optional', 'description': 'If True, the conflicting values are appended to the error message.'}, {'name': 'strict', 'type': 'bool, optional', 'description': 'If True, raise an AssertionError when either the shape or the datatype of the array_like objects does not match. The specialhandling for scalars mentioned in the Notes section is disabled.New in version 1.24.0.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If actual and desired objects are not equal.'}]}]",">>> np.testing.assert_array_equal([1.0,2.33333,np.nan],
...                               [np.exp(0),2.33333, np.nan])
>>> np.testing.assert_array_equal([1.0,np.pi,np.nan],
...                               [1, np.sqrt(np.pi)**2, np.nan])
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not equal

Mismatched elements: 1 / 3 (33.3%)
Max absolute difference among violations: 4.4408921e-16
Max relative difference among violations: 1.41357986e-16
 ACTUAL: array([1.      , 3.141593,      nan])
 DESIRED: array([1.      , 3.141593,      nan])
>>> np.testing.assert_allclose([1.0,np.pi,np.nan],
...                            [1, np.sqrt(np.pi)**2, np.nan],
...                            rtol=1e-10, atol=0)
>>> x = np.full((2, 5), fill_value=3)
>>> np.testing.assert_array_equal(x, 3)
>>> np.testing.assert_array_equal(x, 3, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not equal

(shapes (2, 5), () mismatch)
 ACTUAL: array([[3, 3, 3, 3, 3],
       [3, 3, 3, 3, 3]])
 DESIRED: array(3)
>>> x = np.array([2, 2, 2])
>>> y = np.array([2., 2., 2.], dtype=np.float32)
>>> np.testing.assert_array_equal(x, y, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not equal

(dtypes int64, float32 mismatch)
 ACTUAL: array([2, 2, 2])
 DESIRED: array([2., 2., 2.], dtype=float32)"
numpy.testing.assert_array_less,"Raises an AssertionError if two array_like objects are not ordered by less
than.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The smaller object to check.'}, {'name': 'y', 'type': 'array_like', 'description': 'The larger object to compare.'}, {'name': 'err_msg', 'type': 'string', 'description': 'The error message to be printed in case of failure.'}, {'name': 'verbose', 'type': 'bool', 'description': 'If True, the conflicting values are appended to the error message.'}, {'name': 'strict', 'type': 'bool, optional', 'description': 'If True, raise an AssertionError when either the shape or the datatype of the array_like objects does not match. The specialhandling for scalars mentioned in the Notes section is disabled.New in version 2.0.0.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If x is not strictly smaller than y, element-wise.'}]}]",">>> x = [1.0, 1.0, np.nan]
>>> y = [1.1, 2.0, np.nan]
>>> np.testing.assert_array_less(x, y)
>>> y[0] = 1
>>> np.testing.assert_array_less(x, y)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not strictly ordered `x < y`

Mismatched elements: 1 / 3 (33.3%)
Max absolute difference among violations: 0.
Max relative difference among violations: 0.
 x: array([ 1.,  1., nan])
 y: array([ 1.,  2., nan])
>>> x = [1.0, 4.0]
>>> y = 5.0
>>> np.testing.assert_array_less(x, y)
>>> np.testing.assert_array_less(x, y, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not strictly ordered `x < y`

(shapes (2,), () mismatch)
 x: array([1., 4.])
 y: array(5.)
>>> y = [5, 5]
>>> np.testing.assert_array_less(x, y, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not strictly ordered `x < y`

(dtypes float64, int64 mismatch)
 x: array([1., 4.])
 y: array([5, 5])"
numpy.testing.assert_equal,Raises an AssertionError if two objects are not equal.,"[{'Parameters': [{'name': 'actual', 'type': 'array_like', 'description': 'The object to check.'}, {'name': 'desired', 'type': 'array_like', 'description': 'The expected object.'}, {'name': 'err_msg', 'type': 'str, optional', 'description': 'The error message to be printed in case of failure.'}, {'name': 'verbose', 'type': 'bool, optional', 'description': 'If True, the conflicting values are appended to the error message.'}, {'name': 'strict', 'type': 'bool, optional', 'description': 'If True and either of the actual and desired arguments is an array,raise an AssertionError when either the shape or the data type ofthe arguments does not match. If neither argument is an array, thisparameter has no effect.New in version 2.0.0.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If actual and desired are not equal.'}]}]",">>> np.testing.assert_equal([4, 5], [4, 6])
Traceback (most recent call last):
    ...
AssertionError:
Items are not equal:
item=1
 ACTUAL: 5
 DESIRED: 6
>>> np.testing.assert_equal(np.array([1.0, 2.0, np.nan]), [1, 2, np.nan])
>>> x = np.full((2, 5), fill_value=3)
>>> np.testing.assert_equal(x, 3)
>>> np.testing.assert_equal(x, 3, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not equal

(shapes (2, 5), () mismatch)
 ACTUAL: array([[3, 3, 3, 3, 3],
       [3, 3, 3, 3, 3]])
 DESIRED: array(3)
>>> x = np.array([2, 2, 2])
>>> y = np.array([2., 2., 2.], dtype=np.float32)
>>> np.testing.assert_equal(x, y, strict=True)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not equal

(dtypes int64, float32 mismatch)
 ACTUAL: array([2, 2, 2])
 DESIRED: array([2., 2., 2.], dtype=float32)"
numpy.testing.assert_raises,"Fail unless an exception of class exception_class is thrown
by callable when invoked with arguments args and keyword
arguments kwargs. If a different type of exception is
thrown, it will not be caught, and the test case will be
deemed to have suffered an error, exactly as for an
unexpected exception.",[],">>> from numpy.testing import assert_raises
>>> with assert_raises(ZeroDivisionError):
...     1 / 0
>>> def div(x, y):
...     return x / y
>>> assert_raises(ZeroDivisionError, div, 1, 0)"
numpy.testing.assert_raises_regex,"Fail unless an exception of class exception_class and with message that
matches expected_regexp is thrown by callable when invoked with arguments
args and keyword arguments kwargs.",[],
numpy.testing.assert_warns,Fail unless the given callable throws the specified warning.,"[{'Parameters': [{'name': 'warning_class', 'type': 'class', 'description': 'The class defining the warning that func is expected to throw.'}, {'name': 'func', 'type': 'callable, optional', 'description': 'Callable to test'}, {'name': '*args', 'type': 'Arguments', 'description': 'Arguments for func.'}, {'name': '**kwargs', 'type': 'Kwargs', 'description': 'Keyword arguments for func.'}]}, {'Returns': [{'name': 'The value returned by func.', 'type': None, 'description': ''}]}]",">>> import warnings
>>> def deprecated_func(num):
...     warnings.warn(""Please upgrade"", DeprecationWarning)
...     return num*num
>>> with np.testing.assert_warns(DeprecationWarning):
...     assert deprecated_func(4) == 16
>>> # or passing a func
>>> ret = np.testing.assert_warns(DeprecationWarning, deprecated_func, 4)
>>> assert ret == 16"
numpy.testing.assert_no_warnings,Fail if the given callable produces any warnings.,"[{'Parameters': [{'name': 'func', 'type': 'callable', 'description': 'The callable to test.'}, {'name': '*args', 'type': 'Arguments', 'description': 'Arguments passed to func.'}, {'name': '**kwargs', 'type': 'Kwargs', 'description': 'Keyword arguments passed to func.'}]}, {'Returns': [{'name': 'The value returned by func.', 'type': None, 'description': ''}]}]",
numpy.testing.assert_no_gc_cycles,Fail if the given callable produces any reference cycles.,"[{'Parameters': [{'name': 'func', 'type': 'callable', 'description': 'The callable to test.'}, {'name': '*args', 'type': 'Arguments', 'description': 'Arguments passed to func.'}, {'name': '**kwargs', 'type': 'Kwargs', 'description': 'Keyword arguments passed to func.'}]}, {'Returns': [{'name': 'Nothing. The result is deliberately discarded to ensure that all cycles', 'type': None, 'description': ''}, {'name': 'are found.', 'type': None, 'description': ''}]}]",
numpy.testing.assert_string_equal,Test if two strings are equal.,"[{'Parameters': [{'name': 'actual', 'type': 'str', 'description': 'The string to test for equality against the expected string.'}, {'name': 'desired', 'type': 'str', 'description': 'The expected string.'}]}]",">>> np.testing.assert_string_equal('abc', 'abc')
>>> np.testing.assert_string_equal('abc', 'abcd')
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
...
AssertionError: Differences in strings:
- abc+ abcd?    +"
numpy.testing.assert_,"Assert that works in release mode.
Accepts callable msg to allow deferring evaluation until failure.",[],
numpy.testing.assert_almost_equal,"Raises an AssertionError if two items are not equal up to desired
precision.","[{'Parameters': [{'name': 'actual', 'type': 'array_like', 'description': 'The object to check.'}, {'name': 'desired', 'type': 'array_like', 'description': 'The expected object.'}, {'name': 'decimal', 'type': 'int, optional', 'description': 'Desired precision, default is 7.'}, {'name': 'err_msg', 'type': 'str, optional', 'description': 'The error message to be printed in case of failure.'}, {'name': 'verbose', 'type': 'bool, optional', 'description': 'If True, the conflicting values are appended to the error message.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If actual and desired are not equal up to specified precision.'}]}]",">>> from numpy.testing import assert_almost_equal
>>> assert_almost_equal(2.3333333333333, 2.33333334)
>>> assert_almost_equal(2.3333333333333, 2.33333334, decimal=10)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not almost equal to 10 decimals
 ACTUAL: 2.3333333333333
 DESIRED: 2.33333334
>>> assert_almost_equal(np.array([1.0,2.3333333333333]),
...                     np.array([1.0,2.33333334]), decimal=9)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not almost equal to 9 decimals

Mismatched elements: 1 / 2 (50%)
Max absolute difference among violations: 6.66669964e-09
Max relative difference among violations: 2.85715698e-09
 ACTUAL: array([1.         , 2.333333333])
 DESIRED: array([1.        , 2.33333334])"
numpy.testing.assert_approx_equal,"Raises an AssertionError if two items are not equal up to significant
digits.","[{'Parameters': [{'name': 'actual', 'type': 'scalar', 'description': 'The object to check.'}, {'name': 'desired', 'type': 'scalar', 'description': 'The expected object.'}, {'name': 'significant', 'type': 'int, optional', 'description': 'Desired precision, default is 7.'}, {'name': 'err_msg', 'type': 'str, optional', 'description': 'The error message to be printed in case of failure.'}, {'name': 'verbose', 'type': 'bool, optional', 'description': 'If True, the conflicting values are appended to the error message.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If actual and desired are not equal up to specified precision.'}]}]",">>> np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20)
>>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,
...                                significant=8)
>>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,
...                                significant=8)
Traceback (most recent call last):
    ...
AssertionError:
Items are not equal to 8 significant digits:
 ACTUAL: 1.234567e-21
 DESIRED: 1.2345672e-21
>>> abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21) >= 10**-(8-1)
True"
numpy.testing.assert_array_almost_equal,"Raises an AssertionError if two objects are not equal up to desired
precision.","[{'Parameters': [{'name': 'actual', 'type': 'array_like', 'description': 'The actual object to check.'}, {'name': 'desired', 'type': 'array_like', 'description': 'The desired, expected object.'}, {'name': 'decimal', 'type': 'int, optional', 'description': 'Desired precision, default is 6.'}, {'name': 'err_msg', 'type': 'str, optional', 'description': 'The error message to be printed in case of failure.'}, {'name': 'verbose', 'type': 'bool, optional', 'description': 'If True, the conflicting values are appended to the error message.'}]}, {'Raises': [{'name': 'AssertionError', 'type': None, 'description': 'If actual and desired are not equal up to specified precision.'}]}]",">>> np.testing.assert_array_almost_equal([1.0,2.333,np.nan],
...                                      [1.0,2.333,np.nan])
>>> np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],
...                                      [1.0,2.33339,np.nan], decimal=5)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not almost equal to 5 decimals

Mismatched elements: 1 / 3 (33.3%)
Max absolute difference among violations: 6.e-05
Max relative difference among violations: 2.57136612e-05
 ACTUAL: array([1.     , 2.33333,     nan])
 DESIRED: array([1.     , 2.33339,     nan])
>>> np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],
...                                      [1.0,2.33333, 5], decimal=5)
Traceback (most recent call last):
    ...
AssertionError:
Arrays are not almost equal to 5 decimals

nan location mismatch:
 ACTUAL: array([1.     , 2.33333,     nan])
 DESIRED: array([1.     , 2.33333, 5.     ])"
numpy.testing.print_assert_equal,"Test if two objects are equal, and print an error message if test fails.","[{'Parameters': [{'name': 'test_string', 'type': 'str', 'description': 'The message supplied to AssertionError.'}, {'name': 'actual', 'type': 'object', 'description': 'The object to test for equality against desired.'}, {'name': 'desired', 'type': 'object', 'description': 'The expected result.'}]}]",">>> np.testing.print_assert_equal('Test XYZ of func xyz', [0, 1], [0, 1])
>>> np.testing.print_assert_equal('Test XYZ of func xyz', [0, 1], [0, 2])
Traceback (most recent call last):
...
AssertionError: Test XYZ of func xyz failed
ACTUAL:
[0, 1]
DESIRED:
[0, 2]"
numpy.testing.decorate_methods,Apply a decorator to all methods in a class matching a regular expression.,"[{'Parameters': [{'name': 'cls', 'type': 'class', 'description': 'Class whose methods to decorate.'}, {'name': 'decorator', 'type': 'function', 'description': 'Decorator to apply to methods'}, {'name': 'testmatch', 'type': 'compiled regexp or str, optional', 'description': ""The regular expression. Default value is None, in which case thenose default (re.compile(r'(?:^|[\\b_\\.%s-])[Tt]est' % os.sep))is used.If testmatch is a string, it is compiled to a regular expressionfirst.""}]}]",
numpy.testing.clear_and_catch_warnings,Context manager that resets warning registry for catching warnings,"[{'Parameters': [{'name': 'record', 'type': 'bool, optional', 'description': 'Specifies whether warnings should be captured by a customimplementation of warnings.showwarning() and be appended to a listreturned by the context manager. Otherwise None is returned by thecontext manager. The objects appended to the list are arguments whoseattributes mirror the arguments to showwarning().'}, {'name': 'modules', 'type': 'sequence, optional', 'description': 'Sequence of modules for which to reset warnings registry on entry andrestore on exit. To work correctly, all ‘ignore’ filters shouldfilter by one of these modules.'}]}]",">>> import warnings
>>> with np.testing.clear_and_catch_warnings(
...         modules=[np._core.fromnumeric]):
...     warnings.simplefilter('always')
...     warnings.filterwarnings('ignore', module='np._core.fromnumeric')
...     # do something that raises a warning but ignore those in
...     # np._core.fromnumeric"
numpy.testing.measure,Return elapsed time for executing code in the namespace of the caller.,"[{'Parameters': [{'name': 'code_str', 'type': 'str', 'description': 'The code to be timed.'}, {'name': 'times', 'type': 'int, optional', 'description': 'The number of times the code is executed. Default is 1. The code isonly compiled once.'}, {'name': 'label', 'type': 'str, optional', 'description': 'A label to identify code_str with. This is passed into compileas the second argument (for run-time error messages).'}]}, {'Returns': [{'name': 'elapsed', 'type': 'float', 'description': 'Total elapsed time in seconds for executing code_str times times.'}]}]",">>> times = 10
>>> etime = np.testing.measure('for i in range(1000): np.sqrt(i**2)', times=times)
>>> print(""Time for a single execution : "", etime / times, ""s"")  
Time for a single execution :  0.005 s"
numpy.testing.rundocs,Run doctests found in the given file.,"[{'Parameters': [{'name': 'filename', 'type': 'str', 'description': 'The path to the file for which the doctests are run.'}, {'name': 'raise_on_error', 'type': 'bool', 'description': 'Whether to raise an AssertionError when a doctest fails. Default isTrue.'}]}]",>>> np.lib.test(doctests=True)
numpy.testing.suppress_warnings,"Context manager and decorator doing much the same as
warnings.catch_warnings.","[{'Parameters': [{'name': 'forwarding_rule', 'type': 'str, optional', 'description': 'One of “always”, “once”, “module”, or “location”. Analogous tothe usual warnings module filter mode, it is useful to reducenoise mostly on the outmost level. Unsuppressed and unrecordedwarnings will be forwarded based on this rule. Defaults to “always”.“location” is equivalent to the warnings “default”, match by exactlocation the warning warning originated from.'}]}]",
numpy.testing.overrides.allows_array_function_override,Determine if a Numpy function can be overridden via __array_function__,"[{'Parameters': [{'name': 'func', 'type': 'callable', 'description': 'Function that may be overridable via __array_function__'}]}, {'Returns': [{'name': 'bool', 'type': None, 'description': 'True if func is a function in the Numpy API that isoverridable via __array_function__ and False otherwise.'}]}]",
numpy.testing.overrides.allows_array_ufunc_override,Determine if a function can be overridden via __array_ufunc__,"[{'Parameters': [{'name': 'func', 'type': 'callable', 'description': 'Function that may be overridable via __array_ufunc__'}]}, {'Returns': [{'name': 'bool', 'type': None, 'description': 'True if func is overridable via __array_ufunc__ andFalse otherwise.'}]}]",
numpy.testing.overrides.get_overridable_numpy_ufuncs,List all numpy ufuncs overridable via __array_ufunc__,"[{'Parameters': [{'name': 'None', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'set', 'type': None, 'description': 'A set containing all overridable ufuncs in the public numpy API.'}]}]",
numpy.testing.overrides.get_overridable_numpy_array_functions,List all numpy functions overridable via __array_function__,"[{'Parameters': [{'name': 'None', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'set', 'type': None, 'description': 'A set containing all functions in the public numpy API that areoverridable via __array_function__.'}]}]",
numpy.typing.ArrayLike = typing.Union[...],A Union representing objects that can be coercedinto an ndarray.,[],
numpy.typing.DTypeLike = typing.Union[...],A Union representing objects that can be coercedinto a dtype.,[],
"numpy.typing.NDArray = numpy.ndarray[tuple[int, ...], numpy.dtype[+_ScalarType_co]][source]","A np.ndarray[tuple[int, ...], np.dtype[+ScalarType]]type alias generic w.r.t. itsdtype.type.",[],
class numpy.typing.NBitBase[source],A type representing numpy.number precision during static type checking.,[],
"class numpy.random.Philox(seed=None, counter=None, key=None)",Container for the Philox (4x64) pseudo-random number generator.,"[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like[ints], SeedSequence}, optional', 'description': 'A seed to initialize the BitGenerator. If None, then fresh,unpredictable entropy will be pulled from the OS. If an int orarray_like[ints] is passed, then it will be passed toSeedSequence to derive the initial BitGenerator state. One may alsopass in a SeedSequence instance.'}, {'name': 'counter', 'type': '{None, int, array_like}, optional', 'description': 'Counter to use in the Philox state. Can be eithera Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array.If not provided, the RNG is initialized at 0.'}, {'name': 'key', 'type': '{None, int, array_like}, optional', 'description': 'Key to use in the Philox state.  Unlike seed, the value in key isdirectly set. Can be either a Python int in [0, 2**128) or a 2-elementuint64 array. key and seed cannot both be used.'}]}, {'Attributes': [{'name': 'lock: threading.Lock', 'type': None, 'description': 'Lock instance that is shared so that the same bit git generator canbe used in multiple Generators without corrupting the state. Code thatgenerates values from a bit generator should hold the bit generator’slock.'}]}]",">>> from numpy.random import Generator, Philox, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(Philox(s)) for s in sg.spawn(10)]
>>> from numpy.random import Generator, Philox
>>> bit_generator = Philox(1234)
>>> rg = []
>>> for _ in range(10):
...    rg.append(Generator(bit_generator))
...    bit_generator = bit_generator.jumped()
>>> key = 2**96 + 2**33 + 2**17 + 2**9
>>> rg = [Generator(Philox(key=key+i)) for i in range(10)]
>>> from numpy.random import Generator, Philox
>>> rg = Generator(Philox(1234))
>>> rg.standard_normal()
0.123  # random"
numpy.random.Philox.state,attribute,"[{'Returns': [{'name': 'state', 'type': 'dict', 'description': 'Dictionary containing the information required to describe thestate of the PRNG'}]}]",
numpy.random.Philox.advance,method,"[{'Parameters': [{'name': 'delta', 'type': 'integer, positive', 'description': 'Number of draws to advance the RNG. Must be less than thesize state variable in the underlying RNG.'}]}, {'Returns': [{'name': 'self', 'type': 'Philox', 'description': 'RNG advanced delta steps'}]}]",
numpy.random.Philox.jumped,method,"[{'Parameters': [{'name': 'jumps', 'type': 'integer, positive', 'description': 'Number of times to jump the state of the bit generator returned'}]}, {'Returns': [{'name': 'bit_generator', 'type': 'Philox', 'description': 'New instance of generator jumped iter times'}]}]",
numpy.random.Philox.cffi,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.random.Philox.ctypes,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
class numpy.random.RandomState(seed=None),Container for the slow Mersenne Twister pseudo-random number generator.Consider using a different BitGenerator with the Generator containerinstead.,"[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like, BitGenerator}, optional', 'description': 'Random seed used to initialize the pseudo-random number generator oran instantized BitGenerator.  If an integer or array, used as a seed forthe MT19937 BitGenerator. Values can be any integer between 0 and2**32 - 1 inclusive, an array (or other sequence) of such integers,or None (the default).  If seed is None, then the MT19937BitGenerator is initialized by reading data from /dev/urandom(or the Windows analogue) if available or seed from the clockotherwise.'}]}]",
numpy.random.RandomState.get_state,method,"[{'Parameters': [{'name': 'legacy', 'type': 'bool, optional', 'description': 'Flag indicating to return a legacy tuple state when the BitGeneratoris MT19937, instead of a dict. Raises ValueError if the underlyingbit generator is not an instance of MT19937.'}]}, {'Returns': [{'name': 'out', 'type': '{tuple(str, ndarray of 624 uints, int, int, float), dict}', 'description': 'If legacy is True, the returned tuple has the following items:the string ‘MT19937’.a 1-D array of 624 unsigned integer keys.an integer pos.an integer has_gauss.a float cached_gaussian.If legacy is False, or the BitGenerator is not MT19937, thenstate is returned as a dictionary.'}]}]",
numpy.random.RandomState.set_state,method,"[{'Parameters': [{'name': 'state', 'type': '{tuple(str, ndarray of 624 uints, int, int, float), dict}', 'description': 'The state tuple has the following items:the string ‘MT19937’, specifying the Mersenne Twister algorithm.a 1-D array of 624 unsigned integers keys.an integer pos.an integer has_gauss.a float cached_gaussian.If state is a dictionary, it is directly set using the BitGeneratorsstate property.'}]}, {'Returns': [{'name': 'out', 'type': 'None', 'description': 'Returns ‘None’ on success.'}]}]",
numpy.random.RandomState.seed,method,[],">>> from numpy.random import MT19937
>>> from numpy.random import RandomState, SeedSequence
>>> rs = RandomState(MT19937(SeedSequence(123456789)))
# Later, you want to restart the stream
>>> rs = RandomState(MT19937(SeedSequence(987654321)))"
numpy.random.RandomState.rand,method,"[{'Parameters': [{'name': 'd0, d1, …, dn', 'type': 'int, optional', 'description': 'The dimensions of the returned array, must be non-negative.If no argument is given a single Python float is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray, shape (d0, d1, ..., dn)', 'description': 'Random values.'}]}]",">>> np.random.rand(3,2)
array([[ 0.14022471,  0.96360618],  #random
       [ 0.37601032,  0.25528411],  #random
       [ 0.49313049,  0.94909878]]) #random"
numpy.random.RandomState.randn,method,"[{'Parameters': [{'name': 'd0, d1, …, dn', 'type': 'int, optional', 'description': 'The dimensions of the returned array, must be non-negative.If no argument is given a single Python float is returned.'}]}, {'Returns': [{'name': 'Z', 'type': 'ndarray or float', 'description': 'A (d0, d1, ..., dn)-shaped array of floating-point samples fromthe standard normal distribution, or a single such float ifno parameters were supplied.'}]}]",">>> np.random.randn()
2.1923875335537315  # random
>>> 3 + 2.5 * np.random.randn(2, 4)
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.RandomState.randint,method,"[{'Parameters': [{'name': 'low', 'type': 'int or array-like of ints', 'description': 'Lowest (signed) integers to be drawn from the distribution (unlesshigh=None, in which case this parameter is one above thehighest such integer).'}, {'name': 'high', 'type': 'int or array-like of ints, optional', 'description': 'If provided, one above the largest (signed) integer to be drawnfrom the distribution (see above for behavior if high=None).If array-like, must contain integer values'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Desired dtype of the result. Byteorder must be native.The default value is long.WarningThis function defaults to the C-long dtype, which is 32bit on windowsand otherwise 64bit on 64bit platforms (and 32bit on 32bit ones).Since NumPy 2.0, NumPy’s default integer is 32bit on 32bit platformsand 64bit on 64bit platforms.  Which corresponds to np.intp.(dtype=int is not the same as in most NumPy functions.)'}]}, {'Returns': [{'name': 'out', 'type': 'int or ndarray of ints', 'description': 'size-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.'}]}]",">>> np.random.randint(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random
>>> np.random.randint(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
>>> np.random.randint(5, size=(2, 4))
array([[4, 0, 2, 1], # random
       [3, 2, 2, 0]])
>>> np.random.randint(1, [3, 5, 10])
array([2, 2, 9]) # random
>>> np.random.randint([1, 5, 7], 10)
array([9, 8, 7]) # random
>>> np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)
array([[ 8,  6,  9,  7], # random
       [ 1, 16,  9, 12]], dtype=uint8)"
numpy.random.RandomState.random_integers,method,"[{'Parameters': [{'name': 'low', 'type': 'int', 'description': 'Lowest (signed) integer to be drawn from the distribution (unlesshigh=None, in which case this parameter is the highest suchinteger).'}, {'name': 'high', 'type': 'int, optional', 'description': 'If provided, the largest (signed) integer to be drawn from thedistribution (see above for behavior if high=None).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'int or ndarray of ints', 'description': 'size-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.'}]}]",">>> np.random.random_integers(5)
4 # random
>>> type(np.random.random_integers(5))
<class 'numpy.int64'>
>>> np.random.random_integers(5, size=(3,2))
array([[5, 4], # random
       [3, 3],
       [4, 5]])
>>> 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random
>>> d1 = np.random.random_integers(1, 6, 1000)
>>> d2 = np.random.random_integers(1, 6, 1000)
>>> dsums = d1 + d2
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(dsums, 11, density=True)
>>> plt.show()"
Scalars,"Python defines only one type of a particular data class (there is only
one integer type, one floating-point type, etc.). This can be
convenient in applications that don’t need to be concerned with all
the ways data can be represented in a computer.  For scientific
computing, however, more control is often needed.","[{'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Parameters': [{'name': 'length_or_data', 'type': 'int, array-like, bytes-like, object', 'description': 'One of multiple meanings (see notes).  The length orbytes data of an unstructured void.  Or alternatively,the data to be stored in the new scalar when dtypeis provided.This can be an array-like, in which case an array maybe returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'If provided the dtype of the new scalar.  This dtype mustbe “void” dtype (i.e. a structured or unstructured void,see also Structured datatypes).New in version 1.24.'}]}, {'Character code': []}, {'Character code': []}, {'Character code': []}]",">>> import numpy as np
>>> f16 = np.float16(""0.1"")
>>> f32 = np.float32(f16)
>>> f64 = np.float64(f32)
>>> f16 == f32 == f64
True
>>> f16, f32, f64
(0.1, 0.099975586, 0.0999755859375)
>>> f16 = np.float16(""0.1"")
>>> f32 = np.float32(""0.1"")
>>> f64 = np.float64(""0.1"")
>>> f16 == f32 == f64
False
>>> f16, f32, f64
(0.1, 0.1, 0.1)
>>> np.datetime64(10, 'Y')
np.datetime64('1980')
>>> np.datetime64('1980', 'Y')
np.datetime64('1980')
>>> np.datetime64(10, 'D')
np.datetime64('1970-01-11')
>>> s = np.str_(""abc\x00"")
>>> s
'abc'
>>> m = memoryview(np.str_(""abc""))
>>> m.format
'3w'
>>> m.tobytes()
b'a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'
>>> np.void(5)
np.void(b'\x00\x00\x00\x00\x00')
>>> np.void(b'abcd')
np.void(b'\x61\x62\x63\x64')
>>> np.void((3.2, b'eggs'), dtype=""d,S5"")
np.void((3.2, b'eggs'), dtype=[('f0', '<f8'), ('f1', 'S5')])
>>> np.void(3, dtype=[('x', np.int8), ('y', np.int8)])
np.void((3, 3), dtype=[('x', 'i1'), ('y', 'i1')])"
numpy.random.RandomState.random_sample,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray of floats', 'description': 'Array of random floats of shape size (unless size=None, in whichcase a single float is returned).'}]}]",">>> np.random.random_sample()
0.47108547995356098 # random
>>> type(np.random.random_sample())
<class 'float'>
>>> np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random
>>> 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984], # random
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])"
numpy.random.RandomState.choice,method,"[{'Parameters': [{'name': 'a', 'type': '1-D array-like or int', 'description': 'If an ndarray, a random sample is generated from its elements.If an int, the random sample is generated as if it were np.arange(a)'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'replace', 'type': 'boolean, optional', 'description': 'Whether the sample is with or without replacement. Default is True,meaning that a value of a can be selected multiple times.'}, {'name': 'p', 'type': '1-D array-like, optional', 'description': 'The probabilities associated with each entry in a.If not given, the sample assumes a uniform distribution over allentries in a.'}]}, {'Returns': [{'name': 'samples', 'type': 'single item or ndarray', 'description': 'The generated random samples'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If a is an int and less than zero, if a or p are not 1-dimensional,if a is an array-like of size 0, if p is not a vector ofprobabilities, if a and p have different lengths, or ifreplace=False and the sample size is greater than the populationsize'}]}]",">>> np.random.choice(5, 3)
array([0, 3, 4]) # random
>>> #This is equivalent to np.random.randint(0,5,3)
>>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
array([3, 3, 0]) # random
>>> np.random.choice(5, 3, replace=False)
array([3,1,0]) # random
>>> #This is equivalent to np.random.permutation(np.arange(5))[:3]
>>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
array([2, 3, 0]) # random
>>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
>>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random
      dtype='<U11')"
numpy.random.RandomState.bytes,method,"[{'Parameters': [{'name': 'length', 'type': 'int', 'description': 'Number of random bytes.'}]}, {'Returns': [{'name': 'out', 'type': 'bytes', 'description': 'String of length length.'}]}]",">>> np.random.bytes(10)
b' eh\x85\x022SZ\xbf\xa4' #random"
numpy.random.RandomState.shuffle,method,"[{'Parameters': [{'name': 'x', 'type': 'ndarray or MutableSequence', 'description': 'The array, list or mutable sequence to be shuffled.'}]}, {'Returns': [{'name': 'None', 'type': None, 'description': ''}]}]",">>> arr = np.arange(10)
>>> np.random.shuffle(arr)
>>> arr
[1 7 5 2 9 4 3 6 0 8] # random
>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.shuffle(arr)
>>> arr
array([[3, 4, 5], # random
       [6, 7, 8],
       [0, 1, 2]])"
numpy.random.RandomState.permutation,method,"[{'Parameters': [{'name': 'x', 'type': 'int or array_like', 'description': 'If x is an integer, randomly permute np.arange(x).If x is an array, make a copy and shuffle the elementsrandomly.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Permuted sequence or array range.'}]}]",">>> np.random.permutation(10)
array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random
>>> np.random.permutation([1, 4, 9, 12, 15])
array([15,  1,  9,  4, 12]) # random
>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.permutation(arr)
array([[6, 7, 8], # random
       [0, 1, 2],
       [3, 4, 5]])"
numpy.random.RandomState.beta,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Alpha, positive (>0).'}, {'name': 'b', 'type': 'float or array_like of floats', 'description': 'Beta, positive (>0).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a and b are both scalars.Otherwise, np.broadcast(a, b).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized beta distribution.'}]}]",
numpy.random.RandomState.binomial,method,"[{'Parameters': [{'name': 'n', 'type': 'int or array_like of ints', 'description': 'Parameter of the distribution, >= 0. Floats are also accepted,but they will be truncated to integers.'}, {'name': 'p', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, >= 0 and <=1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if n and p are both scalars.Otherwise, np.broadcast(n, p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized binomial distribution, whereeach sample is equal to the number of successes over the n trials.'}]}]",">>> n, p = 10, .5  # number of trials, probability of each trial
>>> s = np.random.binomial(n, p, 1000)
# result of flipping a coin 10 times, tested 1000 times.
>>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
# answer = 0.38885, or 38%."
numpy.random.RandomState.chisquare,method,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Number of degrees of freedom, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df is a scalar.  Otherwise,np.array(df).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized chi-square distribution.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'When df <= 0 or when an inappropriate size (e.g. size=-1)is given.'}]}]",">>> np.random.chisquare(2,4)
array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random"
numpy.random.RandomState.dirichlet,method,"[{'Parameters': [{'name': 'alpha', 'type': 'sequence of floats, length k', 'description': 'Parameter of the distribution (length k for sample oflength k).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n), thenm * n * k samples are drawn.  Default is None, in which case avector of length k is returned.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray,', 'description': 'The drawn samples, of shape (size, k).'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If any value in alpha is less than or equal to zero'}]}]",">>> s = np.random.dirichlet((10, 5, 3), 20).transpose()
>>> import matplotlib.pyplot as plt
>>> plt.barh(range(20), s[0])
>>> plt.barh(range(20), s[1], left=s[0], color='g')
>>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
>>> plt.title(""Lengths of Strings"")"
numpy.random.RandomState.exponential,method,"[{'Parameters': [{'name': 'scale', 'type': 'float or array_like of floats', 'description': 'The scale parameter, \\(\\beta = 1/\\lambda\\). Must benon-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if scale is a scalar.  Otherwise,np.array(scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized exponential distribution.'}]}]",">>> n = 10000
>>> time_between_calls = np.random.default_rng().exponential(scale=4, size=n)
>>> x = ((time_between_calls < 5).sum())/n 
>>> y = ((time_between_calls < 4).sum())/n
>>> x-y
0.08 # may vary"
numpy.random.RandomState.f,method,"[{'Parameters': [{'name': 'dfnum', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom in numerator, must be > 0.'}, {'name': 'dfden', 'type': 'float or array_like of float', 'description': 'Degrees of freedom in denominator, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if dfnum and dfden are both scalars.Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Fisher distribution.'}]}]",">>> dfnum = 1. # between group degrees of freedom
>>> dfden = 48. # within groups degrees of freedom
>>> s = np.random.f(dfnum, dfden, 1000)
>>> np.sort(s)[-10]
7.61988120985 # random"
numpy.random.RandomState.gamma,method,"[{'Parameters': [{'name': 'shape', 'type': 'float or array_like of floats', 'description': 'The shape of the gamma distribution. Must be non-negative.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'The scale of the gamma distribution. Must be non-negative.Default is equal to 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if shape and scale are both scalars.Otherwise, np.broadcast(shape, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized gamma distribution.'}]}]",">>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
>>> s = np.random.gamma(shape, scale, 1000)
>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1)*(np.exp(-bins/scale) /  
...                      (sps.gamma(shape)*scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.RandomState.geometric,method,"[{'Parameters': [{'name': 'p', 'type': 'float or array_like of floats', 'description': 'The probability of success of an individual trial.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if p is a scalar.  Otherwise,np.array(p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized geometric distribution.'}]}]",">>> z = np.random.geometric(p=0.35, size=10000)
>>> (z == 1).sum() / 10000.
0.34889999999999999 #random"
numpy.random.RandomState.gumbel,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'The location of the mode of the distribution. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'The scale parameter of the distribution. Default is 1. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Gumbel distribution.'}]}]",">>> mu, beta = 0, 0.1 # location and scale
>>> s = np.random.gumbel(mu, beta, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp( -np.exp( -(bins - mu) /beta) ),
...          linewidth=2, color='r')
>>> plt.show()
>>> means = []
>>> maxima = []
>>> for i in range(0,1000) :
...    a = np.random.normal(mu, beta, 1000)
...    means.append(a.mean())
...    maxima.append(a.max())
>>> count, bins, ignored = plt.hist(maxima, 30, density=True)
>>> beta = np.std(maxima) * np.sqrt(6) / np.pi
>>> mu = np.mean(maxima) - 0.57721*beta
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp(-np.exp(-(bins - mu)/beta)),
...          linewidth=2, color='r')
>>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
...          linewidth=2, color='g')
>>> plt.show()"
numpy.random.RandomState.hypergeometric,method,"[{'Parameters': [{'name': 'ngood', 'type': 'int or array_like of ints', 'description': 'Number of ways to make a good selection.  Must be nonnegative.'}, {'name': 'nbad', 'type': 'int or array_like of ints', 'description': 'Number of ways to make a bad selection.  Must be nonnegative.'}, {'name': 'nsample', 'type': 'int or array_like of ints', 'description': 'Number of items sampled.  Must be at least 1 and at mostngood + nbad.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if ngood, nbad, and nsampleare all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized hypergeometric distribution. Eachsample is the number of good items within a randomly selected subset ofsize nsample taken from a set of ngood good items and nbad bad items.'}]}]",">>> ngood, nbad, nsamp = 100, 2, 10
# number of good, number of bad, and number of samples
>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
>>> from matplotlib.pyplot import hist
>>> hist(s)
#   note that it is very unlikely to grab both bad items
>>> s = np.random.hypergeometric(15, 15, 15, 100000)
>>> sum(s>=12)/100000. + sum(s<=3)/100000.
#   answer = 0.003 ... pretty unlikely!"
numpy.random.RandomState.laplace,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'The position, \\(\\mu\\), of the distribution peak. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': '\\(\\lambda\\), the exponential decay. Default is 1. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Laplace distribution.'}]}]",">>> loc, scale = 0., 1.
>>> s = np.random.laplace(loc, scale, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> x = np.arange(-8., 8., .01)
>>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
>>> plt.plot(x, pdf)
>>> g = (1/(scale * np.sqrt(2 * np.pi)) *
...      np.exp(-(x - loc)**2 / (2 * scale**2)))
>>> plt.plot(x,g)"
numpy.random.RandomState.logistic,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'Parameter of the distribution. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'Parameter of the distribution. Must be non-negative.Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized logistic distribution.'}]}]",">>> loc, scale = 10, 1
>>> s = np.random.logistic(loc, scale, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=50)
>>> def logist(x, loc, scale):
...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)
>>> lgst_val = logist(bins, loc, scale)
>>> plt.plot(bins, lgst_val * count.max() / lgst_val.max())
>>> plt.show()"
numpy.random.RandomState.lognormal,method,"[{'Parameters': [{'name': 'mean', 'type': 'float or array_like of floats, optional', 'description': 'Mean value of the underlying normal distribution. Default is 0.'}, {'name': 'sigma', 'type': 'float or array_like of floats, optional', 'description': 'Standard deviation of the underlying normal distribution. Must benon-negative. Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mean and sigma are both scalars.Otherwise, np.broadcast(mean, sigma).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized log-normal distribution.'}]}]",">>> mu, sigma = 3., 1. # mean and standard deviation
>>> s = np.random.lognormal(mu, sigma, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 100, density=True, align='mid')
>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))
>>> plt.plot(x, pdf, linewidth=2, color='r')
>>> plt.axis('tight')
>>> plt.show()
>>> # Generate a thousand samples: each is the product of 100 random
>>> # values, drawn from a normal distribution.
>>> b = []
>>> for i in range(1000):
...    a = 10. + np.random.standard_normal(100)
...    b.append(np.prod(a))
>>> b = np.array(b) / np.min(b) # scale values to be positive
>>> count, bins, ignored = plt.hist(b, 100, density=True, align='mid')
>>> sigma = np.std(np.log(b))
>>> mu = np.mean(np.log(b))
>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))
>>> plt.plot(x, pdf, color='r', linewidth=2)
>>> plt.show()"
numpy.random.RandomState.logseries,method,"[{'Parameters': [{'name': 'p', 'type': 'float or array_like of floats', 'description': 'Shape parameter for the distribution.  Must be in the range [0, 1).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if p is a scalar.  Otherwise,np.array(p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized logarithmic series distribution.'}]}]",">>> a = .6
>>> s = np.random.logseries(a, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s)
>>> def logseries(k, p):
...     return -p**k/(k*np.log(1-p))
>>> plt.plot(bins, logseries(bins, a)*count.max()/
...          logseries(bins, a).max(), 'r')
>>> plt.show()"
numpy.random.RandomState.multinomial,method,"[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'Number of experiments.'}, {'name': 'pvals', 'type': 'sequence of floats, length p', 'description': 'Probabilities of each of the p different outcomes.  Thesemust sum to 1 (however, the last element is always assumed toaccount for the remaining probability, as long assum(pvals[:-1]) <= 1).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.'}]}]",">>> np.random.multinomial(20, [1/6.]*6, size=1)
array([[4, 1, 7, 5, 2, 1]]) # random
>>> np.random.multinomial(20, [1/6.]*6, size=2)
array([[3, 4, 3, 3, 4, 3], # random
       [2, 4, 3, 4, 0, 7]])
>>> np.random.multinomial(100, [1/7.]*5 + [2/7.])
array([11, 16, 14, 17, 16, 26]) # random
>>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
array([38, 62]) # random
>>> np.random.multinomial(100, [1.0, 2.0])  # WRONG
Traceback (most recent call last):
ValueError: pvals < 0, pvals > 1 or pvals contains NaNs"
numpy.random.RandomState.multivariate_normal,method,"[{'Parameters': [{'name': 'mean', 'type': '1-D array_like, of length N', 'description': 'Mean of the N-dimensional distribution.'}, {'name': 'cov', 'type': '2-D array_like, of shape (N, N)', 'description': 'Covariance matrix of the distribution. It must be symmetric andpositive-semidefinite for proper sampling.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Given a shape of, for example, (m,n,k), m*n*k samples aregenerated, and packed in an m-by-n-by-k arrangement.  Becauseeach sample is N-dimensional, the output shape is (m,n,k,N).If no shape is specified, a single (N-D) sample is returned.'}, {'name': 'check_valid', 'type': '{ ‘warn’, ‘raise’, ‘ignore’ }, optional', 'description': 'Behavior when the covariance matrix is not positive semidefinite.'}, {'name': 'tol', 'type': 'float, optional', 'description': 'Tolerance when checking the singular values in covariance matrix.cov is cast to double before the check.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.'}]}]",">>> mean = [0, 0]
>>> cov = [[1, 0], [0, 100]]  # diagonal covariance
>>> import matplotlib.pyplot as plt
>>> x, y = np.random.multivariate_normal(mean, cov, 5000).T
>>> plt.plot(x, y, 'x')
>>> plt.axis('equal')
>>> plt.show()
>>> mean = (1, 2)
>>> cov = [[1, 0], [0, 1]]
>>> x = np.random.multivariate_normal(mean, cov, (3, 3))
>>> x.shape
(3, 3, 2)
>>> cov = np.array([[6, -3], [-3, 3.5]])
>>> pts = np.random.multivariate_normal([0, 0], cov, size=800)
>>> pts.mean(axis=0)
array([ 0.0326911 , -0.01280782])  # may vary
>>> np.cov(pts.T)
array([[ 5.96202397, -2.85602287],
       [-2.85602287,  3.47613949]])  # may vary
>>> np.corrcoef(pts.T)[0, 1]
-0.6273591314603949  # may vary
>>> import matplotlib.pyplot as plt
>>> plt.plot(pts[:, 0], pts[:, 1], '.', alpha=0.5)
>>> plt.axis('equal')
>>> plt.grid()
>>> plt.show()"
numpy.random.RandomState.negative_binomial,method,"[{'Parameters': [{'name': 'n', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, > 0.'}, {'name': 'p', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, >= 0 and <=1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if n and p are both scalars.Otherwise, np.broadcast(n, p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized negative binomial distribution,where each sample is equal to N, the number of failures thatoccurred before a total of n successes was reached.'}]}]",">>> s = np.random.negative_binomial(1, 0.1, 100000)
>>> for i in range(1, 11): 
...    probability = sum(s<i) / 100000.
...    print(i, ""wells drilled, probability of one success ="", probability)"
numpy.random.RandomState.noncentral_chisquare,method,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom, must be > 0.'}, {'name': 'nonc', 'type': 'float or array_like of floats', 'description': 'Non-centrality, must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df and nonc are both scalars.Otherwise, np.broadcast(df, nonc).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized noncentral chi-square distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()
>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
...                   bins=np.arange(0., 25, .1), density=True)
>>> values2 = plt.hist(np.random.chisquare(3, 100000),
...                    bins=np.arange(0., 25, .1), density=True)
>>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
>>> plt.show()
>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()"
numpy.random.RandomState.noncentral_f,method,"[{'Parameters': [{'name': 'dfnum', 'type': 'float or array_like of floats', 'description': 'Numerator degrees of freedom, must be > 0.'}, {'name': 'dfden', 'type': 'float or array_like of floats', 'description': 'Denominator degrees of freedom, must be > 0.'}, {'name': 'nonc', 'type': 'float or array_like of floats', 'description': 'Non-centrality parameter, the sum of the squares of the numeratormeans, must be >= 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if dfnum, dfden, and noncare all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized noncentral Fisher distribution.'}]}]",">>> dfnum = 3 # between group deg of freedom
>>> dfden = 20 # within groups degrees of freedom
>>> nonc = 3.0
>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
>>> NF = np.histogram(nc_vals, bins=50, density=True)
>>> c_vals = np.random.f(dfnum, dfden, 1000000)
>>> F = np.histogram(c_vals, bins=50, density=True)
>>> import matplotlib.pyplot as plt
>>> plt.plot(F[1][1:], F[0])
>>> plt.plot(NF[1][1:], NF[0])
>>> plt.show()"
numpy.random.RandomState.normal,method,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats', 'description': 'Mean (“centre”) of the distribution.'}, {'name': 'scale', 'type': 'float or array_like of floats', 'description': 'Standard deviation (spread or “width”) of the distribution. Must benon-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized normal distribution.'}]}]",">>> mu, sigma = 0, 0.1 # mean and standard deviation
>>> s = np.random.normal(mu, sigma, 1000)
>>> abs(mu - np.mean(s))
0.0  # may vary
>>> abs(sigma - np.std(s, ddof=1))
0.1  # may vary
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
>>> plt.show()
>>> np.random.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.RandomState.pareto,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Shape of the distribution. Must be positive.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Pareto distribution.'}]}]",">>> a, m = 3., 2.  # shape and mode
>>> s = (np.random.pareto(a, 1000) + 1) * m
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 100, density=True)
>>> fit = a*m**a / bins**(a+1)
>>> plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
>>> plt.show()"
numpy.random.RandomState.poisson,method,"[{'Parameters': [{'name': 'lam', 'type': 'float or array_like of floats', 'description': 'Expected number of events occurring in a fixed-time interval,must be >= 0. A sequence must be broadcastable over the requestedsize.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if lam is a scalar. Otherwise,np.array(lam).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Poisson distribution.'}]}]",">>> import numpy as np
>>> s = np.random.poisson(5, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 14, density=True)
>>> plt.show()
>>> s = np.random.poisson(lam=(100., 500.), size=(100, 2))"
numpy.random.RandomState.power,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized power distribution.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If a <= 0.'}]}]",">>> a = 5. # shape
>>> samples = 1000
>>> s = np.random.power(a, samples)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=30)
>>> x = np.linspace(0, 1, 100)
>>> y = a*x**(a-1.)
>>> normed_y = samples*np.diff(bins)[0]*y
>>> plt.plot(x, normed_y)
>>> plt.show()
>>> from scipy import stats 
>>> rvs = np.random.power(5, 1000000)
>>> rvsp = np.random.pareto(5, 1000000)
>>> xx = np.linspace(0,1,100)
>>> powpdf = stats.powerlaw.pdf(xx,5)
>>> plt.figure()
>>> plt.hist(rvs, bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('np.random.power(5)')
>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('inverse of 1 + np.random.pareto(5)')
>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('inverse of stats.pareto(5)')"
numpy.random.RandomState.rayleigh,method,"[{'Parameters': [{'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'Scale, also equals the mode. Must be non-negative. Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if scale is a scalar.  Otherwise,np.array(scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Rayleigh distribution.'}]}]",">>> from matplotlib.pyplot import hist
>>> values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)
>>> meanvalue = 1
>>> modevalue = np.sqrt(2 / np.pi) * meanvalue
>>> s = np.random.rayleigh(modevalue, 1000000)
>>> 100.*sum(s>3)/1000000.
0.087300000000000003 # random"
numpy.random.RandomState.standard_cauchy,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray or scalar', 'description': 'The drawn samples.'}]}]",">>> import matplotlib.pyplot as plt
>>> s = np.random.standard_cauchy(1000000)
>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
>>> plt.hist(s, bins=100)
>>> plt.show()"
numpy.random.RandomState.standard_exponential,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray', 'description': 'Drawn samples.'}]}]",">>> n = np.random.standard_exponential((3, 8000))"
numpy.random.RandomState.standard_gamma,method,"[{'Parameters': [{'name': 'shape', 'type': 'float or array_like of floats', 'description': 'Parameter, must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if shape is a scalar.  Otherwise,np.array(shape).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized standard gamma distribution.'}]}]",">>> shape, scale = 2., 1. # mean and width
>>> s = np.random.standard_gamma(shape, 1000000)
>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1) * ((np.exp(-bins/scale))/  
...                       (sps.gamma(shape) * scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.RandomState.standard_normal,method,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray', 'description': 'A floating-point array of shape size of drawn samples, or asingle sample if size was not specified.'}]}]",">>> np.random.standard_normal()
2.1923875335537315 #random
>>> s = np.random.standard_normal(8000)
>>> s
array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
       -0.38672696, -0.4685006 ])                                # random
>>> s.shape
(8000,)
>>> s = np.random.standard_normal(size=(3, 4, 2))
>>> s.shape
(3, 4, 2)
>>> 3 + 2.5 * np.random.standard_normal(size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.RandomState.standard_t,method,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df is a scalar.  Otherwise,np.array(df).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized standard Student’s t distribution.'}]}]",">>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
...                    7515, 8230, 8770])
>>> np.mean(intake)
6753.636363636364
>>> intake.std(ddof=1)
1142.1232221373727
>>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
>>> t
-2.8207540608310198
>>> import matplotlib.pyplot as plt
>>> s = np.random.standard_t(10, size=1000000)
>>> h = plt.hist(s, bins=100, density=True)
>>> np.sum(np.abs(t) < np.abs(s)) / float(len(s))
0.018318  #random < 0.05, statistic is in critical region"
numpy.random.RandomState.triangular,method,"[{'Parameters': [{'name': 'left', 'type': 'float or array_like of floats', 'description': 'Lower limit.'}, {'name': 'mode', 'type': 'float or array_like of floats', 'description': 'The value where the peak of the distribution occurs.The value must fulfill the condition left <= mode <= right.'}, {'name': 'right', 'type': 'float or array_like of floats', 'description': 'Upper limit, must be larger than left.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if left, mode, and rightare all scalars.  Otherwise, np.broadcast(left, mode, right).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized triangular distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
...              density=True)
>>> plt.show()"
numpy.random.RandomState.uniform,method,"[{'Parameters': [{'name': 'low', 'type': 'float or array_like of floats, optional', 'description': 'Lower boundary of the output interval.  All values generated will begreater than or equal to low.  The default value is 0.'}, {'name': 'high', 'type': 'float or array_like of floats', 'description': 'Upper boundary of the output interval.  All values generated will beless than or equal to high.  The high limit may be included in the returned array of floats due to floating-point rounding in the equation low + (high-low) * random_sample().  The default value is 1.0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if low and high are both scalars.Otherwise, np.broadcast(low, high).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized uniform distribution.'}]}]",">>> x = np.float32(5*0.99999999)
>>> x
np.float32(5.0)
>>> s = np.random.uniform(-1,0,1000)
>>> np.all(s >= -1)
True
>>> np.all(s < 0)
True
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 15, density=True)
>>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
>>> plt.show()"
numpy.random.RandomState.vonmises,method,"[{'Parameters': [{'name': 'mu', 'type': 'float or array_like of floats', 'description': 'Mode (“center”) of the distribution.'}, {'name': 'kappa', 'type': 'float or array_like of floats', 'description': 'Concentration of the distribution, has to be >=0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mu and kappa are both scalars.Otherwise, np.broadcast(mu, kappa).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized von Mises distribution.'}]}]",">>> mu, kappa = 0.0, 4.0 # mean and concentration
>>> s = np.random.vonmises(mu, kappa, 1000)
>>> import matplotlib.pyplot as plt
>>> from scipy.special import i0  
>>> plt.hist(s, 50, density=True)
>>> x = np.linspace(-np.pi, np.pi, num=51)
>>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  
>>> plt.plot(x, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.RandomState.wald,method,"[{'Parameters': [{'name': 'mean', 'type': 'float or array_like of floats', 'description': 'Distribution mean, must be > 0.'}, {'name': 'scale', 'type': 'float or array_like of floats', 'description': 'Scale parameter, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mean and scale are both scalars.Otherwise, np.broadcast(mean, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Wald distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)
>>> plt.show()"
numpy.random.RandomState.weibull,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Shape parameter of the distribution.  Must be nonnegative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Weibull distribution.'}]}]",">>> a = 5. # shape
>>> s = np.random.weibull(a, 1000)
>>> import matplotlib.pyplot as plt
>>> x = np.arange(1,100.)/50.
>>> def weib(x,n,a):
...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)
>>> count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
>>> x = np.arange(1,100.)/50.
>>> scale = count.max()/weib(x, 1., 5.).max()
>>> plt.plot(x, weib(x, 1., 5.)*scale)
>>> plt.show()"
numpy.random.RandomState.zipf,method,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Distribution parameter. Must be greater than 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar. Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Zipf distribution.'}]}]",">>> a = 4.0
>>> n = 20000
>>> s = np.random.zipf(a, n)
>>> import matplotlib.pyplot as plt
>>> from scipy.special import zeta
>>> count = np.bincount(s)
>>> k = np.arange(1, s.max() + 1)
>>> plt.bar(k, count[1:], alpha=0.5, label='sample count')
>>> plt.plot(k, n*(k**-a)/zeta(a), 'k.-', alpha=0.5,
...          label='expected count')   
>>> plt.semilogy()
>>> plt.grid(alpha=0.4)
>>> plt.legend()
>>> plt.title(f'Zipf sample, a={a}, size={n}')
>>> plt.show()"
numpy.random.beta,Draw samples from a Beta distribution.,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Alpha, positive (>0).'}, {'name': 'b', 'type': 'float or array_like of floats', 'description': 'Beta, positive (>0).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a and b are both scalars.Otherwise, np.broadcast(a, b).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized beta distribution.'}]}]",
numpy.random.binomial,Draw samples from a binomial distribution.,"[{'Parameters': [{'name': 'n', 'type': 'int or array_like of ints', 'description': 'Parameter of the distribution, >= 0. Floats are also accepted,but they will be truncated to integers.'}, {'name': 'p', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, >= 0 and <=1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if n and p are both scalars.Otherwise, np.broadcast(n, p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized binomial distribution, whereeach sample is equal to the number of successes over the n trials.'}]}]",">>> n, p = 10, .5  # number of trials, probability of each trial
>>> s = np.random.binomial(n, p, 1000)
# result of flipping a coin 10 times, tested 1000 times.
>>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
# answer = 0.38885, or 38%."
numpy.random.bytes,Return random bytes.,"[{'Parameters': [{'name': 'length', 'type': 'int', 'description': 'Number of random bytes.'}]}, {'Returns': [{'name': 'out', 'type': 'bytes', 'description': 'String of length length.'}]}]",">>> np.random.bytes(10)
b' eh\x85\x022SZ\xbf\xa4' #random"
numpy.random.chisquare,Draw samples from a chi-square distribution.,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Number of degrees of freedom, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df is a scalar.  Otherwise,np.array(df).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized chi-square distribution.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'When df <= 0 or when an inappropriate size (e.g. size=-1)is given.'}]}]",">>> np.random.chisquare(2,4)
array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random"
numpy.random.choice,Generates a random sample from a given 1-D array,"[{'Parameters': [{'name': 'a', 'type': '1-D array-like or int', 'description': 'If an ndarray, a random sample is generated from its elements.If an int, the random sample is generated as if it were np.arange(a)'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'replace', 'type': 'boolean, optional', 'description': 'Whether the sample is with or without replacement. Default is True,meaning that a value of a can be selected multiple times.'}, {'name': 'p', 'type': '1-D array-like, optional', 'description': 'The probabilities associated with each entry in a.If not given, the sample assumes a uniform distribution over allentries in a.'}]}, {'Returns': [{'name': 'samples', 'type': 'single item or ndarray', 'description': 'The generated random samples'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If a is an int and less than zero, if a or p are not 1-dimensional,if a is an array-like of size 0, if p is not a vector ofprobabilities, if a and p have different lengths, or ifreplace=False and the sample size is greater than the populationsize'}]}]",">>> np.random.choice(5, 3)
array([0, 3, 4]) # random
>>> #This is equivalent to np.random.randint(0,5,3)
>>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
array([3, 3, 0]) # random
>>> np.random.choice(5, 3, replace=False)
array([3,1,0]) # random
>>> #This is equivalent to np.random.permutation(np.arange(5))[:3]
>>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
array([2, 3, 0]) # random
>>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
>>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random
      dtype='<U11')"
numpy.random.dirichlet,Draw samples from the Dirichlet distribution.,"[{'Parameters': [{'name': 'alpha', 'type': 'sequence of floats, length k', 'description': 'Parameter of the distribution (length k for sample oflength k).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n), thenm * n * k samples are drawn.  Default is None, in which case avector of length k is returned.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray,', 'description': 'The drawn samples, of shape (size, k).'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If any value in alpha is less than or equal to zero'}]}]",">>> s = np.random.dirichlet((10, 5, 3), 20).transpose()
>>> import matplotlib.pyplot as plt
>>> plt.barh(range(20), s[0])
>>> plt.barh(range(20), s[1], left=s[0], color='g')
>>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
>>> plt.title(""Lengths of Strings"")"
numpy.random.exponential,Draw samples from an exponential distribution.,"[{'Parameters': [{'name': 'scale', 'type': 'float or array_like of floats', 'description': 'The scale parameter, \\(\\beta = 1/\\lambda\\). Must benon-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if scale is a scalar.  Otherwise,np.array(scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized exponential distribution.'}]}]",">>> n = 10000
>>> time_between_calls = np.random.default_rng().exponential(scale=4, size=n)
>>> x = ((time_between_calls < 5).sum())/n 
>>> y = ((time_between_calls < 4).sum())/n
>>> x-y
0.08 # may vary"
numpy.random.f,Draw samples from an F distribution.,"[{'Parameters': [{'name': 'dfnum', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom in numerator, must be > 0.'}, {'name': 'dfden', 'type': 'float or array_like of float', 'description': 'Degrees of freedom in denominator, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if dfnum and dfden are both scalars.Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Fisher distribution.'}]}]",">>> dfnum = 1. # between group degrees of freedom
>>> dfden = 48. # within groups degrees of freedom
>>> s = np.random.f(dfnum, dfden, 1000)
>>> np.sort(s)[-10]
7.61988120985 # random"
numpy.random.gamma,Draw samples from a Gamma distribution.,"[{'Parameters': [{'name': 'shape', 'type': 'float or array_like of floats', 'description': 'The shape of the gamma distribution. Must be non-negative.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'The scale of the gamma distribution. Must be non-negative.Default is equal to 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if shape and scale are both scalars.Otherwise, np.broadcast(shape, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized gamma distribution.'}]}]",">>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
>>> s = np.random.gamma(shape, scale, 1000)
>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1)*(np.exp(-bins/scale) /  
...                      (sps.gamma(shape)*scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.geometric,Draw samples from the geometric distribution.,"[{'Parameters': [{'name': 'p', 'type': 'float or array_like of floats', 'description': 'The probability of success of an individual trial.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if p is a scalar.  Otherwise,np.array(p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized geometric distribution.'}]}]",">>> z = np.random.geometric(p=0.35, size=10000)
>>> (z == 1).sum() / 10000.
0.34889999999999999 #random"
numpy.random.get_state,Return a tuple representing the internal state of the generator.,"[{'Parameters': [{'name': 'legacy', 'type': 'bool, optional', 'description': 'Flag indicating to return a legacy tuple state when the BitGeneratoris MT19937, instead of a dict. Raises ValueError if the underlyingbit generator is not an instance of MT19937.'}]}, {'Returns': [{'name': 'out', 'type': '{tuple(str, ndarray of 624 uints, int, int, float), dict}', 'description': 'If legacy is True, the returned tuple has the following items:the string ‘MT19937’.a 1-D array of 624 unsigned integer keys.an integer pos.an integer has_gauss.a float cached_gaussian.If legacy is False, or the BitGenerator is not MT19937, thenstate is returned as a dictionary.'}]}]",
numpy.random.gumbel,Draw samples from a Gumbel distribution.,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'The location of the mode of the distribution. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'The scale parameter of the distribution. Default is 1. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Gumbel distribution.'}]}]",">>> mu, beta = 0, 0.1 # location and scale
>>> s = np.random.gumbel(mu, beta, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp( -np.exp( -(bins - mu) /beta) ),
...          linewidth=2, color='r')
>>> plt.show()
>>> means = []
>>> maxima = []
>>> for i in range(0,1000) :
...    a = np.random.normal(mu, beta, 1000)
...    means.append(a.mean())
...    maxima.append(a.max())
>>> count, bins, ignored = plt.hist(maxima, 30, density=True)
>>> beta = np.std(maxima) * np.sqrt(6) / np.pi
>>> mu = np.mean(maxima) - 0.57721*beta
>>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
...          * np.exp(-np.exp(-(bins - mu)/beta)),
...          linewidth=2, color='r')
>>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
...          linewidth=2, color='g')
>>> plt.show()"
numpy.random.hypergeometric,Draw samples from a Hypergeometric distribution.,"[{'Parameters': [{'name': 'ngood', 'type': 'int or array_like of ints', 'description': 'Number of ways to make a good selection.  Must be nonnegative.'}, {'name': 'nbad', 'type': 'int or array_like of ints', 'description': 'Number of ways to make a bad selection.  Must be nonnegative.'}, {'name': 'nsample', 'type': 'int or array_like of ints', 'description': 'Number of items sampled.  Must be at least 1 and at mostngood + nbad.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if ngood, nbad, and nsampleare all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized hypergeometric distribution. Eachsample is the number of good items within a randomly selected subset ofsize nsample taken from a set of ngood good items and nbad bad items.'}]}]",">>> ngood, nbad, nsamp = 100, 2, 10
# number of good, number of bad, and number of samples
>>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
>>> from matplotlib.pyplot import hist
>>> hist(s)
#   note that it is very unlikely to grab both bad items
>>> s = np.random.hypergeometric(15, 15, 15, 100000)
>>> sum(s>=12)/100000. + sum(s<=3)/100000.
#   answer = 0.003 ... pretty unlikely!"
numpy.random.laplace,"Draw samples from the Laplace or double exponential distribution with
specified location (or mean) and scale (decay).","[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'The position, \\(\\mu\\), of the distribution peak. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': '\\(\\lambda\\), the exponential decay. Default is 1. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Laplace distribution.'}]}]",">>> loc, scale = 0., 1.
>>> s = np.random.laplace(loc, scale, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> x = np.arange(-8., 8., .01)
>>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
>>> plt.plot(x, pdf)
>>> g = (1/(scale * np.sqrt(2 * np.pi)) *
...      np.exp(-(x - loc)**2 / (2 * scale**2)))
>>> plt.plot(x,g)"
numpy.random.logistic,Draw samples from a logistic distribution.,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats, optional', 'description': 'Parameter of the distribution. Default is 0.'}, {'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'Parameter of the distribution. Must be non-negative.Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized logistic distribution.'}]}]",">>> loc, scale = 10, 1
>>> s = np.random.logistic(loc, scale, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=50)
>>> def logist(x, loc, scale):
...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)
>>> lgst_val = logist(bins, loc, scale)
>>> plt.plot(bins, lgst_val * count.max() / lgst_val.max())
>>> plt.show()"
numpy.random.lognormal,Draw samples from a log-normal distribution.,"[{'Parameters': [{'name': 'mean', 'type': 'float or array_like of floats, optional', 'description': 'Mean value of the underlying normal distribution. Default is 0.'}, {'name': 'sigma', 'type': 'float or array_like of floats, optional', 'description': 'Standard deviation of the underlying normal distribution. Must benon-negative. Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mean and sigma are both scalars.Otherwise, np.broadcast(mean, sigma).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized log-normal distribution.'}]}]",">>> mu, sigma = 3., 1. # mean and standard deviation
>>> s = np.random.lognormal(mu, sigma, 1000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 100, density=True, align='mid')
>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))
>>> plt.plot(x, pdf, linewidth=2, color='r')
>>> plt.axis('tight')
>>> plt.show()
>>> # Generate a thousand samples: each is the product of 100 random
>>> # values, drawn from a normal distribution.
>>> b = []
>>> for i in range(1000):
...    a = 10. + np.random.standard_normal(100)
...    b.append(np.prod(a))
>>> b = np.array(b) / np.min(b) # scale values to be positive
>>> count, bins, ignored = plt.hist(b, 100, density=True, align='mid')
>>> sigma = np.std(np.log(b))
>>> mu = np.mean(np.log(b))
>>> x = np.linspace(min(bins), max(bins), 10000)
>>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
...        / (x * sigma * np.sqrt(2 * np.pi)))
>>> plt.plot(x, pdf, color='r', linewidth=2)
>>> plt.show()"
numpy.random.logseries,Draw samples from a logarithmic series distribution.,"[{'Parameters': [{'name': 'p', 'type': 'float or array_like of floats', 'description': 'Shape parameter for the distribution.  Must be in the range [0, 1).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if p is a scalar.  Otherwise,np.array(p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized logarithmic series distribution.'}]}]",">>> a = .6
>>> s = np.random.logseries(a, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s)
>>> def logseries(k, p):
...     return -p**k/(k*np.log(1-p))
>>> plt.plot(bins, logseries(bins, a)*count.max()/
...          logseries(bins, a).max(), 'r')
>>> plt.show()"
numpy.random.multinomial,Draw samples from a multinomial distribution.,"[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'Number of experiments.'}, {'name': 'pvals', 'type': 'sequence of floats, length p', 'description': 'Probabilities of each of the p different outcomes.  Thesemust sum to 1 (however, the last element is always assumed toaccount for the remaining probability, as long assum(pvals[:-1]) <= 1).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.'}]}]",">>> np.random.multinomial(20, [1/6.]*6, size=1)
array([[4, 1, 7, 5, 2, 1]]) # random
>>> np.random.multinomial(20, [1/6.]*6, size=2)
array([[3, 4, 3, 3, 4, 3], # random
       [2, 4, 3, 4, 0, 7]])
>>> np.random.multinomial(100, [1/7.]*5 + [2/7.])
array([11, 16, 14, 17, 16, 26]) # random
>>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
array([38, 62]) # random
>>> np.random.multinomial(100, [1.0, 2.0])  # WRONG
Traceback (most recent call last):
ValueError: pvals < 0, pvals > 1 or pvals contains NaNs"
numpy.random.multivariate_normal,Draw random samples from a multivariate normal distribution.,"[{'Parameters': [{'name': 'mean', 'type': '1-D array_like, of length N', 'description': 'Mean of the N-dimensional distribution.'}, {'name': 'cov', 'type': '2-D array_like, of shape (N, N)', 'description': 'Covariance matrix of the distribution. It must be symmetric andpositive-semidefinite for proper sampling.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Given a shape of, for example, (m,n,k), m*n*k samples aregenerated, and packed in an m-by-n-by-k arrangement.  Becauseeach sample is N-dimensional, the output shape is (m,n,k,N).If no shape is specified, a single (N-D) sample is returned.'}, {'name': 'check_valid', 'type': '{ ‘warn’, ‘raise’, ‘ignore’ }, optional', 'description': 'Behavior when the covariance matrix is not positive semidefinite.'}, {'name': 'tol', 'type': 'float, optional', 'description': 'Tolerance when checking the singular values in covariance matrix.cov is cast to double before the check.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.'}]}]",">>> mean = [0, 0]
>>> cov = [[1, 0], [0, 100]]  # diagonal covariance
>>> import matplotlib.pyplot as plt
>>> x, y = np.random.multivariate_normal(mean, cov, 5000).T
>>> plt.plot(x, y, 'x')
>>> plt.axis('equal')
>>> plt.show()
>>> mean = (1, 2)
>>> cov = [[1, 0], [0, 1]]
>>> x = np.random.multivariate_normal(mean, cov, (3, 3))
>>> x.shape
(3, 3, 2)
>>> cov = np.array([[6, -3], [-3, 3.5]])
>>> pts = np.random.multivariate_normal([0, 0], cov, size=800)
>>> pts.mean(axis=0)
array([ 0.0326911 , -0.01280782])  # may vary
>>> np.cov(pts.T)
array([[ 5.96202397, -2.85602287],
       [-2.85602287,  3.47613949]])  # may vary
>>> np.corrcoef(pts.T)[0, 1]
-0.6273591314603949  # may vary
>>> import matplotlib.pyplot as plt
>>> plt.plot(pts[:, 0], pts[:, 1], '.', alpha=0.5)
>>> plt.axis('equal')
>>> plt.grid()
>>> plt.show()"
numpy.random.negative_binomial,Draw samples from a negative binomial distribution.,"[{'Parameters': [{'name': 'n', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, > 0.'}, {'name': 'p', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution, >= 0 and <=1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if n and p are both scalars.Otherwise, np.broadcast(n, p).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized negative binomial distribution,where each sample is equal to N, the number of failures thatoccurred before a total of n successes was reached.'}]}]",">>> s = np.random.negative_binomial(1, 0.1, 100000)
>>> for i in range(1, 11): 
...    probability = sum(s<i) / 100000.
...    print(i, ""wells drilled, probability of one success ="", probability)"
numpy.random.noncentral_chisquare,Draw samples from a noncentral chi-square distribution.,"[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom, must be > 0.'}, {'name': 'nonc', 'type': 'float or array_like of floats', 'description': 'Non-centrality, must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df and nonc are both scalars.Otherwise, np.broadcast(df, nonc).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized noncentral chi-square distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()
>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
...                   bins=np.arange(0., 25, .1), density=True)
>>> values2 = plt.hist(np.random.chisquare(3, 100000),
...                    bins=np.arange(0., 25, .1), density=True)
>>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
>>> plt.show()
>>> plt.figure()
>>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
...                   bins=200, density=True)
>>> plt.show()"
numpy.random.noncentral_f,Draw samples from the noncentral F distribution.,"[{'Parameters': [{'name': 'dfnum', 'type': 'float or array_like of floats', 'description': 'Numerator degrees of freedom, must be > 0.'}, {'name': 'dfden', 'type': 'float or array_like of floats', 'description': 'Denominator degrees of freedom, must be > 0.'}, {'name': 'nonc', 'type': 'float or array_like of floats', 'description': 'Non-centrality parameter, the sum of the squares of the numeratormeans, must be >= 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if dfnum, dfden, and noncare all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized noncentral Fisher distribution.'}]}]",">>> dfnum = 3 # between group deg of freedom
>>> dfden = 20 # within groups degrees of freedom
>>> nonc = 3.0
>>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
>>> NF = np.histogram(nc_vals, bins=50, density=True)
>>> c_vals = np.random.f(dfnum, dfden, 1000000)
>>> F = np.histogram(c_vals, bins=50, density=True)
>>> import matplotlib.pyplot as plt
>>> plt.plot(F[1][1:], F[0])
>>> plt.plot(NF[1][1:], NF[0])
>>> plt.show()"
numpy.random.normal,Draw random samples from a normal (Gaussian) distribution.,"[{'Parameters': [{'name': 'loc', 'type': 'float or array_like of floats', 'description': 'Mean (“centre”) of the distribution.'}, {'name': 'scale', 'type': 'float or array_like of floats', 'description': 'Standard deviation (spread or “width”) of the distribution. Must benon-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if loc and scale are both scalars.Otherwise, np.broadcast(loc, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized normal distribution.'}]}]",">>> mu, sigma = 0, 0.1 # mean and standard deviation
>>> s = np.random.normal(mu, sigma, 1000)
>>> abs(mu - np.mean(s))
0.0  # may vary
>>> abs(sigma - np.std(s, ddof=1))
0.1  # may vary
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 30, density=True)
>>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
...          linewidth=2, color='r')
>>> plt.show()
>>> np.random.normal(3, 2.5, size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.pareto,"Draw samples from a Pareto II or Lomax distribution with
specified shape.","[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Shape of the distribution. Must be positive.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Pareto distribution.'}]}]",">>> a, m = 3., 2.  # shape and mode
>>> s = (np.random.pareto(a, 1000) + 1) * m
>>> import matplotlib.pyplot as plt
>>> count, bins, _ = plt.hist(s, 100, density=True)
>>> fit = a*m**a / bins**(a+1)
>>> plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
>>> plt.show()"
numpy.random.permutation,"Randomly permute a sequence, or return a permuted range.","[{'Parameters': [{'name': 'x', 'type': 'int or array_like', 'description': 'If x is an integer, randomly permute np.arange(x).If x is an array, make a copy and shuffle the elementsrandomly.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Permuted sequence or array range.'}]}]",">>> np.random.permutation(10)
array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random
>>> np.random.permutation([1, 4, 9, 12, 15])
array([15,  1,  9,  4, 12]) # random
>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.permutation(arr)
array([[6, 7, 8], # random
       [0, 1, 2],
       [3, 4, 5]])"
numpy.random.poisson,Draw samples from a Poisson distribution.,"[{'Parameters': [{'name': 'lam', 'type': 'float or array_like of floats', 'description': 'Expected number of events occurring in a fixed-time interval,must be >= 0. A sequence must be broadcastable over the requestedsize.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if lam is a scalar. Otherwise,np.array(lam).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Poisson distribution.'}]}]",">>> import numpy as np
>>> s = np.random.poisson(5, 10000)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 14, density=True)
>>> plt.show()
>>> s = np.random.poisson(lam=(100., 500.), size=(100, 2))"
numpy.random.power,"Draws samples in [0, 1] from a power distribution with positive
exponent a - 1.","[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Parameter of the distribution. Must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized power distribution.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If a <= 0.'}]}]",">>> a = 5. # shape
>>> samples = 1000
>>> s = np.random.power(a, samples)
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, bins=30)
>>> x = np.linspace(0, 1, 100)
>>> y = a*x**(a-1.)
>>> normed_y = samples*np.diff(bins)[0]*y
>>> plt.plot(x, normed_y)
>>> plt.show()
>>> from scipy import stats 
>>> rvs = np.random.power(5, 1000000)
>>> rvsp = np.random.pareto(5, 1000000)
>>> xx = np.linspace(0,1,100)
>>> powpdf = stats.powerlaw.pdf(xx,5)
>>> plt.figure()
>>> plt.hist(rvs, bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('np.random.power(5)')
>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('inverse of 1 + np.random.pareto(5)')
>>> plt.figure()
>>> plt.hist(1./(1.+rvsp), bins=50, density=True)
>>> plt.plot(xx,powpdf,'r-')  
>>> plt.title('inverse of stats.pareto(5)')"
numpy.random.rand,Random values in a given shape.,"[{'Parameters': [{'name': 'd0, d1, …, dn', 'type': 'int, optional', 'description': 'The dimensions of the returned array, must be non-negative.If no argument is given a single Python float is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray, shape (d0, d1, ..., dn)', 'description': 'Random values.'}]}]",">>> np.random.rand(3,2)
array([[ 0.14022471,  0.96360618],  #random
       [ 0.37601032,  0.25528411],  #random
       [ 0.49313049,  0.94909878]]) #random"
numpy.random.randint,Return random integers from low (inclusive) to high (exclusive).,"[{'Parameters': [{'name': 'low', 'type': 'int or array-like of ints', 'description': 'Lowest (signed) integers to be drawn from the distribution (unlesshigh=None, in which case this parameter is one above thehighest such integer).'}, {'name': 'high', 'type': 'int or array-like of ints, optional', 'description': 'If provided, one above the largest (signed) integer to be drawnfrom the distribution (see above for behavior if high=None).If array-like, must contain integer values'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Desired dtype of the result. Byteorder must be native.The default value is long.WarningThis function defaults to the C-long dtype, which is 32bit on windowsand otherwise 64bit on 64bit platforms (and 32bit on 32bit ones).Since NumPy 2.0, NumPy’s default integer is 32bit on 32bit platformsand 64bit on 64bit platforms.  Which corresponds to np.intp.(dtype=int is not the same as in most NumPy functions.)'}]}, {'Returns': [{'name': 'out', 'type': 'int or ndarray of ints', 'description': 'size-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.'}]}]",">>> np.random.randint(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random
>>> np.random.randint(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
>>> np.random.randint(5, size=(2, 4))
array([[4, 0, 2, 1], # random
       [3, 2, 2, 0]])
>>> np.random.randint(1, [3, 5, 10])
array([2, 2, 9]) # random
>>> np.random.randint([1, 5, 7], 10)
array([9, 8, 7]) # random
>>> np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)
array([[ 8,  6,  9,  7], # random
       [ 1, 16,  9, 12]], dtype=uint8)"
numpy.random.randn,Return a sample (or samples) from the “standard normal” distribution.,"[{'Parameters': [{'name': 'd0, d1, …, dn', 'type': 'int, optional', 'description': 'The dimensions of the returned array, must be non-negative.If no argument is given a single Python float is returned.'}]}, {'Returns': [{'name': 'Z', 'type': 'ndarray or float', 'description': 'A (d0, d1, ..., dn)-shaped array of floating-point samples fromthe standard normal distribution, or a single such float ifno parameters were supplied.'}]}]",">>> np.random.randn()
2.1923875335537315  # random
>>> 3 + 2.5 * np.random.randn(2, 4)
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.random,"Return random floats in the half-open interval [0.0, 1.0). Alias for
random_sample to ease forward-porting to the new random API.",[],
numpy.random.random_integers,"Random integers of type numpy.int_ between low and high, inclusive.","[{'Parameters': [{'name': 'low', 'type': 'int', 'description': 'Lowest (signed) integer to be drawn from the distribution (unlesshigh=None, in which case this parameter is the highest suchinteger).'}, {'name': 'high', 'type': 'int, optional', 'description': 'If provided, the largest (signed) integer to be drawn from thedistribution (see above for behavior if high=None).'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'int or ndarray of ints', 'description': 'size-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.'}]}]",">>> np.random.random_integers(5)
4 # random
>>> type(np.random.random_integers(5))
<class 'numpy.int64'>
>>> np.random.random_integers(5, size=(3,2))
array([[5, 4], # random
       [3, 3],
       [4, 5]])
>>> 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random
>>> d1 = np.random.random_integers(1, 6, 1000)
>>> d2 = np.random.random_integers(1, 6, 1000)
>>> dsums = d1 + d2
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(dsums, 11, density=True)
>>> plt.show()"
numpy.random.random_sample,"Return random floats in the half-open interval [0.0, 1.0).","[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray of floats', 'description': 'Array of random floats of shape size (unless size=None, in whichcase a single float is returned).'}]}]",">>> np.random.random_sample()
0.47108547995356098 # random
>>> type(np.random.random_sample())
<class 'float'>
>>> np.random.random_sample((5,))
array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random
>>> 5 * np.random.random_sample((3, 2)) - 5
array([[-3.99149989, -0.52338984], # random
       [-2.99091858, -0.79479508],
       [-1.23204345, -1.75224494]])"
numpy.random.ranf,"This is an alias of random_sample. See random_sample  for the complete
documentation.",[],
numpy.random.rayleigh,Draw samples from a Rayleigh distribution.,"[{'Parameters': [{'name': 'scale', 'type': 'float or array_like of floats, optional', 'description': 'Scale, also equals the mode. Must be non-negative. Default is 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if scale is a scalar.  Otherwise,np.array(scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Rayleigh distribution.'}]}]",">>> from matplotlib.pyplot import hist
>>> values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)
>>> meanvalue = 1
>>> modevalue = np.sqrt(2 / np.pi) * meanvalue
>>> s = np.random.rayleigh(modevalue, 1000000)
>>> 100.*sum(s>3)/1000000.
0.087300000000000003 # random"
numpy.random.sample,"This is an alias of random_sample. See random_sample  for the complete
documentation.",[],
numpy.random.seed,Reseed the singleton RandomState instance.,[],
numpy.random.set_state,Set the internal state of the generator from a tuple.,"[{'Parameters': [{'name': 'state', 'type': '{tuple(str, ndarray of 624 uints, int, int, float), dict}', 'description': 'The state tuple has the following items:the string ‘MT19937’, specifying the Mersenne Twister algorithm.a 1-D array of 624 unsigned integers keys.an integer pos.an integer has_gauss.a float cached_gaussian.If state is a dictionary, it is directly set using the BitGeneratorsstate property.'}]}, {'Returns': [{'name': 'out', 'type': 'None', 'description': 'Returns ‘None’ on success.'}]}]",
numpy.random.shuffle,Modify a sequence in-place by shuffling its contents.,"[{'Parameters': [{'name': 'x', 'type': 'ndarray or MutableSequence', 'description': 'The array, list or mutable sequence to be shuffled.'}]}, {'Returns': [{'name': 'None', 'type': None, 'description': ''}]}]",">>> arr = np.arange(10)
>>> np.random.shuffle(arr)
>>> arr
[1 7 5 2 9 4 3 6 0 8] # random
>>> arr = np.arange(9).reshape((3, 3))
>>> np.random.shuffle(arr)
>>> arr
array([[3, 4, 5], # random
       [6, 7, 8],
       [0, 1, 2]])"
numpy.random.standard_cauchy,Draw samples from a standard Cauchy distribution with mode = 0.,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'samples', 'type': 'ndarray or scalar', 'description': 'The drawn samples.'}]}]",">>> import matplotlib.pyplot as plt
>>> s = np.random.standard_cauchy(1000000)
>>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
>>> plt.hist(s, bins=100)
>>> plt.show()"
numpy.random.standard_exponential,Draw samples from the standard exponential distribution.,"[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray', 'description': 'Drawn samples.'}]}]",">>> n = np.random.standard_exponential((3, 8000))"
numpy.random.standard_gamma,Draw samples from a standard Gamma distribution.,"[{'Parameters': [{'name': 'shape', 'type': 'float or array_like of floats', 'description': 'Parameter, must be non-negative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if shape is a scalar.  Otherwise,np.array(shape).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized standard gamma distribution.'}]}]",">>> shape, scale = 2., 1. # mean and width
>>> s = np.random.standard_gamma(shape, 1000000)
>>> import matplotlib.pyplot as plt
>>> import scipy.special as sps  
>>> count, bins, ignored = plt.hist(s, 50, density=True)
>>> y = bins**(shape-1) * ((np.exp(-bins/scale))/  
...                       (sps.gamma(shape) * scale**shape))
>>> plt.plot(bins, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.standard_normal,"Draw samples from a standard Normal distribution (mean=0, stdev=1).","[{'Parameters': [{'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  Default is None, in which case asingle value is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'float or ndarray', 'description': 'A floating-point array of shape size of drawn samples, or asingle sample if size was not specified.'}]}]",">>> np.random.standard_normal()
2.1923875335537315 #random
>>> s = np.random.standard_normal(8000)
>>> s
array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
       -0.38672696, -0.4685006 ])                                # random
>>> s.shape
(8000,)
>>> s = np.random.standard_normal(size=(3, 4, 2))
>>> s.shape
(3, 4, 2)
>>> 3 + 2.5 * np.random.standard_normal(size=(2, 4))
array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random"
numpy.random.standard_t,"Draw samples from a standard Student’s t distribution with df degrees
of freedom.","[{'Parameters': [{'name': 'df', 'type': 'float or array_like of floats', 'description': 'Degrees of freedom, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if df is a scalar.  Otherwise,np.array(df).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized standard Student’s t distribution.'}]}]",">>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
...                    7515, 8230, 8770])
>>> np.mean(intake)
6753.636363636364
>>> intake.std(ddof=1)
1142.1232221373727
>>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
>>> t
-2.8207540608310198
>>> import matplotlib.pyplot as plt
>>> s = np.random.standard_t(10, size=1000000)
>>> h = plt.hist(s, bins=100, density=True)
>>> np.sum(np.abs(t) < np.abs(s)) / float(len(s))
0.018318  #random < 0.05, statistic is in critical region"
numpy.random.triangular,"Draw samples from the triangular distribution over the
interval [left, right].","[{'Parameters': [{'name': 'left', 'type': 'float or array_like of floats', 'description': 'Lower limit.'}, {'name': 'mode', 'type': 'float or array_like of floats', 'description': 'The value where the peak of the distribution occurs.The value must fulfill the condition left <= mode <= right.'}, {'name': 'right', 'type': 'float or array_like of floats', 'description': 'Upper limit, must be larger than left.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if left, mode, and rightare all scalars.  Otherwise, np.broadcast(left, mode, right).sizesamples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized triangular distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
...              density=True)
>>> plt.show()"
numpy.random.uniform,Draw samples from a uniform distribution.,"[{'Parameters': [{'name': 'low', 'type': 'float or array_like of floats, optional', 'description': 'Lower boundary of the output interval.  All values generated will begreater than or equal to low.  The default value is 0.'}, {'name': 'high', 'type': 'float or array_like of floats', 'description': 'Upper boundary of the output interval.  All values generated will beless than or equal to high.  The high limit may be included in the returned array of floats due to floating-point rounding in the equation low + (high-low) * random_sample().  The default value is 1.0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if low and high are both scalars.Otherwise, np.broadcast(low, high).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized uniform distribution.'}]}]",">>> x = np.float32(5*0.99999999)
>>> x
np.float32(5.0)
>>> s = np.random.uniform(-1,0,1000)
>>> np.all(s >= -1)
True
>>> np.all(s < 0)
True
>>> import matplotlib.pyplot as plt
>>> count, bins, ignored = plt.hist(s, 15, density=True)
>>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
>>> plt.show()"
numpy.random.vonmises,Draw samples from a von Mises distribution.,"[{'Parameters': [{'name': 'mu', 'type': 'float or array_like of floats', 'description': 'Mode (“center”) of the distribution.'}, {'name': 'kappa', 'type': 'float or array_like of floats', 'description': 'Concentration of the distribution, has to be >=0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mu and kappa are both scalars.Otherwise, np.broadcast(mu, kappa).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized von Mises distribution.'}]}]",">>> mu, kappa = 0.0, 4.0 # mean and concentration
>>> s = np.random.vonmises(mu, kappa, 1000)
>>> import matplotlib.pyplot as plt
>>> from scipy.special import i0  
>>> plt.hist(s, 50, density=True)
>>> x = np.linspace(-np.pi, np.pi, num=51)
>>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  
>>> plt.plot(x, y, linewidth=2, color='r')  
>>> plt.show()"
numpy.random.wald,"Draw samples from a Wald, or inverse Gaussian, distribution.","[{'Parameters': [{'name': 'mean', 'type': 'float or array_like of floats', 'description': 'Distribution mean, must be > 0.'}, {'name': 'scale', 'type': 'float or array_like of floats', 'description': 'Scale parameter, must be > 0.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if mean and scale are both scalars.Otherwise, np.broadcast(mean, scale).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Wald distribution.'}]}]",">>> import matplotlib.pyplot as plt
>>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)
>>> plt.show()"
numpy.random.weibull,Draw samples from a Weibull distribution.,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Shape parameter of the distribution.  Must be nonnegative.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar.  Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Weibull distribution.'}]}]",">>> a = 5. # shape
>>> s = np.random.weibull(a, 1000)
>>> import matplotlib.pyplot as plt
>>> x = np.arange(1,100.)/50.
>>> def weib(x,n,a):
...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)
>>> count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
>>> x = np.arange(1,100.)/50.
>>> scale = count.max()/weib(x, 1., 5.).max()
>>> plt.plot(x, weib(x, 1., 5.)*scale)
>>> plt.show()"
numpy.random.zipf,Draw samples from a Zipf distribution.,"[{'Parameters': [{'name': 'a', 'type': 'float or array_like of floats', 'description': 'Distribution parameter. Must be greater than 1.'}, {'name': 'size', 'type': 'int or tuple of ints, optional', 'description': 'Output shape.  If the given shape is, e.g., (m, n, k), thenm * n * k samples are drawn.  If size is None (default),a single value is returned if a is a scalar. Otherwise,np.array(a).size samples are drawn.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Drawn samples from the parameterized Zipf distribution.'}]}]",">>> a = 4.0
>>> n = 20000
>>> s = np.random.zipf(a, n)
>>> import matplotlib.pyplot as plt
>>> from scipy.special import zeta
>>> count = np.bincount(s)
>>> k = np.arange(1, s.max() + 1)
>>> plt.bar(k, count[1:], alpha=0.5, label='sample count')
>>> plt.plot(k, n*(k**-a)/zeta(a), 'k.-', alpha=0.5,
...          label='expected count')   
>>> plt.semilogy()
>>> plt.grid(alpha=0.4)
>>> plt.legend()
>>> plt.title(f'Zipf sample, a={a}, size={n}')
>>> plt.show()"
class numpy.random.PCG64(seed=None),BitGenerator for the PCG-64 pseudo-random number generator.,"[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like[ints], SeedSequence}, optional', 'description': 'A seed to initialize the BitGenerator. If None, then fresh,unpredictable entropy will be pulled from the OS. If an int orarray_like[ints] is passed, then it will be passed toSeedSequence to derive the initial BitGenerator state. One may alsopass in a SeedSequence instance.'}]}]",">>> from numpy.random import Generator, PCG64, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(PCG64(s)) for s in sg.spawn(10)]"
numpy.random.PCG64.state,attribute,"[{'Returns': [{'name': 'state', 'type': 'dict', 'description': 'Dictionary containing the information required to describe thestate of the PRNG'}]}]",
numpy.random.PCG64.advance,method,"[{'Parameters': [{'name': 'delta', 'type': 'integer, positive', 'description': 'Number of draws to advance the RNG. Must be less than thesize state variable in the underlying RNG.'}]}, {'Returns': [{'name': 'self', 'type': 'PCG64', 'description': 'RNG advanced delta steps'}]}]",
numpy.random.PCG64.jumped,method,"[{'Parameters': [{'name': 'jumps', 'type': 'integer, positive', 'description': 'Number of times to jump the state of the bit generator returned'}]}, {'Returns': [{'name': 'bit_generator', 'type': 'PCG64', 'description': 'New instance of generator jumped iter times'}]}]",
numpy.random.PCG64.cffi,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.random.PCG64.ctypes,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.strings.add,Add arguments element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'The arrays to be added.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'add', 'type': 'ndarray or scalar', 'description': 'The sum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.add(1.0, 4.0)
5.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> x1 + x2
array([[ 0.,  2.,  4.],
       [ 3.,  5.,  7.],
       [ 6.,  8., 10.]])"
numpy.strings.center,"Return a copy of a with its elements centered in a string of
length width.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'width', 'type': 'array_like, with any integer dtype', 'description': 'The length of the resulting strings, unless width < str_len(a).'}, {'name': 'fillchar', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Optional padding character to use (default is space).'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['a1b2','1b2a','b2a1','2a1b']); c
array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='<U4')
>>> np.strings.center(c, width=9)
array(['   a1b2  ', '   1b2a  ', '   b2a1  ', '   2a1b  '], dtype='<U9')
>>> np.strings.center(c, width=9, fillchar='*')
array(['***a1b2**', '***1b2a**', '***b2a1**', '***2a1b**'], dtype='<U9')
>>> np.strings.center(c, width=1)
array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='<U4')"
numpy.strings.capitalize,"Return a copy of a with only the first character of each element
capitalized.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array of strings to capitalize.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c
array(['a1b2', '1b2a', 'b2a1', '2a1b'],
    dtype='|S4')
>>> np.strings.capitalize(c)
array(['A1b2', '1b2a', 'B2a1', '2a1b'],
    dtype='|S4')"
numpy.strings.decode,Calls bytes.decode element-wise.,"[{'Parameters': [{'name': 'a', 'type': 'array_like, with bytes_ dtype', 'description': ''}, {'name': 'encoding', 'type': 'str, optional', 'description': 'The name of an encoding'}, {'name': 'errors', 'type': 'str, optional', 'description': 'Specifies how to handle encoding errors'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': ''}]}]",">>> import numpy as np
>>> c = np.array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
...               b'\x81\x82\xc2\xc1\xc2\x82\x81'])
>>> c
array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
       b'\x81\x82\xc2\xc1\xc2\x82\x81'], dtype='|S7')
>>> np.strings.decode(c, encoding='cp037')
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')"
numpy.strings.encode,Calls str.encode element-wise.,"[{'Parameters': [{'name': 'a', 'type': 'array_like, with StringDType or str_ dtype', 'description': ''}, {'name': 'encoding', 'type': 'str, optional', 'description': 'The name of an encoding'}, {'name': 'errors', 'type': 'str, optional', 'description': 'Specifies how to handle encoding errors'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': ''}]}]",">>> import numpy as np
>>> a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
>>> np.strings.encode(a, encoding='cp037')
array([b'ÁÁÁ', b'@@Á@@',
   b'ÂÁÂ'], dtype='|S7')"
numpy.strings.expandtabs,"Return a copy of each string element where all tab characters are
replaced by one or more spaces.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array'}, {'name': 'tabsize', 'type': 'int, optional', 'description': 'Replace tabs with tabsize number of spaces.  If not given defaultsto 8 spaces.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input type'}]}]",">>> import numpy as np
>>> a = np.array(['         Hello   world'])
>>> np.strings.expandtabs(a, tabsize=4)  
array(['        Hello   world'], dtype='<U21')"
numpy.strings.ljust,"Return an array with the elements of a left-justified in a
string of length width.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'width', 'type': 'array_like, with any integer dtype', 'description': 'The length of the resulting strings, unless width < str_len(a).'}, {'name': 'fillchar', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Optional character to use for padding (default is space).'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
>>> np.strings.ljust(c, width=3)
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
>>> np.strings.ljust(c, width=9)
array(['aAaAaA   ', '  aA     ', 'abBABba  '], dtype='<U9')"
numpy.strings.lower,Return an array with the elements converted to lowercase.,"[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['A1B C', '1BCA', 'BCA1']); c
array(['A1B C', '1BCA', 'BCA1'], dtype='<U5')
>>> np.strings.lower(c)
array(['a1b c', '1bca', 'bca1'], dtype='<U5')"
numpy.strings.lstrip,"For each element in a, return a copy with the leading characters
removed.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'chars', 'type': 'scalar with the same dtype as a, optional', 'description': 'The chars argument is a string specifying the set ofcharacters to be removed. If None, the charsargument defaults to removing whitespace. The chars argumentis not a prefix or suffix; rather, all combinations of itsvalues are stripped.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
>>> c
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
# The 'a' variable is unstripped from c[1] because of leading whitespace.
>>> np.strings.lstrip(c, 'a')
array(['AaAaA', '  aA  ', 'bBABba'], dtype='<U7')
>>> np.strings.lstrip(c, 'A') # leaves c unchanged
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
>>> (np.strings.lstrip(c, ' ') == np.strings.lstrip(c, '')).all()
np.False_
>>> (np.strings.lstrip(c, ' ') == np.strings.lstrip(c)).all()
np.True_"
numpy.strings.mod,"Return (a % i), that is pre-Python 2.6 string formatting
(interpolation), element-wise for a pair of array_likes of str
or unicode.","[{'Parameters': [{'name': 'a', 'type': 'array_like, with np.bytes_ or np.str_ dtype', 'description': ''}, {'name': 'values', 'type': 'array_like of values', 'description': 'These values will be element-wise interpolated into the string.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> a = np.array([""NumPy is a %s library""])
>>> np.strings.mod(a, values=[""Python""])
array(['NumPy is a Python library'], dtype='<U25')
>>> a = np.array([b'%d bytes', b'%d bits'])
>>> values = np.array([8, 64])
>>> np.strings.mod(a, values)
array([b'8 bytes', b'64 bits'], dtype='|S7')"
numpy.strings.multiply,"Return (a * i), that is string multiple concatenation,
element-wise.","[{'Parameters': [{'name': 'a', 'type': 'array_like, with StringDType, bytes_ or str_ dtype', 'description': ''}, {'name': 'i', 'type': 'array_like, with any integer dtype', 'description': ''}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> a = np.array([""a"", ""b"", ""c""])
>>> np.strings.multiply(a, 3)
array(['aaa', 'bbb', 'ccc'], dtype='<U3')
>>> i = np.array([1, 2, 3])
>>> np.strings.multiply(a, i)
array(['a', 'bb', 'ccc'], dtype='<U3')
>>> np.strings.multiply(np.array(['a']), i)
array(['a', 'aa', 'aaa'], dtype='<U3')
>>> a = np.array(['a', 'b', 'c', 'd', 'e', 'f']).reshape((2, 3))
>>> np.strings.multiply(a, 3)
array([['aaa', 'bbb', 'ccc'],
       ['ddd', 'eee', 'fff']], dtype='<U3')
>>> np.strings.multiply(a, i)
array([['a', 'bb', 'ccc'],
       ['d', 'ee', 'fff']], dtype='<U3')"
numpy.strings.partition,Partition each element in a around sep.,"[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array'}, {'name': 'sep', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Separator to split each string element in a.'}]}, {'Returns': [{'name': 'out', 'type': '3-tuple:', 'description': 'array with StringDType, bytes_ or str_ dtype with thepart before the separatorarray with StringDType, bytes_ or str_ dtype with theseparatorarray with StringDType, bytes_ or str_ dtype with thepart after the separator'}]}]",">>> import numpy as np
>>> x = np.array([""Numpy is nice!""])
>>> np.strings.partition(x, "" "")
(array(['Numpy'], dtype='<U5'),
 array([' '], dtype='<U1'),
 array(['is nice!'], dtype='<U8'))"
numpy.strings.replace,"For each element in a, return a copy of the string with
occurrences of substring old replaced by new.","[{'Parameters': [{'name': 'a', 'type': 'array_like, with bytes_ or str_ dtype', 'description': ''}, {'name': 'old, new', 'type': 'array_like, with bytes_ or str_ dtype', 'description': ''}, {'name': 'count', 'type': 'array_like, with int_ dtype', 'description': 'If the optional argument count is given, only the firstcount occurrences are replaced.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> a = np.array([""That is a mango"", ""Monkeys eat mangos""])
>>> np.strings.replace(a, 'mango', 'banana')
array(['That is a banana', 'Monkeys eat bananas'], dtype='<U19')
>>> a = np.array([""The dish is fresh"", ""This is it""])
>>> np.strings.replace(a, 'is', 'was')
array(['The dwash was fresh', 'Thwas was it'], dtype='<U19')"
numpy.strings.rjust,"Return an array with the elements of a right-justified in a
string of length width.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'width', 'type': 'array_like, with any integer dtype', 'description': 'The length of the resulting strings, unless width < str_len(a).'}, {'name': 'fillchar', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Optional padding character to use (default is space).'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
>>> np.strings.rjust(a, width=3)
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
>>> np.strings.rjust(a, width=9)
array(['   aAaAaA', '     aA  ', '  abBABba'], dtype='<U9')"
numpy.strings.rpartition,Partition (split) each element around the right-most separator.,"[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array'}, {'name': 'sep', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Separator to split each string element in a.'}]}, {'Returns': [{'name': 'out', 'type': '3-tuple:', 'description': 'array with StringDType, bytes_ or str_ dtype with thepart before the separatorarray with StringDType, bytes_ or str_ dtype with theseparatorarray with StringDType, bytes_ or str_ dtype with thepart after the separator'}]}]",">>> import numpy as np
>>> a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
>>> np.strings.rpartition(a, 'A')
(array(['aAaAa', '  a', 'abB'], dtype='<U5'),
 array(['A', 'A', 'A'], dtype='<U1'),
 array(['', '  ', 'Bba'], dtype='<U3'))"
numpy.strings.rstrip,"For each element in a, return a copy with the trailing characters
removed.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'chars', 'type': 'scalar with the same dtype as a, optional', 'description': 'The chars argument is a string specifying the set ofcharacters to be removed. If None, the charsargument defaults to removing whitespace. The chars argumentis not a prefix or suffix; rather, all combinations of itsvalues are stripped.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['aAaAaA', 'abBABba'])
>>> c
array(['aAaAaA', 'abBABba'], dtype='<U7')
>>> np.strings.rstrip(c, 'a')
array(['aAaAaA', 'abBABb'], dtype='<U7')
>>> np.strings.rstrip(c, 'A')
array(['aAaAa', 'abBABba'], dtype='<U7')"
numpy.strings.strip,"For each element in a, return a copy with the leading and
trailing characters removed.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'chars', 'type': 'scalar with the same dtype as a, optional', 'description': 'The chars argument is a string specifying the set ofcharacters to be removed. If None, the charsargument defaults to removing whitespace. The chars argumentis not a prefix or suffix; rather, all combinations of itsvalues are stripped.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
>>> c
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
>>> np.strings.strip(c)
array(['aAaAaA', 'aA', 'abBABba'], dtype='<U7')
# 'a' unstripped from c[1] because of leading whitespace.
>>> np.strings.strip(c, 'a')
array(['AaAaA', '  aA  ', 'bBABb'], dtype='<U7')
# 'A' unstripped from c[1] because of trailing whitespace.
>>> np.strings.strip(c, 'A')
array(['aAaAa', '  aA  ', 'abBABba'], dtype='<U7')"
numpy.strings.swapcase,"Return element-wise a copy of the string with
uppercase characters converted to lowercase and vice versa.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c
array(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],
    dtype='|S5')
>>> np.strings.swapcase(c)
array(['A1b C', '1B cA', 'B cA1', 'Ca1B'],
    dtype='|S5')"
numpy.strings.title,Return element-wise title cased version of string or unicode.,"[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c
array(['a1b c', '1b ca', 'b ca1', 'ca1b'],
    dtype='|S5')
>>> np.strings.title(c)
array(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],
    dtype='|S5')"
numpy.strings.translate,"For each element in a, return a copy of the string where all
characters occurring in the optional argument deletechars are
removed, and the remaining characters have been mapped through the
given translation table.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with np.bytes_ or np.str_ dtype', 'description': ''}, {'name': 'table', 'type': 'str of length 256', 'description': ''}, {'name': 'deletechars', 'type': 'str', 'description': ''}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of str or unicode, depending on input type'}]}]",">>> import numpy as np
>>> a = np.array(['a1b c', '1bca', 'bca1'])
>>> table = a[0].maketrans('abc', '123')
>>> deletechars = ' '
>>> np.char.translate(a, table, deletechars)
array(['112 3', '1231', '2311'], dtype='<U5')"
numpy.strings.upper,Return an array with the elements converted to uppercase.,"[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input types'}]}]",">>> import numpy as np
>>> c = np.array(['a1b c', '1bca', 'bca1']); c
array(['a1b c', '1bca', 'bca1'], dtype='<U5')
>>> np.strings.upper(c)
array(['A1B C', '1BCA', 'BCA1'], dtype='<U5')"
numpy.strings.zfill,"Return the numeric string left-filled with zeros. A leading
sign prefix (+/-) is handled by inserting the padding
after the sign character rather than before.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'width', 'type': 'array_like, with any integer dtype', 'description': 'Width of string to left-fill elements in a.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of StringDType, bytes_ or str_ dtype,depending on input type'}]}]",">>> import numpy as np
>>> np.strings.zfill(['1', '-1', '+1'], 3)
array(['001', '-01', '+01'], dtype='<U3')"
numpy.strings.equal,Return (x1 == x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.equal([0, 1, 3], np.arange(3))
array([ True,  True, False])
>>> np.equal(1, np.ones(1))
array([ True])
>>> a = np.array([2, 4, 6])
>>> b = np.array([2, 4, 2])
>>> a == b
array([ True,  True, False])"
numpy.strings.not_equal,Return (x1 != x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.not_equal([1.,2.], [1., 3.])
array([False,  True])
>>> np.not_equal([1, 2], [[1, 3],[1, 4]])
array([[False,  True],
       [False,  True]])
>>> a = np.array([1., 2.])
>>> b = np.array([1., 3.])
>>> a != b
array([False,  True])"
numpy.strings.greater_equal,Return the truth value of (x1 >= x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'bool or ndarray of bool', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.greater_equal([4, 2, 1], [2, 2, 2])
array([ True, True, False])
>>> a = np.array([4, 2, 1])
>>> b = np.array([2, 2, 2])
>>> a >= b
array([ True,  True, False])"
numpy.strings.less_equal,Return the truth value of (x1 <= x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.less_equal([4, 2, 1], [2, 2, 2])
array([False,  True,  True])
>>> a = np.array([4, 2, 1])
>>> b = np.array([2, 2, 2])
>>> a <= b
array([False,  True,  True])"
numpy.strings.greater,Return the truth value of (x1 > x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.greater([4,2],[2,2])
array([ True, False])
>>> a = np.array([4, 2])
>>> b = np.array([2, 2])
>>> a > b
array([ True, False])"
numpy.strings.less,Return the truth value of (x1 < x2) element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.less([1, 2], [2, 2])
array([ True, False])
>>> a = np.array([1, 2])
>>> b = np.array([2, 2])
>>> a < b
array([ True, False])"
numpy.strings.count,"Returns an array with the number of non-overlapping occurrences of
substring sub in the range [start, end).","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'sub', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'The substring to search for.'}, {'name': 'start, end', 'type': 'array_like, with any integer dtype', 'description': 'The range to look in, interpreted as in slice notation.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of ints'}]}]",">>> import numpy as np
>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
>>> c
array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
>>> np.strings.count(c, 'A')
array([3, 1, 1])
>>> np.strings.count(c, 'aA')
array([3, 1, 0])
>>> np.strings.count(c, 'A', start=1, end=4)
array([2, 1, 1])
>>> np.strings.count(c, 'A', start=1, end=3)
array([1, 0, 0])"
numpy.strings.endswith,"Returns a boolean array which is True where the string element
in a ends with suffix, otherwise False.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'suffix', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'start, end', 'type': 'array_like, with any integer dtype', 'description': 'With start, test beginning at that position. With end,stop comparing at that position.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of bools'}]}]",">>> import numpy as np
>>> s = np.array(['foo', 'bar'])
>>> s
array(['foo', 'bar'], dtype='<U3')
>>> np.strings.endswith(s, 'ar')
array([False,  True])
>>> np.strings.endswith(s, 'a', start=1, end=2)
array([False,  True])"
numpy.strings.find,"For each element, return the lowest index in the string where
substring sub is found, such that sub is contained in the
range [start, end).","[{'Parameters': [{'name': 'a', 'type': 'array_like, with StringDType, bytes_ or str_ dtype', 'description': ''}, {'name': 'sub', 'type': 'array_like, with np.bytes_ or np.str_ dtype', 'description': 'The substring to search for.'}, {'name': 'start, end', 'type': 'array_like, with any integer dtype', 'description': 'The range to look in, interpreted as in slice notation.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of ints'}]}]",">>> import numpy as np
>>> a = np.array([""NumPy is a Python library""])
>>> np.strings.find(a, ""Python"")
array([11])"
numpy.strings.index,"Like find, but raises ValueError when the substring is not found.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'sub', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'start, end', 'type': 'array_like, with any integer dtype, optional', 'description': ''}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of ints.'}]}]",">>> import numpy as np
>>> a = np.array([""Computer Science""])
>>> np.strings.index(a, ""Science"", start=0, end=None)
array([9])"
numpy.strings.isalnum,"Returns true for each element if all characters in the string are
alphanumeric and there is at least one character, false otherwise.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_ or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of boolThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array(['a', '1', 'a1', '(', ''])
>>> np.strings.isalnum(a)
array([ True,  True,  True, False, False])"
numpy.strings.isalpha,"Returns true for each element if all characters in the data
interpreted as a string are alphabetic and there is at least
one character, false otherwise.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array(['a', 'b', '0'])
>>> np.strings.isalpha(a)
array([ True,  True, False])
>>> a = np.array([['a', 'b', '0'], ['c', '1', '2']])
>>> np.strings.isalpha(a)
array([[ True,  True, False], [ True, False, False]])"
numpy.strings.isdecimal,"For each element, return True if there are only decimal
characters in the element.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.strings.isdecimal(['12345', '4.99', '123ABC', ''])
array([ True, False, False, False])"
numpy.strings.isdigit,"Returns true for each element if all characters in the string are
digits and there is at least one character, false otherwise.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array(['a', 'b', '0'])
>>> np.strings.isdigit(a)
array([False, False,  True])
>>> a = np.array([['a', 'b', '0'], ['c', '1', '2']])
>>> np.strings.isdigit(a)
array([[False, False,  True], [False,  True,  True]])"
numpy.strings.islower,"Returns true for each element if all cased characters in the
string are lowercase and there is at least one cased character,
false otherwise.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_ or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.strings.islower(""GHC"")
array(False)
>>> np.strings.islower(""ghc"")
array(True)"
numpy.strings.isnumeric,"For each element, return True if there are only numeric
characters in the element.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.strings.isnumeric(['123', '123abc', '9.0', '1/4', 'VIII'])
array([ True, False, False, False, False])"
numpy.strings.isspace,"Returns true for each element if there are only whitespace
characters in the string and there is at least one character,
false otherwise.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> np.char.isspace(list(""a b c""))
array([False,  True, False,  True, False])
>>> np.char.isspace(b'\x0a \x0b \x0c')
np.True_
>>> np.char.isspace(b'\x0a \x0b \x0c N')
np.False_"
numpy.strings.istitle,"Returns true for each element if the element is a titlecased
string and there is at least one character, false otherwise.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_ or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.strings.istitle(""Numpy Is Great"")
array(True)
>>> np.strings.istitle(""Numpy is great"")
array(False)"
numpy.strings.isupper,"Return true for each element if all cased characters in the
string are uppercase and there is at least one character, false
otherwise.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_ or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of boolsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.strings.isupper(""GHC"")
array(True)
>>> a = np.array([""hello"", ""HELLO"", ""Hello""])
>>> np.strings.isupper(a)
array([False,  True, False])"
numpy.strings.rfind,"For each element, return the highest index in the string where
substring sub is found, such that sub is contained in the
range [start, end).","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'sub', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': 'The substring to search for.'}, {'name': 'start, end', 'type': 'array_like, with any integer dtype', 'description': 'The range to look in, interpreted as in slice notation.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of ints'}]}]",">>> import numpy as np
>>> a = np.array([""Computer Science""])
>>> np.strings.rfind(a, ""Science"", start=0, end=None)
array([9])
>>> np.strings.rfind(a, ""Science"", start=0, end=8)
array([-1])
>>> b = np.array([""Computer Science"", ""Science""])
>>> np.strings.rfind(b, ""Science"", start=0, end=None)
array([9, 0])"
numpy.strings.rindex,"Like rfind, but raises ValueError when the substring sub is
not found.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with np.bytes_ or np.str_ dtype', 'description': ''}, {'name': 'sub', 'type': 'array-like, with np.bytes_ or np.str_ dtype', 'description': ''}, {'name': 'start, end', 'type': 'array-like, with any integer dtype, optional', 'description': ''}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of ints.'}]}]",">>> a = np.array([""Computer Science""])
>>> np.strings.rindex(a, ""Science"", start=0, end=None)
array([9])"
numpy.strings.startswith,"Returns a boolean array which is True where the string element
in a starts with prefix, otherwise False.","[{'Parameters': [{'name': 'a', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'prefix', 'type': 'array-like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'start, end', 'type': 'array_like, with any integer dtype', 'description': 'With start, test beginning at that position. With end,stop comparing at that position.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array of bools'}]}]",">>> import numpy as np
>>> s = np.array(['foo', 'bar'])
>>> s
array(['foo', 'bar'], dtype='<U3')
>>> np.strings.startswith(s, 'fo')
array([True,  False])
>>> np.strings.startswith(s, 'o', start=1, end=2)
array([True,  False])"
numpy.strings.str_len,"Returns the length of each element. For byte strings,
this is the number of bytes, while, for Unicode strings,
it is the number of Unicode code points.","[{'Parameters': [{'name': 'x', 'type': 'array_like, with StringDType, bytes_, or str_ dtype', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Output array of intsThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array(['Grace Hopper Conference', 'Open Source Day'])
>>> np.strings.str_len(a)
array([23, 15])
>>> a = np.array(['Р', 'о'])
>>> np.strings.str_len(a)
array([1, 1])
>>> a = np.array([['hello', 'world'], ['Р', 'о']])
>>> np.strings.str_len(a)
array([[5, 5], [1, 1]])"
numpy.ma.MaskType,alias of bool,[],
Scalars,"Python defines only one type of a particular data class (there is only
one integer type, one floating-point type, etc.). This can be
convenient in applications that don’t need to be concerned with all
the ways data can be represented in a computer.  For scientific
computing, however, more control is often needed.","[{'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Canonical name': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Alias on this platform (Linux x86_64)': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Character code': []}, {'Parameters': [{'name': 'length_or_data', 'type': 'int, array-like, bytes-like, object', 'description': 'One of multiple meanings (see notes).  The length orbytes data of an unstructured void.  Or alternatively,the data to be stored in the new scalar when dtypeis provided.This can be an array-like, in which case an array maybe returned.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'If provided the dtype of the new scalar.  This dtype mustbe “void” dtype (i.e. a structured or unstructured void,see also Structured datatypes).New in version 1.24.'}]}, {'Character code': []}, {'Character code': []}, {'Character code': []}]",">>> import numpy as np
>>> f16 = np.float16(""0.1"")
>>> f32 = np.float32(f16)
>>> f64 = np.float64(f32)
>>> f16 == f32 == f64
True
>>> f16, f32, f64
(0.1, 0.099975586, 0.0999755859375)
>>> f16 = np.float16(""0.1"")
>>> f32 = np.float32(""0.1"")
>>> f64 = np.float64(""0.1"")
>>> f16 == f32 == f64
False
>>> f16, f32, f64
(0.1, 0.1, 0.1)
>>> np.datetime64(10, 'Y')
np.datetime64('1980')
>>> np.datetime64('1980', 'Y')
np.datetime64('1980')
>>> np.datetime64(10, 'D')
np.datetime64('1970-01-11')
>>> s = np.str_(""abc\x00"")
>>> s
'abc'
>>> m = memoryview(np.str_(""abc""))
>>> m.format
'3w'
>>> m.tobytes()
b'a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'
>>> np.void(5)
np.void(b'\x00\x00\x00\x00\x00')
>>> np.void(b'abcd')
np.void(b'\x61\x62\x63\x64')
>>> np.void((3.2, b'eggs'), dtype=""d,S5"")
np.void((3.2, b'eggs'), dtype=[('f0', '<f8'), ('f1', 'S5')])
>>> np.void(3, dtype=[('x', np.int8), ('y', np.int8)])
np.void((3, 3), dtype=[('x', 'i1'), ('y', 'i1')])"
numpy.ma.masked_array,alias of MaskedArray,[],
Constants of the numpy.ma module,"In addition to the MaskedArray class, the numpy.ma module
defines several constants.",[],">>> x = np.ma.array(np.matrix([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
>>> x.data
matrix([[1, 2],
        [3, 4]])
>>> x = np.ma.array([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)],
...         mask=[(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)],
...        dtype=[('a', int), ('b', int)])
>>> x.recordmask
array([False, False,  True, False, False])
>>> import numpy as np
>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
...     np.ma.array([0, 1], dtype=dt).get_fill_value()
...
np.int64(999999)
np.int64(999999)
np.float64(1e+20)
np.complex128(1e+20+0j)
>>> x = np.ma.array([0, 1.], fill_value=-np.inf)
>>> x.fill_value
np.float64(-inf)
>>> x.fill_value = np.pi
>>> x.fill_value
np.float64(3.1415926535897931)
>>> x.fill_value = None
>>> x.fill_value
np.float64(1e+20)
>>> import numpy as np
>>> x = np.arange(10)
>>> m = np.ma.masked_array(x, x>5)
>>> assert not m.hardmask
>>> m[8] = 42
>>> m
masked_array(data=[0, 1, 2, 3, 4, 5, --, --, 42, --],
             mask=[False, False, False, False, False, False,
                   True, True, False, True],
       fill_value=999999)
>>> hardened = np.ma.harden_mask(m)
>>> assert m.hardmask and hardened is m
>>> m[:] = 23
>>> m
masked_array(data=[23, 23, 23, 23, 23, 23, --, --, 23, --],
             mask=[False, False, False, False, False, False,
                   True, True, False, True],
       fill_value=999999)"
numpy.ma.array,An array class with possibly masked values.,"[{'Parameters': [{'name': 'data', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'mask', 'type': 'sequence, optional', 'description': 'Mask. Must be convertible to an array of booleans with the sameshape as data. True indicates a masked (i.e. invalid) data.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data type of the output.If dtype is None, the type of the data argument (data.dtype)is used. If dtype is not None and different from data.dtype,a copy is performed.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Whether to copy the input data (True), or to use a reference instead.Default is False.'}, {'name': 'subok', 'type': 'bool, optional', 'description': 'Whether to return a subclass of MaskedArray if possible (True) or aplain MaskedArray. Default is True.'}, {'name': 'ndmin', 'type': 'int, optional', 'description': 'Minimum number of dimensions. Default is 0.'}, {'name': 'fill_value', 'type': 'scalar, optional', 'description': 'Value used to fill in the masked values when necessary.If None, a default based on the data-type is used.'}, {'name': 'keep_mask', 'type': 'bool, optional', 'description': 'Whether to combine mask with the mask of the input data, if any(True), or to use only mask for the output (False). Default is True.'}, {'name': 'hard_mask', 'type': 'bool, optional', 'description': 'Whether to use a hard mask or not. With a hard mask, masked valuescannot be unmasked. Default is False.'}, {'name': 'shrink', 'type': 'bool, optional', 'description': 'Whether to force compression of an empty mask. Default is True.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’}, optional', 'description': 'Specify the order of the array.  If order is ‘C’, then the arraywill be in C-contiguous order (last-index varies the fastest).If order is ‘F’, then the returned array will be inFortran-contiguous order (first-index varies the fastest).If order is ‘A’ (default), then the returned array may bein any order (either C-, Fortran-contiguous, or even discontiguous),unless a copy is required, in which case it will be C-contiguous.'}]}]",">>> import numpy as np
>>> data = np.arange(6).reshape((2, 3))
>>> np.ma.MaskedArray(data, mask=[[False, True, False],
...                               [False, False, True]])
masked_array(
  data=[[0, --, 2],
        [3, 4, --]],
  mask=[[False,  True, False],
        [False, False,  True]],
  fill_value=999999)
>>> np.ma.MaskedArray(data, mask=False)
masked_array(
  data=[[0, 1, 2],
        [3, 4, 5]],
  mask=[[False, False, False],
        [False, False, False]],
  fill_value=999999)
>>> np.ma.MaskedArray(data, mask=True)
masked_array(
  data=[[--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True]],
  fill_value=999999,
  dtype=int64)
>>> np.False_ is np.ma.nomask
True"
numpy.ma.copy,Return a copy of the array.,"[{'Parameters': [{'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Controls the memory layout of the copy. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible. (Note that this function and numpy.copy are verysimilar but have different default values for their order=arguments, and this function always passes sub-classes through.)'}]}]",">>> import numpy as np
>>> x = np.array([[1,2,3],[4,5,6]], order='F')
>>> y = x.copy()
>>> x.fill(0)
>>> x
array([[0, 0, 0],
       [0, 0, 0]])
>>> y
array([[1, 2, 3],
       [4, 5, 6]])
>>> y.flags['C_CONTIGUOUS']
True
>>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
>>> b = a.copy()
>>> b[2][0] = 10
>>> a
array([1, 'm', list([10, 3, 4])], dtype=object)
>>> import copy
>>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
>>> c = copy.deepcopy(a)
>>> c[2][0] = 10
>>> c
array([1, 'm', list([10, 3, 4])], dtype=object)
>>> a
array([1, 'm', list([2, 3, 4])], dtype=object)"
numpy.ma.frombuffer,Interpret a buffer as a 1-dimensional array.,"[{'Parameters': [{'name': 'buffer', 'type': 'buffer_like', 'description': 'An object that exposes the buffer interface.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the returned array; default: float.'}, {'name': 'count', 'type': 'int, optional', 'description': 'Number of items to read. -1 means all data in the buffer.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Start reading the buffer from this offset (in bytes); default: 0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out: MaskedArray', 'type': None, 'description': ''}]}]",">>> import numpy as np
>>> s = b'hello world'
>>> np.frombuffer(s, dtype='S1', count=5, offset=6)
array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')
>>> np.frombuffer(b'\x01\x02', dtype=np.uint8)
array([1, 2], dtype=uint8)
>>> np.frombuffer(b'\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
array([1, 2, 3], dtype=uint8)"
numpy.ma.fromfunction,Construct an array by executing a function over each coordinate.,"[{'Parameters': [{'name': 'function', 'type': 'callable', 'description': 'The function is called with N parameters, where N is the rank ofshape.  Each parameter represents the coordinates of the arrayvarying along a specific axis.  For example, if shapewere (2, 2), then the parameters would bearray([[0, 0], [1, 1]]) and array([[0, 1], [0, 1]])'}, {'name': 'shape', 'type': '(N,) tuple of ints', 'description': 'Shape of the output array, which also determines the shape ofthe coordinate arrays passed to function.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the coordinate arrays passed to function.By default, dtype is float.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'fromfunction: MaskedArray', 'type': None, 'description': 'The result of the call to function is passed back directly.Therefore the shape of fromfunction is completely determined byfunction.  If function returns a scalar value, the shape offromfunction would not match the shape parameter.'}]}]",">>> import numpy as np
>>> np.fromfunction(lambda i, j: i, (2, 2), dtype=float)
array([[0., 0.],
       [1., 1.]])
>>> np.fromfunction(lambda i, j: j, (2, 2), dtype=float)
array([[0., 1.],
       [0., 1.]])
>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])
>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])"
numpy.ma.MaskedArray.copy,method,"[{'Parameters': [{'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'Controls the memory layout of the copy. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible. (Note that this function and numpy.copy are verysimilar but have different default values for their order=arguments, and this function always passes sub-classes through.)'}]}]",">>> import numpy as np
>>> x = np.array([[1,2,3],[4,5,6]], order='F')
>>> y = x.copy()
>>> x.fill(0)
>>> x
array([[0, 0, 0],
       [0, 0, 0]])
>>> y
array([[1, 2, 3],
       [4, 5, 6]])
>>> y.flags['C_CONTIGUOUS']
True
>>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
>>> b = a.copy()
>>> b[2][0] = 10
>>> a
array([1, 'm', list([10, 3, 4])], dtype=object)
>>> import copy
>>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
>>> c = copy.deepcopy(a)
>>> c[2][0] = 10
>>> c
array([1, 'm', list([10, 3, 4])], dtype=object)
>>> a
array([1, 'm', list([2, 3, 4])], dtype=object)"
numpy.ma.diagflat,Create a two-dimensional array with the flattened input as a diagonal.,"[{'Parameters': [{'name': 'v', 'type': 'array_like', 'description': 'Input data, which is flattened and set as the k-thdiagonal of the output.'}, {'name': 'k', 'type': 'int, optional', 'description': 'Diagonal to set; 0, the default, corresponds to the “main” diagonal,a positive (negative) k giving the number of the diagonal above(below) the main.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The 2-D output array.'}]}]",">>> import numpy as np
>>> np.diagflat([[1,2], [3,4]])
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])
>>> np.diagflat([1,2], 1)
array([[0, 1, 0],
       [0, 0, 2],
       [0, 0, 0]])"
numpy.ma.empty,"Return a new array of given shape and type, without initializing entries.","[{'Parameters': [{'name': 'shape', 'type': 'int or tuple of int', 'description': 'Shape of the empty array, e.g., (2, 3) or 2.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Desired output data-type for the array, e.g, numpy.int8. Default isnumpy.float64.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional, default: ‘C’', 'description': 'Whether to store multi-dimensional data in row-major(C-style) or column-major (Fortran-style) order inmemory.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Array of uninitialized (arbitrary) data of the given shape, dtype, andorder.  Object arrays will be initialized to None.'}]}]",">>> import numpy as np
>>> np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized
>>> np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
       [  496041986,    19249760]])                     #uninitialized"
numpy.ma.empty_like,Return a new array with the same shape and type as a given array.,"[{'Parameters': [{'name': 'prototype', 'type': 'array_like', 'description': 'The shape and data-type of prototype define these same attributesof the returned array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Overrides the data type of the result.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, or ‘K’}, optional', 'description': 'Overrides the memory layout of the result. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if prototype is Fortrancontiguous, ‘C’ otherwise. ‘K’ means match the layout of prototypeas closely as possible.'}, {'name': 'subok', 'type': 'bool, optional.', 'description': 'If True, then the newly created array will use the sub-classtype of prototype, otherwise it will be a base-class array. Defaultsto True.'}, {'name': 'shape', 'type': 'int or sequence of ints, optional.', 'description': 'Overrides the shape of the result. If order=’K’ and the number ofdimensions is unchanged, will try to keep order, otherwise,order=’C’ is implied.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Array of uninitialized (arbitrary) data with the sameshape and type as prototype.'}]}]",">>> import numpy as np
>>> a = ([1,2,3], [4,5,6])                         # a is array-like
>>> np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
>>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
>>> np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])"
numpy.ma.masked_all,Empty masked array with all elements masked.,"[{'Parameters': [{'name': 'shape', 'type': 'int or tuple of ints', 'description': 'Shape of the required MaskedArray, e.g., (2, 3) or 2.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data type of the output.'}]}, {'Returns': [{'name': 'a', 'type': 'MaskedArray', 'description': 'A masked array with all data masked.'}]}]",">>> import numpy as np
>>> np.ma.masked_all((3, 3))
masked_array(
  data=[[--, --, --],
        [--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True],
        [ True,  True,  True]],
  fill_value=1e+20,
  dtype=float64)
>>> a = np.ma.masked_all((3, 3))
>>> a.dtype
dtype('float64')
>>> a = np.ma.masked_all((3, 3), dtype=np.int32)
>>> a.dtype
dtype('int32')"
numpy.ma.masked_all_like,Empty masked array with the properties of an existing array.,"[{'Parameters': [{'name': 'arr', 'type': 'ndarray', 'description': 'An array describing the shape and dtype of the required MaskedArray.'}]}, {'Returns': [{'name': 'a', 'type': 'MaskedArray', 'description': 'A masked array with all data masked.'}]}, {'Raises': [{'name': 'AttributeError', 'type': None, 'description': 'If arr doesn’t have a shape attribute (i.e. not an ndarray)'}]}]",">>> import numpy as np
>>> arr = np.zeros((2, 3), dtype=np.float32)
>>> arr
array([[0., 0., 0.],
       [0., 0., 0.]], dtype=float32)
>>> np.ma.masked_all_like(arr)
masked_array(
  data=[[--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True]],
  fill_value=np.float64(1e+20),
  dtype=float32)
>>> arr.dtype
dtype('float32')
>>> np.ma.masked_all_like(arr).dtype
dtype('float32')"
numpy.ma.ones,"Return a new array of given shape and type, filled with ones.","[{'Parameters': [{'name': 'shape', 'type': 'int or sequence of ints', 'description': 'Shape of the new array, e.g., (2, 3) or 2.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The desired data-type for the array, e.g., numpy.int8.  Default isnumpy.float64.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional, default: C', 'description': 'Whether to store multi-dimensional data in row-major(C-style) or column-major (Fortran-style) order inmemory.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Array of ones with the given shape, dtype, and order.'}]}]",">>> import numpy as np
>>> np.ones(5)
array([1., 1., 1., 1., 1.])
>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])
>>> np.ones((2, 1))
array([[1.],
       [1.]])
>>> s = (2,2)
>>> np.ones(s)
array([[1.,  1.],
       [1.,  1.]])"
numpy.ma.ones_like,Return an array of ones with the same shape and type as a given array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The shape and data-type of a define these same attributes ofthe returned array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Overrides the data type of the result.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, or ‘K’}, optional', 'description': 'Overrides the memory layout of the result. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible.'}, {'name': 'subok', 'type': 'bool, optional.', 'description': 'If True, then the newly created array will use the sub-classtype of a, otherwise it will be a base-class array. Defaultsto True.'}, {'name': 'shape', 'type': 'int or sequence of ints, optional.', 'description': 'Overrides the shape of the result. If order=’K’ and the number ofdimensions is unchanged, will try to keep order, otherwise,order=’C’ is implied.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Array of ones with the same shape and type as a.'}]}]",">>> import numpy as np
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])
>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.ones_like(y)
array([1.,  1.,  1.])"
numpy.ma.zeros,"Return a new array of given shape and type, filled with zeros.","[{'Parameters': [{'name': 'shape', 'type': 'int or tuple of ints', 'description': 'Shape of the new array, e.g., (2, 3) or 2.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The desired data-type for the array, e.g., numpy.int8.  Default isnumpy.float64.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional, default: ‘C’', 'description': 'Whether to store multi-dimensional data in row-major(C-style) or column-major (Fortran-style) order inmemory.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Array of zeros with the given shape, dtype, and order.'}]}]",">>> import numpy as np
>>> np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])
>>> np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])
>>> np.zeros((2, 1))
array([[ 0.],
       [ 0.]])
>>> s = (2,2)
>>> np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])
>>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
      dtype=[('x', '<i4'), ('y', '<i4')])"
numpy.ma.zeros_like,Return an array of zeros with the same shape and type as a given array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The shape and data-type of a define these same attributes ofthe returned array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Overrides the data type of the result.'}, {'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, or ‘K’}, optional', 'description': 'Overrides the memory layout of the result. ‘C’ means C-order,‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,‘C’ otherwise. ‘K’ means match the layout of a as closelyas possible.'}, {'name': 'subok', 'type': 'bool, optional.', 'description': 'If True, then the newly created array will use the sub-classtype of a, otherwise it will be a base-class array. Defaultsto True.'}, {'name': 'shape', 'type': 'int or sequence of ints, optional.', 'description': 'Overrides the shape of the result. If order=’K’ and the number ofdimensions is unchanged, will try to keep order, otherwise,order=’C’ is implied.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Array of zeros with the same shape and type as a.'}]}]",">>> import numpy as np
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])
>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.zeros_like(y)
array([0.,  0.,  0.])"
numpy.ma.all,Returns True if all elements evaluate to True.,[],">>> import numpy as np
>>> np.ma.array([1,2,3]).all()
True
>>> a = np.ma.array([1,2,3], mask=True)
>>> (a.all() is np.ma.masked)
True"
numpy.ma.any,Returns True if any of the elements of a evaluate to True.,[],
numpy.ma.count,Count the non-masked elements of the array along the given axis.,"[{'Parameters': [{'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which the count is performed.The default, None, performs the count over allthe dimensions of the input array. axis may be negative, inwhich case it counts from the last to the first axis.If this is a tuple of ints, the count is performed on multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray or scalar', 'description': 'An array with the same shape as the input array, with the specifiedaxis removed. If the array is a 0-d array, or if axis is None, ascalar is returned.'}]}]",">>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3
>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])"
numpy.ma.count_masked,Count the number of masked elements along the given axis.,"[{'Parameters': [{'name': 'arr', 'type': 'array_like', 'description': 'An array with (possibly) masked elements.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to count. If None (default), a flattenedversion of the array is used.'}]}, {'Returns': [{'name': 'count', 'type': 'int, ndarray', 'description': 'The total number of masked elements (axis=None) or the numberof masked elements along each slice of the given axis.'}]}]",">>> import numpy as np
>>> a = np.arange(9).reshape((3,3))
>>> a = np.ma.array(a)
>>> a[1, 0] = np.ma.masked
>>> a[1, 2] = np.ma.masked
>>> a[2, 1] = np.ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False, False, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> np.ma.count_masked(a)
3
>>> np.ma.count_masked(a, axis=0)
array([1, 1, 1])
>>> np.ma.count_masked(a, axis=1)
array([0, 2, 1])"
numpy.ma.getmask,"Return the mask of a masked array, or nomask.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input MaskedArray for which the mask is required.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmask(a)
array([[False,  True],
       [False, False]])
>>> a.mask
array([[False,  True],
       [False, False]])
>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.nomask
False
>>> ma.getmask(b) == ma.nomask
True
>>> b.mask == ma.nomask
True"
numpy.ma.getmaskarray,"Return the mask of a masked array, or full boolean array of False.","[{'Parameters': [{'name': 'arr', 'type': 'array_like', 'description': 'Input MaskedArray for which the mask is required.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmaskarray(a)
array([[False,  True],
       [False, False]])
>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.getmaskarray(b)
array([[False, False],
       [False, False]])"
numpy.ma.getdata,Return the data of a masked array as an ndarray.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input MaskedArray, alternatively a ndarray or a subclass thereof.'}, {'name': 'subok', 'type': 'bool', 'description': 'Whether to force the output to be a pure ndarray (False) or toreturn a subclass of ndarray if appropriate (True, default).'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getdata(a)
array([[1, 2],
       [3, 4]])
>>> a.data
array([[1, 2],
       [3, 4]])"
numpy.ma.nonzero,Return the indices of unmasked elements that are not zero.,"[{'Parameters': [{'name': 'None', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'tuple_of_arrays', 'type': 'tuple', 'description': 'Indices of elements that are non-zero.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.array(np.eye(3))
>>> x
masked_array(
  data=[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]],
  mask=False,
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 1, 2]), array([0, 1, 2]))
>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[1.0, 0.0, 0.0],
        [0.0, --, 0.0],
        [0.0, 0.0, 1.0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 2]), array([0, 2]))
>>> np.transpose(x.nonzero())
array([[0, 0],
       [2, 2]])
>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
>>> a > 3
masked_array(
  data=[[False, False, False],
        [ True,  True,  True],
        [ True,  True,  True]],
  mask=False,
  fill_value=True)
>>> ma.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
numpy.ma.shape,Return the shape of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'shape', 'type': 'tuple of ints', 'description': 'The elements of the shape tuple give the lengths of thecorresponding array dimensions.'}]}]",">>> import numpy as np
>>> np.shape(np.eye(3))
(3, 3)
>>> np.shape([[1, 3]])
(1, 2)
>>> np.shape([0])
(1,)
>>> np.shape(0)
()
>>> a = np.array([(1, 2), (3, 4), (5, 6)],
...              dtype=[('x', 'i4'), ('y', 'i4')])
>>> np.shape(a)
(3,)
>>> a.shape
(3,)"
numpy.ma.size,Return the number of elements along a given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the elements are counted.  By default, givethe total number of elements.'}]}, {'Returns': [{'name': 'element_count', 'type': 'int', 'description': 'Number of elements along the specified axis.'}]}]",">>> import numpy as np
>>> a = np.array([[1,2,3],[4,5,6]])
>>> np.size(a)
6
>>> np.size(a,1)
3
>>> np.size(a,0)
2"
numpy.ma.is_masked,Determine whether input has masked values.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Array to check for masked values.'}]}, {'Returns': [{'name': 'result', 'type': 'bool', 'description': 'True if x is a MaskedArray with masked values, False otherwise.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> x
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_masked(x)
True
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)
>>> x
masked_array(data=[0, 1, 0, 2, 3],
             mask=False,
       fill_value=42)
>>> ma.is_masked(x)
False
>>> x = [False, True, False]
>>> ma.is_masked(x)
False
>>> x = 'a string'
>>> ma.is_masked(x)
False"
numpy.ma.is_mask,"Return True if m is a valid, standard mask.","[{'Parameters': [{'name': 'm', 'type': 'array_like', 'description': 'Array to test.'}]}, {'Returns': [{'name': 'result', 'type': 'bool', 'description': 'True if m.dtype.type is MaskType, False otherwise.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> m
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_mask(m)
False
>>> ma.is_mask(m.mask)
True
>>> m = [False, True, False]
>>> ma.is_mask(m)
False
>>> m = np.array([False, True, False])
>>> m
array([False,  True, False])
>>> ma.is_mask(m)
True
>>> dtype = np.dtype({'names':['monty', 'pithon'],
...                   'formats':[bool, bool]})
>>> dtype
dtype([('monty', '|b1'), ('pithon', '|b1')])
>>> m = np.array([(True, False), (False, True), (True, False)],
...              dtype=dtype)
>>> m
array([( True, False), (False,  True), ( True, False)],
      dtype=[('monty', '?'), ('pithon', '?')])
>>> ma.is_mask(m)
False"
numpy.ma.isMaskedArray,Test whether input is an instance of MaskedArray.,"[{'Parameters': [{'name': 'x', 'type': 'object', 'description': 'Object to test.'}]}, {'Returns': [{'name': 'result', 'type': 'bool', 'description': 'True if x is a MaskedArray.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False"
numpy.ma.isMA,Test whether input is an instance of MaskedArray.,"[{'Parameters': [{'name': 'x', 'type': 'object', 'description': 'Object to test.'}]}, {'Returns': [{'name': 'result', 'type': 'bool', 'description': 'True if x is a MaskedArray.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False"
numpy.ma.isarray,Test whether input is an instance of MaskedArray.,"[{'Parameters': [{'name': 'x', 'type': 'object', 'description': 'Object to test.'}]}, {'Returns': [{'name': 'result', 'type': 'bool', 'description': 'True if x is a MaskedArray.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False"
numpy.ma.isin,"Calculates element in test_elements, broadcasting over
element only.",[],">>> import numpy as np
>>> element = np.ma.array([1, 2, 3, 4, 5, 6])
>>> test_elements = [0, 2]
>>> np.ma.isin(element, test_elements)
masked_array(data=[False,  True, False, False, False, False],
             mask=False,
       fill_value=True)"
numpy.ma.in1d,"Test whether each element of an array is also present in a second
array.",[],">>> import numpy as np
>>> ar1 = np.ma.array([0, 1, 2, 5, 0])
>>> ar2 = [0, 2]
>>> np.ma.in1d(ar1, ar2)
masked_array(data=[ True, False,  True, False,  True],
             mask=False,
       fill_value=True)"
numpy.ma.unique,Finds the unique elements of an array.,[],">>> import numpy as np
>>> a = [1, 2, 1000, 2, 3]
>>> mask = [0, 0, 1, 0, 0]
>>> masked_a = np.ma.masked_array(a, mask)
>>> masked_a
masked_array(data=[1, 2, --, 2, 3],
            mask=[False, False,  True, False, False],
    fill_value=999999)
>>> np.ma.unique(masked_a)
masked_array(data=[1, 2, 3, --],
            mask=[False, False, False,  True],
    fill_value=999999)
>>> np.ma.unique(masked_a, return_index=True)
(masked_array(data=[1, 2, 3, --],
            mask=[False, False, False,  True],
    fill_value=999999), array([0, 1, 4, 2]))
>>> np.ma.unique(masked_a, return_inverse=True)
(masked_array(data=[1, 2, 3, --],
            mask=[False, False, False,  True],
    fill_value=999999), array([0, 1, 3, 1, 2]))
>>> np.ma.unique(masked_a, return_index=True, return_inverse=True)
(masked_array(data=[1, 2, 3, --],
            mask=[False, False, False,  True],
    fill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))"
numpy.ma.MaskedArray.all,method,[],">>> import numpy as np
>>> np.ma.array([1,2,3]).all()
True
>>> a = np.ma.array([1,2,3], mask=True)
>>> (a.all() is np.ma.masked)
True"
numpy.ma.MaskedArray.any,method,[],
numpy.ma.MaskedArray.count,method,"[{'Parameters': [{'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which the count is performed.The default, None, performs the count over allthe dimensions of the input array. axis may be negative, inwhich case it counts from the last to the first axis.If this is a tuple of ints, the count is performed on multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray or scalar', 'description': 'An array with the same shape as the input array, with the specifiedaxis removed. If the array is a 0-d array, or if axis is None, ascalar is returned.'}]}]",">>> import numpy.ma as ma
>>> a = ma.arange(6).reshape((2, 3))
>>> a[1, :] = ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, --, --]],
  mask=[[False, False, False],
        [ True,  True,  True]],
  fill_value=999999)
>>> a.count()
3
>>> a.count(axis=0)
array([1, 1, 1])
>>> a.count(axis=1)
array([3, 0])"
numpy.ma.MaskedArray.nonzero,method,"[{'Parameters': [{'name': 'None', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'tuple_of_arrays', 'type': 'tuple', 'description': 'Indices of elements that are non-zero.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.array(np.eye(3))
>>> x
masked_array(
  data=[[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]],
  mask=False,
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 1, 2]), array([0, 1, 2]))
>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[1.0, 0.0, 0.0],
        [0.0, --, 0.0],
        [0.0, 0.0, 1.0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1e+20)
>>> x.nonzero()
(array([0, 2]), array([0, 2]))
>>> np.transpose(x.nonzero())
array([[0, 0],
       [2, 2]])
>>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
>>> a > 3
masked_array(
  data=[[False, False, False],
        [ True,  True,  True],
        [ True,  True,  True]],
  mask=False,
  fill_value=True)
>>> ma.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
numpy.ma.ravel,"Returns a 1D version of self, as a view.","[{'Parameters': [{'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'The elements of a are read using this index order. ‘C’ means toindex the elements in C-like order, with the last axis indexchanging fastest, back to the first axis index changing slowest.‘F’ means to index the elements in Fortran-like index order, withthe first index changing fastest, and the last index changingslowest. Note that the ‘C’ and ‘F’ options take no account of thememory layout of the underlying array, and only refer to the orderof axis indexing.  ‘A’ means to read the elements in Fortran-likeindex order if m is Fortran contiguous in memory, C-like orderotherwise.  ‘K’ means to read the elements in the order they occurin memory, except for reversing the data when strides are negative.By default, ‘C’ index order is used.(Masked arrays currently use ‘A’ on the data when ‘K’ is passed.)'}]}, {'Returns': [{'name': 'MaskedArray', 'type': None, 'description': 'Output view is of shape (self.size,) (or(np.ma.product(self.shape),)).'}]}]",">>> import numpy as np
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.ravel()
masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
             mask=[False,  True, False,  True, False,  True, False,  True,
                   False],
       fill_value=999999)"
numpy.ma.reshape,Returns an array containing the same data with a new shape.,[],">>> a = np.ma.array([1, 2, 3, 4])
>>> np.ma.reshape(a, (2, 2))
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> b = np.ma.array([[1, 2], [3, 4]])
>>> np.ma.reshape(b, (1, 4))
masked_array(data=[[1, 2, 3, 4]],
             mask=False,
       fill_value=999999)
>>> c = np.ma.array([1, 2, 3, 4], mask=[False, True, False, False])
>>> np.ma.reshape(c, (2, 2))
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=999999)"
numpy.ma.resize,Return a new masked array with the specified size and shape.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.array([[1, 2] ,[3, 4]])
>>> a[0, 1] = ma.masked
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=999999)
>>> np.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, --, 3],
        [4, 1, --],
        [3, 4, 1]],
  mask=[[False,  True, False],
        [False, False,  True],
        [False, False, False]],
  fill_value=999999)
>>> a = np.array([[1, 2] ,[3, 4]])
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)"
numpy.ma.MaskedArray.flatten,method,"[{'Parameters': [{'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': '‘C’ means to flatten in row-major (C-style) order.‘F’ means to flatten in column-major (Fortran-style) order. ‘A’ means to flatten in column-majororder if a is Fortran contiguous in memory,row-major order otherwise. ‘K’ means to flattena in the order the elements occur in memory.The default is ‘C’.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'A copy of the input array, flattened to one dimension.'}]}]",">>> import numpy as np
>>> a = np.array([[1,2], [3,4]])
>>> a.flatten()
array([1, 2, 3, 4])
>>> a.flatten('F')
array([1, 3, 2, 4])"
numpy.ma.MaskedArray.ravel,method,"[{'Parameters': [{'name': 'order', 'type': '{‘C’, ‘F’, ‘A’, ‘K’}, optional', 'description': 'The elements of a are read using this index order. ‘C’ means toindex the elements in C-like order, with the last axis indexchanging fastest, back to the first axis index changing slowest.‘F’ means to index the elements in Fortran-like index order, withthe first index changing fastest, and the last index changingslowest. Note that the ‘C’ and ‘F’ options take no account of thememory layout of the underlying array, and only refer to the orderof axis indexing.  ‘A’ means to read the elements in Fortran-likeindex order if m is Fortran contiguous in memory, C-like orderotherwise.  ‘K’ means to read the elements in the order they occurin memory, except for reversing the data when strides are negative.By default, ‘C’ index order is used.(Masked arrays currently use ‘A’ on the data when ‘K’ is passed.)'}]}, {'Returns': [{'name': 'MaskedArray', 'type': None, 'description': 'Output view is of shape (self.size,) (or(np.ma.product(self.shape),)).'}]}]",">>> import numpy as np
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.ravel()
masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
             mask=[False,  True, False,  True, False,  True, False,  True,
                   False],
       fill_value=999999)"
numpy.ma.MaskedArray.reshape,method,"[{'Parameters': [{'name': 'shape', 'type': 'int or tuple of ints', 'description': 'The new shape should be compatible with the original shape. If aninteger is supplied, then the result will be a 1-D array of thatlength.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Determines whether the array data should be viewed as in C(row-major) or FORTRAN (column-major) order.'}]}, {'Returns': [{'name': 'reshaped_array', 'type': 'array', 'description': 'A new view on the array.'}]}]",">>> import numpy as np
>>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
>>> x
masked_array(
  data=[[--, 2],
        [3, --]],
  mask=[[ True, False],
        [False,  True]],
  fill_value=999999)
>>> x = x.reshape((4,1))
>>> x
masked_array(
  data=[[--],
        [2],
        [3],
        [--]],
  mask=[[ True],
        [False],
        [False],
        [ True]],
  fill_value=999999)"
numpy.ma.MaskedArray.resize,method,[],
numpy.ma.swapaxes,Return a view of the array with axis1 and axis2 interchanged.,[],
numpy.ma.transpose,Permute the dimensions of an array.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.arange(4).reshape((2,2))
>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[0, 1],
        [2, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)
>>> ma.transpose(x)
masked_array(
  data=[[0, 2],
        [1, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)"
numpy.ma.MaskedArray.swapaxes,method,[],
numpy.ma.MaskedArray.transpose,method,"[{'Parameters': [{'name': 'axes', 'type': 'None, tuple of ints, or n ints', 'description': 'None or no argument: reverses the order of the axes.tuple of ints: i in the j-th place in the tuple means that thearray’s i-th axis becomes the transposed array’s j-th axis.n ints: same as an n-tuple of the same ints (this form isintended simply as a “convenience” alternative to the tuple form).'}]}, {'Returns': [{'name': 'p', 'type': 'ndarray', 'description': 'View of the array with its axes suitably permuted.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> a
array([[1, 2],
       [3, 4]])
>>> a.transpose()
array([[1, 3],
       [2, 4]])
>>> a.transpose((1, 0))
array([[1, 3],
       [2, 4]])
>>> a.transpose(1, 0)
array([[1, 3],
       [2, 4]])
>>> a = np.array([1, 2, 3, 4])
>>> a
array([1, 2, 3, 4])
>>> a.transpose()
array([1, 2, 3, 4])"
numpy.ma.atleast_1d,Convert inputs to arrays with at least one dimension.,"[{'Parameters': [{'name': 'arys1, arys2, …', 'type': 'array_like', 'description': 'One or more input arrays.'}]}, {'Returns': [{'name': 'ret', 'type': 'ndarray', 'description': 'An array, or tuple of arrays, each with a.ndim >= 1.Copies are made only if necessary.'}]}]",">>> import numpy as np
>>> np.atleast_1d(1.0)
array([1.])
>>> x = np.arange(9.0).reshape(3,3)
>>> np.atleast_1d(x)
array([[0., 1., 2.],
       [3., 4., 5.],
       [6., 7., 8.]])
>>> np.atleast_1d(x) is x
True
>>> np.atleast_1d(1, [3, 4])
(array([1]), array([3, 4]))"
numpy.ma.atleast_2d,View inputs as arrays with at least two dimensions.,"[{'Parameters': [{'name': 'arys1, arys2, …', 'type': 'array_like', 'description': 'One or more array-like sequences.  Non-array inputs are convertedto arrays.  Arrays that already have two or more dimensions arepreserved.'}]}, {'Returns': [{'name': 'res, res2, …', 'type': 'ndarray', 'description': 'An array, or tuple of arrays, each with a.ndim >= 2.Copies are avoided where possible, and views with two or moredimensions are returned.'}]}]",">>> import numpy as np
>>> np.atleast_2d(3.0)
array([[3.]])
>>> x = np.arange(3.0)
>>> np.atleast_2d(x)
array([[0., 1., 2.]])
>>> np.atleast_2d(x).base is x
True
>>> np.atleast_2d(1, [1, 2], [[1, 2]])
(array([[1]]), array([[1, 2]]), array([[1, 2]]))"
numpy.ma.atleast_3d,View inputs as arrays with at least three dimensions.,"[{'Parameters': [{'name': 'arys1, arys2, …', 'type': 'array_like', 'description': 'One or more array-like sequences.  Non-array inputs are converted toarrays.  Arrays that already have three or more dimensions arepreserved.'}]}, {'Returns': [{'name': 'res1, res2, …', 'type': 'ndarray', 'description': 'An array, or tuple of arrays, each with a.ndim >= 3.  Copies areavoided where possible, and views with three or more dimensions arereturned.  For example, a 1-D array of shape (N,) becomes a viewof shape (1, N, 1), and a 2-D array of shape (M, N) becomes aview of shape (M, N, 1).'}]}]",">>> import numpy as np
>>> np.atleast_3d(3.0)
array([[[3.]]])
>>> x = np.arange(3.0)
>>> np.atleast_3d(x).shape
(1, 3, 1)
>>> x = np.arange(12.0).reshape(4,3)
>>> np.atleast_3d(x).shape
(4, 3, 1)
>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
True
>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
...     print(arr, arr.shape) 
...
[[[1]
  [2]]] (1, 2, 1)
[[[1]
  [2]]] (1, 2, 1)
[[[1 2]]] (1, 1, 2)"
numpy.ma.expand_dims,Expand the shape of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int or tuple of ints', 'description': 'Position in the expanded axes where the new axis (or axes) is placed.Deprecated since version 1.13.0: Passing an axis where axis > a.ndim will be treated asaxis == a.ndim, and passing axis < -a.ndim - 1 willbe treated as axis == 0. This behavior is deprecated.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray', 'description': 'View of a with the number of dimensions increased.'}]}]",">>> import numpy as np
>>> x = np.array([1, 2])
>>> x.shape
(2,)
>>> y = np.expand_dims(x, axis=0)
>>> y
array([[1, 2]])
>>> y.shape
(1, 2)
>>> y = np.expand_dims(x, axis=1)
>>> y
array([[1],
       [2]])
>>> y.shape
(2, 1)
>>> y = np.expand_dims(x, axis=(0, 1))
>>> y
array([[[1, 2]]])
>>> y = np.expand_dims(x, axis=(2, 0))
>>> y
array([[[1],
        [2]]])
>>> np.newaxis is None
True"
numpy.ma.squeeze,Remove axes of length one from a.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Selects a subset of the entries of length one in theshape. If an axis is selected with shape entry greater thanone, an error is raised.'}]}, {'Returns': [{'name': 'squeezed', 'type': 'MaskedArray', 'description': 'The input array, but with all or a subset of thedimensions of length 1 removed. This is always a itselfor a view into a. Note that if all axes are squeezed,the result is a 0d array and not a scalar.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If axis is not None, and an axis being squeezed is not of length 1'}]}]",">>> import numpy as np
>>> x = np.array([[[0], [1], [2]]])
>>> x.shape
(1, 3, 1)
>>> np.squeeze(x).shape
(3,)
>>> np.squeeze(x, axis=0).shape
(3, 1)
>>> np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size
not equal to one
>>> np.squeeze(x, axis=2).shape
(1, 3)
>>> x = np.array([[1234]])
>>> x.shape
(1, 1)
>>> np.squeeze(x)
array(1234)  # 0d array
>>> np.squeeze(x).shape
()
>>> np.squeeze(x)[()]
1234"
numpy.ma.MaskedArray.squeeze,method,[],
numpy.ma.stack,Join a sequence of arrays along a new axis.,"[{'Parameters': [{'name': 'arrays', 'type': 'sequence of ndarrays', 'description': 'Each array must have the same shape. In the case of a single ndarrayarray_like input, it will be treated as a sequence of arrays; i.e.,each element along the zeroth axis is treated as a separate array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis in the result array along which the input arrays are stacked.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'If provided, the destination to place the result. The shape must becorrect, matching that of what stack would have returned if noout argument were specified.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.24.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.New in version 1.24.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The stacked array has one more dimension than the input arrays.'}]}]",">>> import numpy as np
>>> rng = np.random.default_rng()
>>> arrays = [rng.normal(size=(3,4)) for _ in range(10)]
>>> np.stack(arrays, axis=0).shape
(10, 3, 4)
>>> np.stack(arrays, axis=1).shape
(3, 10, 4)
>>> np.stack(arrays, axis=2).shape
(3, 4, 10)
>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.stack((a, b))
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.stack((a, b), axis=-1)
array([[1, 4],
       [2, 5],
       [3, 6]])"
numpy.ma.column_stack,Stack 1-D arrays as columns into a 2-D array.,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of 1-D or 2-D arrays.', 'description': 'Arrays to stack. All of them must have the same first dimension.'}]}, {'Returns': [{'name': 'stacked', 'type': '2-D array', 'description': 'The array formed by stacking the given arrays.'}]}]",">>> import numpy as np
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.column_stack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])"
numpy.ma.concatenate,Concatenate a sequence of arrays along the given axis.,"[{'Parameters': [{'name': 'arrays', 'type': 'sequence of array_like', 'description': 'The arrays must have the same shape, except in the dimensioncorresponding to axis (the first, by default).'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which the arrays will be joined. Default is 0.'}]}, {'Returns': [{'name': 'result', 'type': 'MaskedArray', 'description': 'The concatenated array with any masked entries preserved.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.arange(3)
>>> a[1] = ma.masked
>>> b = ma.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
masked_array(data=[2, 3, 4],
             mask=False,
       fill_value=999999)
>>> ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)"
numpy.ma.dstack,Stack arrays in sequence depth wise (along third axis).,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of arrays', 'description': 'The arrays must have the same shape along all but the third axis.1-D or 2-D arrays must have the same shape.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The array formed by stacking the given arrays, will be at least 3-D.'}]}]",">>> import numpy as np
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.dstack((a,b))
array([[[1, 2],
        [2, 3],
        [3, 4]]])
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[2],[3],[4]])
>>> np.dstack((a,b))
array([[[1, 2]],
       [[2, 3]],
       [[3, 4]]])"
numpy.ma.hstack,Stack arrays in sequence horizontally (column wise).,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of ndarrays', 'description': 'The arrays must have the same shape along all but the second axis,except 1-D arrays which can be any length. In the case of a singlearray_like input, it will be treated as a sequence of arrays; i.e.,each element along the zeroth axis is treated as a separate array.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.24.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.New in version 1.24.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The array formed by stacking the given arrays.'}]}]",">>> import numpy as np
>>> a = np.array((1,2,3))
>>> b = np.array((4,5,6))
>>> np.hstack((a,b))
array([1, 2, 3, 4, 5, 6])
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[4],[5],[6]])
>>> np.hstack((a,b))
array([[1, 4],
       [2, 5],
       [3, 6]])"
numpy.ma.hsplit,Split an array into multiple sub-arrays horizontally (column-wise).,[],">>> import numpy as np
>>> x = np.arange(16.0).reshape(4, 4)
>>> x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
>>> np.hsplit(x, 2)
[array([[  0.,   1.],
       [  4.,   5.],
       [  8.,   9.],
       [12.,  13.]]),
 array([[  2.,   3.],
       [  6.,   7.],
       [10.,  11.],
       [14.,  15.]])]
>>> np.hsplit(x, np.array([3, 6]))
[array([[ 0.,   1.,   2.],
       [ 4.,   5.,   6.],
       [ 8.,   9.,  10.],
       [12.,  13.,  14.]]),
 array([[ 3.],
       [ 7.],
       [11.],
       [15.]]),
 array([], shape=(4, 0), dtype=float64)]
>>> x = np.arange(8.0).reshape(2, 2, 2)
>>> x
array([[[0.,  1.],
        [2.,  3.]],
       [[4.,  5.],
        [6.,  7.]]])
>>> np.hsplit(x, 2)
[array([[[0.,  1.]],
       [[4.,  5.]]]),
 array([[[2.,  3.]],
       [[6.,  7.]]])]
>>> x = np.array([0, 1, 2, 3, 4, 5])
>>> np.hsplit(x, 2)
[array([0, 1, 2]), array([3, 4, 5])]"
numpy.ma.mr_,Translate slice objects to concatenation along the first axis.,[],">>> import numpy as np
>>> np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]
masked_array(data=[1, 2, 3, ..., 4, 5, 6],
             mask=False,
       fill_value=999999)"
numpy.ma.vstack,Stack arrays in sequence vertically (row wise).,"[{'Parameters': [{'name': 'tup', 'type': 'sequence of ndarrays', 'description': 'The arrays must have the same shape along all but the first axis.1-D arrays must have the same length. In the case of a singlearray_like input, it will be treated as a sequence of arrays; i.e.,each element along the zeroth axis is treated as a separate array.'}, {'name': 'dtype', 'type': 'str or dtype', 'description': 'If provided, the destination array will have this dtype. Cannot beprovided together with out.New in version 1.24.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur. Defaults to ‘same_kind’.New in version 1.24.'}]}, {'Returns': [{'name': 'stacked', 'type': 'ndarray', 'description': 'The array formed by stacking the given arrays, will be at least 2-D.'}]}]",">>> import numpy as np
>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.vstack((a,b))
array([[1, 2, 3],
       [4, 5, 6]])
>>> a = np.array([[1], [2], [3]])
>>> b = np.array([[4], [5], [6]])
>>> np.vstack((a,b))
array([[1],
       [2],
       [3],
       [4],
       [5],
       [6]])"
numpy.ma.append,Append values to the end of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Values are appended to a copy of this array.'}, {'name': 'b', 'type': 'array_like', 'description': 'These values are appended to a copy of a.  It must be of thecorrect shape (the same shape as a, excluding axis).  If axisis not specified, b can be any shape and will be flattenedbefore use.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which v are appended.  If axis is not given,both a and b are flattened before use.'}]}, {'Returns': [{'name': 'append', 'type': 'MaskedArray', 'description': 'A copy of a with b appended to axis.  Note that appenddoes not occur in-place: a new array is allocated and filled.  Ifaxis is None, the result is a flattened array.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_values([1, 2, 3], 2)
>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
>>> ma.append(a, b)
masked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],
             mask=[False,  True, False, False, False, False,  True, False,
                   False],
       fill_value=999999)"
numpy.ma.make_mask,Create a boolean mask from an array.,"[{'Parameters': [{'name': 'm', 'type': 'array_like', 'description': 'Potential mask.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Whether to return a copy of m (True) or m itself (False).'}, {'name': 'shrink', 'type': 'bool, optional', 'description': 'Whether to shrink m to nomask if all its values are False.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data-type of the output mask. By default, the output mask has adtype of MaskType (bool). If the dtype is flexible, each field hasa boolean dtype. This is ignored when m is nomask, in whichcase nomask is always returned.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray', 'description': 'A boolean mask derived from m.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> m = [True, False, True, True]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 1, 1]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 2, -3]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = np.zeros(4)
>>> m
array([0., 0., 0., 0.])
>>> ma.make_mask(m)
False
>>> ma.make_mask(m, shrink=False)
array([False, False, False, False])
>>> m = [1, 0, 1, 1]
>>> n = [0, 1, 0, 0]
>>> arr = []
>>> for man, mouse in zip(m, n):
...     arr.append((man, mouse))
>>> arr
[(1, 0), (0, 1), (1, 0), (1, 0)]
>>> dtype = np.dtype({'names':['man', 'mouse'],
...                   'formats':[np.int64, np.int64]})
>>> arr = np.array(arr, dtype=dtype)
>>> arr
array([(1, 0), (0, 1), (1, 0), (1, 0)],
      dtype=[('man', '<i8'), ('mouse', '<i8')])
>>> ma.make_mask(arr, dtype=dtype)
array([(True, False), (False, True), (True, False), (True, False)],
      dtype=[('man', '|b1'), ('mouse', '|b1')])"
numpy.ma.make_mask_none,"Return a boolean mask of the given shape, filled with False.","[{'Parameters': [{'name': 'newshape', 'type': 'tuple', 'description': 'A tuple indicating the shape of the mask.'}, {'name': 'dtype', 'type': '{None, dtype}, optional', 'description': 'If None, use a MaskType instance. Otherwise, use a new datatype withthe same fields as dtype, converted to boolean types.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray', 'description': 'An ndarray of appropriate shape and dtype, filled with False.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> ma.make_mask_none((3,))
array([False, False, False])
>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_none((3,), dtype=dtype)
array([(False, False), (False, False), (False, False)],
      dtype=[('foo', '|b1'), ('bar', '|b1')])"
numpy.ma.mask_or,Combine two masks with the logical_or operator.,"[{'Parameters': [{'name': 'm1, m2', 'type': 'array_like', 'description': 'Input masks.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'If copy is False and one of the inputs is nomask, return a viewof the other input mask. Defaults to False.'}, {'name': 'shrink', 'type': 'bool, optional', 'description': 'Whether to shrink the output to nomask if all its values areFalse. Defaults to True.'}]}, {'Returns': [{'name': 'mask', 'type': 'output mask', 'description': 'The result masks values that are masked in either m1 or m2.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If m1 and m2 have different flexible dtypes.'}]}]",">>> import numpy as np
>>> m1 = np.ma.make_mask([0, 1, 1, 0])
>>> m2 = np.ma.make_mask([1, 0, 0, 0])
>>> np.ma.mask_or(m1, m2)
array([ True,  True,  True, False])"
numpy.ma.make_mask_descr,Construct a dtype description list from a given dtype.,"[{'Parameters': [{'name': 'ndtype', 'type': 'dtype', 'description': 'The dtype to convert.'}]}, {'Returns': [{'name': 'result', 'type': 'dtype', 'description': 'A dtype that looks like ndtype, the type of all fields is boolean.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_descr(dtype)
dtype([('foo', '|b1'), ('bar', '|b1')])
>>> ma.make_mask_descr(np.float32)
dtype('bool')"
numpy.ma.masked_array.mask,property,[],
numpy.ma.ndenumerate,Multidimensional index iterator.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'An array with (possibly) masked elements.'}, {'name': 'compressed', 'type': 'bool, optional', 'description': 'If True (default), masked elements are skipped.'}]}]",">>> import numpy as np
>>> a = np.ma.arange(9).reshape((3, 3))
>>> a[1, 0] = np.ma.masked
>>> a[1, 2] = np.ma.masked
>>> a[2, 1] = np.ma.masked
>>> a
masked_array(
  data=[[0, 1, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False, False, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> for index, x in np.ma.ndenumerate(a):
...     print(index, x)
(0, 0) 0
(0, 1) 1
(0, 2) 2
(1, 1) 4
(2, 0) 6
(2, 2) 8
>>> for index, x in np.ma.ndenumerate(a, compressed=False):
...     print(index, x)
(0, 0) 0
(0, 1) 1
(0, 2) 2
(1, 0) --
(1, 1) 4
(1, 2) --
(2, 0) 6
(2, 1) --
(2, 2) 8"
numpy.ma.flatnotmasked_contiguous,Find contiguous unmasked data in a masked array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The input array.'}]}, {'Returns': [{'name': 'slice_list', 'type': 'list', 'description': 'A sorted sequence of slice objects (start index, end index).'}]}]",">>> import numpy as np
>>> a = np.ma.arange(10)
>>> np.ma.flatnotmasked_contiguous(a)
[slice(0, 10, None)]
>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])
>>> np.ma.flatnotmasked_contiguous(a)
[slice(3, 5, None), slice(6, 9, None)]
>>> a[:] = np.ma.masked
>>> np.ma.flatnotmasked_contiguous(a)
[]"
numpy.ma.flatnotmasked_edges,Find the indices of the first and last unmasked values.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input 1-D MaskedArray'}]}, {'Returns': [{'name': 'edges', 'type': 'ndarray or None', 'description': 'The indices of first and last non-masked value in the array.Returns None if all values are masked.'}]}]",">>> import numpy as np
>>> a = np.ma.arange(10)
>>> np.ma.flatnotmasked_edges(a)
array([0, 9])
>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])
>>> np.ma.flatnotmasked_edges(a)
array([3, 8])
>>> a[:] = np.ma.masked
>>> print(np.ma.flatnotmasked_edges(a))
None"
numpy.ma.notmasked_contiguous,Find contiguous unmasked data in a masked array along the given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to perform the operation.If None (default), applies to a flattened version of the array, and thisis the same as flatnotmasked_contiguous.'}]}, {'Returns': [{'name': 'endpoints', 'type': 'list', 'description': 'A list of slices (start and end indexes) of unmasked indexesin the array.If the input is 2d and axis is specified, the result is a list of lists.'}]}]",">>> import numpy as np
>>> a = np.arange(12).reshape((3, 4))
>>> mask = np.zeros_like(a)
>>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0
>>> ma = np.ma.array(a, mask=mask)
>>> ma
masked_array(
  data=[[0, --, 2, 3],
        [--, --, --, 7],
        [8, --, --, 11]],
  mask=[[False,  True, False, False],
        [ True,  True,  True, False],
        [False,  True,  True, False]],
  fill_value=999999)
>>> np.array(ma[~ma.mask])
array([ 0,  2,  3,  7, 8, 11])
>>> np.ma.notmasked_contiguous(ma)
[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]
>>> np.ma.notmasked_contiguous(ma, axis=0)
[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]
>>> np.ma.notmasked_contiguous(ma, axis=1)
[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]"
numpy.ma.notmasked_edges,Find the indices of the first and last unmasked values along an axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to perform the operation.If None (default), applies to a flattened version of the array.'}]}, {'Returns': [{'name': 'edges', 'type': 'ndarray or list', 'description': 'An array of start and end indexes if there are any masked data inthe array. If there are no masked data in the array, edges is alist of the first and last index.'}]}]",">>> import numpy as np
>>> a = np.arange(9).reshape((3, 3))
>>> m = np.zeros_like(a)
>>> m[1:, 1:] = 1
>>> am = np.ma.array(a, mask=m)
>>> np.array(am[~am.mask])
array([0, 1, 2, 3, 6])
>>> np.ma.notmasked_edges(am)
array([0, 6])"
numpy.ma.clump_masked,"Returns a list of slices corresponding to the masked clumps of a 1-D array.
(A “clump” is defined as a contiguous region of the array).","[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'A one-dimensional masked array.'}]}, {'Returns': [{'name': 'slices', 'type': 'list of slice', 'description': 'The list of slices, one for each continuous region of masked elementsin a.'}]}]",">>> import numpy as np
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_masked(a)
[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]"
numpy.ma.clump_unmasked,"Return list of slices corresponding to the unmasked clumps of a 1-D array.
(A “clump” is defined as a contiguous region of the array).","[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'A one-dimensional masked array.'}]}, {'Returns': [{'name': 'slices', 'type': 'list of slice', 'description': 'The list of slices, one for each continuous region of unmaskedelements in a.'}]}]",">>> import numpy as np
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_unmasked(a)
[slice(3, 6, None), slice(7, 8, None)]"
numpy.ma.mask_cols,Mask columns of a 2D array that contain masked values.,[],">>> import numpy as np
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = np.ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> np.ma.mask_cols(a)
masked_array(
  data=[[0, --, 0],
        [0, --, 0],
        [0, --, 0]],
  mask=[[False,  True, False],
        [False,  True, False],
        [False,  True, False]],
  fill_value=1)"
numpy.ma.mask_rowcols,Mask rows and/or columns of a 2D array that contain masked values.,"[{'Parameters': [{'name': 'a', 'type': 'array_like, MaskedArray', 'description': 'The array to mask.  If not a MaskedArray instance (or if no arrayelements are masked), the result is a MaskedArray with mask setto nomask (False). Must be a 2D array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to perform the operation. If None, applies to aflattened version of the array.'}]}, {'Returns': [{'name': 'a', 'type': 'MaskedArray', 'description': 'A modified version of the input array, masked depending on the valueof the axis parameter.'}]}, {'Raises': [{'name': 'NotImplementedError', 'type': None, 'description': 'If input array a is not 2D.'}]}]",">>> import numpy as np
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = np.ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> np.ma.mask_rowcols(a)
masked_array(
  data=[[0, --, 0],
        [--, --, --],
        [0, --, 0]],
  mask=[[False,  True, False],
        [ True,  True,  True],
        [False,  True, False]],
  fill_value=1)"
numpy.ma.mask_rows,Mask rows of a 2D array that contain masked values.,[],">>> import numpy as np
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = np.ma.masked_equal(a, 1)
>>> a
masked_array(
  data=[[0, 0, 0],
        [0, --, 0],
        [0, 0, 0]],
  mask=[[False, False, False],
        [False,  True, False],
        [False, False, False]],
  fill_value=1)
>>> np.ma.mask_rows(a)
masked_array(
  data=[[0, 0, 0],
        [--, --, --],
        [0, 0, 0]],
  mask=[[False, False, False],
        [ True,  True,  True],
        [False, False, False]],
  fill_value=1)"
numpy.ma.harden_mask,"Force the mask to hard, preventing unmasking by assignment.",[],
numpy.ma.soften_mask,"Force the mask to soft (default), allowing unmasking by assignment.",[],
numpy.ma.MaskedArray.harden_mask,method,[],
numpy.ma.MaskedArray.soften_mask,method,[],
numpy.ma.MaskedArray.shrink_mask,method,"[{'Parameters': [{'name': 'None', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'None', 'type': None, 'description': ''}]}]",">>> import numpy as np
>>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
>>> x.mask
array([[False, False],
       [False, False]])
>>> x.shrink_mask()
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> x.mask
False"
numpy.ma.MaskedArray.unshare_mask,method,[],
numpy.ma.asarray,Convert the input to a masked array of the given data-type.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data, in any form that can be converted to a masked array. Thisincludes lists, lists of tuples, tuples, tuples of tuples, tuplesof lists, ndarrays and masked arrays.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Whether to use row-major (‘C’) or column-major (‘FORTRAN’) memoryrepresentation.  Default is ‘C’.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Masked array interpretation of a.'}]}]",">>> import numpy as np
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asarray(x))
<class 'numpy.ma.MaskedArray'>"
numpy.ma.asanyarray,"Convert the input to a masked array, conserving subclasses.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data, in any form that can be converted to an array.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'By default, the data-type is inferred from the input data.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Whether to use row-major (‘C’) or column-major (‘FORTRAN’) memoryrepresentation.  Default is ‘C’.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'MaskedArray interpretation of a.'}]}]",">>> import numpy as np
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asanyarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asanyarray(x))
<class 'numpy.ma.MaskedArray'>"
numpy.ma.fix_invalid,Return input with invalid data masked and replaced by a fill value.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array, a (subclass of) ndarray.'}, {'name': 'mask', 'type': 'sequence, optional', 'description': 'Mask. Must be convertible to an array of booleans with the sameshape as data. True indicates a masked (i.e. invalid) data.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Whether to use a copy of a (True) or to fix a in place (False).Default is True.'}, {'name': 'fill_value', 'type': 'scalar, optional', 'description': 'Value used for fixing invalid data. Default is None, in which casethe a.fill_value is used.'}]}, {'Returns': [{'name': 'b', 'type': 'MaskedArray', 'description': 'The input array with invalid entries fixed.'}]}]",">>> import numpy as np
>>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
>>> x
masked_array(data=[--, -1.0, nan, inf],
             mask=[ True, False, False, False],
       fill_value=1e+20)
>>> np.ma.fix_invalid(x)
masked_array(data=[--, -1.0, --, --],
             mask=[ True, False,  True,  True],
       fill_value=1e+20)
>>> fixed = np.ma.fix_invalid(x)
>>> fixed.data
array([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])
>>> x.data
array([ 1., -1., nan, inf])"
numpy.ma.masked_equal,Mask an array where equal to a given value.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_equal(a, 2)
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=2)"
numpy.ma.masked_greater,Mask an array where greater than a given value.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater(a, 2)
masked_array(data=[0, 1, 2, --],
             mask=[False, False, False,  True],
       fill_value=999999)"
numpy.ma.masked_greater_equal,Mask an array where greater than or equal to a given value.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater_equal(a, 2)
masked_array(data=[0, 1, --, --],
             mask=[False, False,  True,  True],
       fill_value=999999)"
numpy.ma.masked_inside,Mask an array inside a given interval.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_inside(x, -0.3, 0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)
>>> ma.masked_inside(x, 0.3, -0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)"
numpy.ma.masked_invalid,Mask an array where invalid values occur (NaNs or infs).,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(5, dtype=float)
>>> a[2] = np.nan
>>> a[3] = np.inf
>>> a
array([ 0.,  1., nan, inf,  4.])
>>> ma.masked_invalid(a)
masked_array(data=[0.0, 1.0, --, --, 4.0],
             mask=[False, False,  True,  True, False],
       fill_value=1e+20)"
numpy.ma.masked_less,Mask an array where less than a given value.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less(a, 2)
masked_array(data=[--, --, 2, 3],
             mask=[ True,  True, False, False],
       fill_value=999999)"
numpy.ma.masked_less_equal,Mask an array where less than or equal to a given value.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less_equal(a, 2)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)"
numpy.ma.masked_not_equal,Mask an array where not equal to a given value.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_not_equal(a, 2)
masked_array(data=[--, --, 2, --],
             mask=[ True,  True, False,  True],
       fill_value=999999)"
numpy.ma.masked_object,Mask the array x where the data are exactly equal to value.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Array to mask'}, {'name': 'value', 'type': 'object', 'description': 'Comparison value'}, {'name': 'copy', 'type': '{True, False}, optional', 'description': 'Whether to return a copy of x.'}, {'name': 'shrink', 'type': '{True, False}, optional', 'description': 'Whether to collapse a mask full of False to nomask'}]}, {'Returns': [{'name': 'result', 'type': 'MaskedArray', 'description': 'The result of masking x where equal to value.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> food = np.array(['green_eggs', 'ham'], dtype=object)
>>> # don't eat spoiled food
>>> eat = ma.masked_object(food, 'green_eggs')
>>> eat
masked_array(data=[--, 'ham'],
             mask=[ True, False],
       fill_value='green_eggs',
            dtype=object)
>>> # plain ol` ham is boring
>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
>>> eat = ma.masked_object(fresh_food, 'green_eggs')
>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)
>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)"
numpy.ma.masked_outside,Mask an array outside a given interval.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_outside(x, -0.3, 0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)
>>> ma.masked_outside(x, 0.3, -0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)"
numpy.ma.masked_values,Mask using floating point equality.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Array to mask.'}, {'name': 'value', 'type': 'float', 'description': 'Masking value.'}, {'name': 'rtol, atol', 'type': 'float, optional', 'description': 'Tolerance parameters passed on to isclose'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Whether to return a copy of x.'}, {'name': 'shrink', 'type': 'bool, optional', 'description': 'Whether to collapse a mask full of False to nomask.'}]}, {'Returns': [{'name': 'result', 'type': 'MaskedArray', 'description': 'The result of masking x where approximately equal to value.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> x = np.array([1, 1.1, 2, 1.1, 3])
>>> ma.masked_values(x, 1.1)
masked_array(data=[1.0, --, 2.0, --, 3.0],
             mask=[False,  True, False,  True, False],
       fill_value=1.1)
>>> ma.masked_values(x, 2.1)
masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],
             mask=False,
       fill_value=2.1)
>>> ma.masked_values(x, 2.1, atol=1e-1)
masked_array(data=[1.0, 1.1, --, 1.1, 3.0],
             mask=[False, False,  True, False, False],
       fill_value=2.1)"
numpy.ma.masked_where,Mask an array where a condition is met.,"[{'Parameters': [{'name': 'condition', 'type': 'array_like', 'description': 'Masking condition.  When condition tests floating point values forequality, consider using masked_values instead.'}, {'name': 'a', 'type': 'array_like', 'description': 'Array to mask.'}, {'name': 'copy', 'type': 'bool', 'description': 'If True (default) make a copy of a in the result.  If False modifya in place and return a view.'}]}, {'Returns': [{'name': 'result', 'type': 'MaskedArray', 'description': 'The result of masking a where condition is True.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_where(a <= 2, a)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)
>>> b = ['a', 'b', 'c', 'd']
>>> ma.masked_where(a == 2, b)
masked_array(data=['a', 'b', --, 'd'],
             mask=[False, False,  True, False],
       fill_value='N/A',
            dtype='<U1')
>>> c = ma.masked_where(a <= 2, a)
>>> c
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([0, 1, 2, 3])
>>> c = ma.masked_where(a <= 2, a, copy=False)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([99,  1,  2,  3])
>>> a = np.arange(4)
>>> a = ma.masked_where(a == 2, a)
>>> a
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=999999)
>>> b = np.arange(4)
>>> b = ma.masked_where(b == 0, b)
>>> b
masked_array(data=[--, 1, 2, 3],
             mask=[ True, False, False, False],
       fill_value=999999)
>>> ma.masked_where(a == 3, b)
masked_array(data=[--, 1, --, --],
             mask=[ True, False,  True,  True],
       fill_value=999999)"
numpy.ma.compress_cols,Suppress whole columns of a 2-D array that contain masked values.,"[{'Parameters': [{'name': 'x', 'type': 'array_like, MaskedArray', 'description': 'The array to operate on.  If not a MaskedArray instance (or if no arrayelements are masked), x is interpreted as a MaskedArray withmask set to nomask. Must be a 2D array.'}]}, {'Returns': [{'name': 'compressed_array', 'type': 'ndarray', 'description': 'The compressed array.'}]}]",">>> import numpy as np
>>> a = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> np.ma.compress_cols(a)
array([[1, 2],
       [4, 5],
       [7, 8]])"
numpy.ma.compress_rowcols,"Suppress the rows and/or columns of a 2-D array that contain
masked values.","[{'Parameters': [{'name': 'x', 'type': 'array_like, MaskedArray', 'description': 'The array to operate on.  If not a MaskedArray instance (or if no arrayelements are masked), x is interpreted as a MaskedArray withmask set to nomask. Must be a 2D array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to perform the operation. Default is None.'}]}, {'Returns': [{'name': 'compressed_array', 'type': 'ndarray', 'description': 'The compressed array.'}]}]",">>> import numpy as np
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> x
masked_array(
  data=[[--, 1, 2],
        [--, 4, 5],
        [6, 7, 8]],
  mask=[[ True, False, False],
        [ True, False, False],
        [False, False, False]],
  fill_value=999999)
>>> np.ma.compress_rowcols(x)
array([[7, 8]])
>>> np.ma.compress_rowcols(x, 0)
array([[6, 7, 8]])
>>> np.ma.compress_rowcols(x, 1)
array([[1, 2],
       [4, 5],
       [7, 8]])"
numpy.ma.compress_rows,Suppress whole rows of a 2-D array that contain masked values.,"[{'Parameters': [{'name': 'x', 'type': 'array_like, MaskedArray', 'description': 'The array to operate on. If not a MaskedArray instance (or if no arrayelements are masked), x is interpreted as a MaskedArray withmask set to nomask. Must be a 2D array.'}]}, {'Returns': [{'name': 'compressed_array', 'type': 'ndarray', 'description': 'The compressed array.'}]}]",">>> import numpy as np
>>> a = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> np.ma.compress_rows(a)
array([[6, 7, 8]])"
numpy.ma.compressed,Return all the non-masked data as a 1-D array.,[],">>> import numpy as np
>>> import numpy as np
>>> x = np.array([[1, -1, 0], [2, -1, 3], [7, 4, -1]])
>>> masked_x = np.ma.masked_array(x, mask=x < 0)
>>> masked_x
masked_array(
  data=[[1, --, 0],
        [2, --, 3],
        [7, 4, --]],
  mask=[[False,  True, False],
        [False,  True, False],
        [False, False,  True]],
  fill_value=999999)
>>> np.ma.compressed(masked_x)
array([1, 0, 2, 3, 7, 4])"
numpy.ma.filled,"Return input as an ndarray, with masked values replaced by
fill_value.","[{'Parameters': [{'name': 'a', 'type': 'MaskedArray or array_like', 'description': 'An input object.'}, {'name': 'fill_value', 'type': 'array_like, optional.', 'description': 'Can be scalar or non-scalar. If non-scalar, theresulting filled array should be broadcastableover input array. Default is None.'}]}, {'Returns': [{'name': 'a', 'type': 'ndarray', 'description': 'The filled array.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                [1, 0, 0],
...                                                [0, 0, 0]])
>>> x.filled()
array([[999999,      1,      2],
       [999999,      4,      5],
       [     6,      7,      8]])
>>> x.filled(fill_value=333)
array([[333,   1,   2],
       [333,   4,   5],
       [  6,   7,   8]])
>>> x.filled(fill_value=np.arange(3))
array([[0, 1, 2],
       [0, 4, 5],
       [6, 7, 8]])"
numpy.ndarray,"An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)","[{'Parameters': [{'name': '(for the __new__ method; see Notes below)', 'type': None, 'description': ''}, {'name': 'shape', 'type': 'tuple of ints', 'description': 'Shape of created array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Any object that can be interpreted as a numpy data type.'}, {'name': 'buffer', 'type': 'object exposing buffer interface, optional', 'description': 'Used to fill the array with data.'}, {'name': 'offset', 'type': 'int, optional', 'description': 'Offset of array data in buffer.'}, {'name': 'strides', 'type': 'tuple of ints, optional', 'description': 'Strides of data in memory.'}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Row-major (C-style) or column-major (Fortran-style) order.'}]}, {'Attributes': [{'name': 'Tndarray', 'type': 'ndarray', 'description': 'View of the transposed array.'}, {'name': 'databuffer', 'type': 'buffer', 'description': 'Python buffer object pointing to the start of the array’s data.'}, {'name': 'dtypedtype object', 'type': 'dtype object', 'description': 'Data-type of the array’s elements.'}, {'name': 'flagsdict', 'type': 'dict', 'description': 'Information about the memory layout of the array.'}, {'name': 'flatnumpy.flatiter object', 'type': 'numpy.flatiter object', 'description': 'A 1-D iterator over the array.'}, {'name': 'imagndarray', 'type': 'ndarray', 'description': 'The imaginary part of the array.'}, {'name': 'realndarray', 'type': 'ndarray', 'description': 'The real part of the array.'}, {'name': 'sizeint', 'type': 'int', 'description': 'Number of elements in the array.'}, {'name': 'itemsizeint', 'type': 'int', 'description': 'Length of one array element in bytes.'}, {'name': 'nbytesint', 'type': 'int', 'description': 'Total bytes consumed by the elements of the array.'}, {'name': 'ndimint', 'type': 'int', 'description': 'Number of array dimensions.'}, {'name': 'shapetuple of ints', 'type': 'tuple of ints', 'description': 'Tuple of array dimensions.'}, {'name': 'stridestuple of ints', 'type': 'tuple of ints', 'description': 'Tuple of bytes to step in each dimension when traversing an array.'}, {'name': 'ctypesctypes object', 'type': 'ctypes object', 'description': 'An object to simplify the interaction of the array with the ctypes module.'}, {'name': 'basendarray', 'type': 'ndarray', 'description': 'Base object if memory is from some other object.'}]}]",">>> import numpy as np
>>> np.ndarray(shape=(2,2), dtype=float, order='F')
array([[0.0e+000, 0.0e+000], # random
       [     nan, 2.5e-323]])
>>> np.ndarray((2,), buffer=np.array([1,2,3]),
...            offset=np.int_().itemsize,
...            dtype=int) # offset = 1*itemsize, i.e. skip first element
array([2, 3])"
numpy.ma.MaskedArray.compressed,method,"[{'Returns': [{'name': 'data', 'type': 'ndarray', 'description': 'A new ndarray holding the non-masked data is returned.'}]}]",">>> import numpy as np
>>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
>>> x.compressed()
array([0, 1])
>>> type(x.compressed())
<class 'numpy.ndarray'>
>>> arr = [[1, 2], [3, 4]]
>>> mask = [[1, 0], [0, 1]]
>>> x = np.ma.array(arr, mask=mask)
>>> x.compressed()
array([2, 3])"
numpy.ma.MaskedArray.filled,method,"[{'Parameters': [{'name': 'fill_value', 'type': 'array_like, optional', 'description': 'The value to use for invalid entries. Can be scalar or non-scalar.If non-scalar, the resulting ndarray must be broadcastable overinput array. Default is None, in which case, the fill_valueattribute of the array is used instead.'}]}, {'Returns': [{'name': 'filled_array', 'type': 'ndarray', 'description': 'A copy of self with invalid entries replaced by fill_value(be it the function argument or the attribute of self), orself itself as an ndarray if there are no invalid entries tobe replaced.'}]}]",">>> import numpy as np
>>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)
>>> x.filled()
array([   1,    2, -999,    4, -999])
>>> x.filled(fill_value=1000)
array([   1,    2, 1000,    4, 1000])
>>> type(x.filled())
<class 'numpy.ndarray'>
>>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)
>>> m = np.ma.array(x, mask=[(True, False), (False, True)])
>>> m.filled()
rec.array([(999999,      2), (    -3, 999999)],
          dtype=[('f0', '<i8'), ('f1', '<i8')])"
numpy.ma.MaskedArray.tofile,method,"[{'Raises': [{'name': 'NotImplementedError', 'type': None, 'description': 'When tofile is called.'}]}]",
numpy.ma.MaskedArray.tolist,method,"[{'Parameters': [{'name': 'fill_value', 'type': 'scalar, optional', 'description': 'The value to use for invalid entries. Default is None.'}]}, {'Returns': [{'name': 'result', 'type': 'list', 'description': 'The Python list representation of the masked array.'}]}]",">>> import numpy as np
>>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)
>>> x.tolist()
[[1, None, 3], [None, 5, None], [7, None, 9]]
>>> x.tolist(-999)
[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]"
numpy.ma.MaskedArray.torecords,method,"[{'Parameters': [{'name': 'None', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'record', 'type': 'ndarray', 'description': 'A new flexible-type ndarray with two fields: the first elementcontaining a value, the second element containing the correspondingmask boolean. The returned record shape matches self.shape.'}]}]",">>> import numpy as np
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.toflex()
array([[(1, False), (2,  True), (3, False)],
       [(4,  True), (5, False), (6,  True)],
       [(7, False), (8,  True), (9, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])"
numpy.ma.MaskedArray.tobytes,method,"[{'Parameters': [{'name': 'fill_value', 'type': 'scalar, optional', 'description': 'Value used to fill in the masked values. Default is None, in whichcase MaskedArray.fill_value is used.'}, {'name': 'order', 'type': '{‘C’,’F’,’A’}, optional', 'description': 'Order of the data item in the copy. Default is ‘C’.‘C’   – C order (row major).‘F’   – Fortran order (column major).‘A’   – Any, current order of array.None  – Same as ‘A’.'}]}]",">>> import numpy as np
>>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
>>> x.tobytes()
b'\x01\x00\x00\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00?B\x0f\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00'"
numpy.ma.common_fill_value,"Return the common filling value of two masked arrays, if any.","[{'Parameters': [{'name': 'a, b', 'type': 'MaskedArray', 'description': 'The masked arrays for which to compare fill values.'}]}, {'Returns': [{'name': 'fill_value', 'type': 'scalar or None', 'description': 'The common fill value, or None.'}]}]",">>> import numpy as np
>>> x = np.ma.array([0, 1.], fill_value=3)
>>> y = np.ma.array([0, 1.], fill_value=3)
>>> np.ma.common_fill_value(x, y)
3.0"
numpy.ma.default_fill_value,Return the default fill value for the argument object.,"[{'Parameters': [{'name': 'obj', 'type': 'ndarray, dtype or scalar', 'description': 'The array data-type or scalar for which the default fill valueis returned.'}]}, {'Returns': [{'name': 'fill_value', 'type': 'scalar', 'description': 'The default fill value.'}]}]",">>> import numpy as np
>>> np.ma.default_fill_value(1)
999999
>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
1e+20
>>> np.ma.default_fill_value(np.dtype(complex))
(1e+20+0j)"
numpy.ma.maximum_fill_value,Return the minimum value that can be represented by the dtype of an object.,"[{'Parameters': [{'name': 'obj', 'type': 'ndarray, dtype or scalar', 'description': 'An object that can be queried for it’s numeric type.'}]}, {'Returns': [{'name': 'val', 'type': 'scalar', 'description': 'The minimum representable value.'}]}, {'Raises': [{'name': 'TypeError', 'type': None, 'description': 'If obj isn’t a suitable numeric type.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.maximum_fill_value(a)
-128
>>> a = np.int32()
>>> ma.maximum_fill_value(a)
-2147483648
>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.maximum_fill_value(a)
-128
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.maximum_fill_value(a)
-inf"
numpy.ma.minimum_fill_value,Return the maximum value that can be represented by the dtype of an object.,"[{'Parameters': [{'name': 'obj', 'type': 'ndarray, dtype or scalar', 'description': 'An object that can be queried for it’s numeric type.'}]}, {'Returns': [{'name': 'val', 'type': 'scalar', 'description': 'The maximum representable value.'}]}, {'Raises': [{'name': 'TypeError', 'type': None, 'description': 'If obj isn’t a suitable numeric type.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.minimum_fill_value(a)
127
>>> a = np.int32()
>>> ma.minimum_fill_value(a)
2147483647
>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.minimum_fill_value(a)
127
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.minimum_fill_value(a)
inf"
numpy.ma.set_fill_value,"Set the filling value of a, if a is a masked array.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'fill_value', 'type': 'dtype', 'description': 'Filling value. A consistency test is performed to make surethe value is compatible with the dtype of a.'}]}, {'Returns': [{'name': 'None', 'type': None, 'description': 'Nothing returned by this function.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a = ma.masked_where(a < 3, a)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=999999)
>>> ma.set_fill_value(a, -999)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=-999)
>>> a = list(range(5))
>>> a
[0, 1, 2, 3, 4]
>>> ma.set_fill_value(a, 100)
>>> a
[0, 1, 2, 3, 4]
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> ma.set_fill_value(a, 100)
>>> a
array([0, 1, 2, 3, 4])"
numpy.ma.MaskedArray.get_fill_value,method,[],">>> import numpy as np
>>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
...     np.ma.array([0, 1], dtype=dt).get_fill_value()
...
np.int64(999999)
np.int64(999999)
np.float64(1e+20)
np.complex128(1e+20+0j)
>>> x = np.ma.array([0, 1.], fill_value=-np.inf)
>>> x.fill_value
np.float64(-inf)
>>> x.fill_value = np.pi
>>> x.fill_value
np.float64(3.1415926535897931)
>>> x.fill_value = None
>>> x.fill_value
np.float64(1e+20)"
numpy.ma.MaskedArray.set_fill_value,method,[],
numpy.ma.anom,"Compute the anomalies (deviations from the arithmetic mean)
along the given axis.","[{'Parameters': [{'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which the anomalies are taken.The default is to use the mean of the flattened array as reference.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type to use in computing the variance. For arrays of integer typethe default is float32; for arrays of float types it is the same asthe array type.'}, {'name': 'Type to use in computing the variance. For arrays of integer type', 'type': None, 'description': 'the default is float32; for arrays of float types it is the same asthe array type.'}]}]",">>> import numpy as np
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)"
numpy.ma.anomalies,"Compute the anomalies (deviations from the arithmetic mean)
along the given axis.","[{'Parameters': [{'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which the anomalies are taken.The default is to use the mean of the flattened array as reference.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type to use in computing the variance. For arrays of integer typethe default is float32; for arrays of float types it is the same asthe array type.'}, {'name': 'Type to use in computing the variance. For arrays of integer type', 'type': None, 'description': 'the default is float32; for arrays of float types it is the same asthe array type.'}]}]",">>> import numpy as np
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)"
numpy.ma.average,Return the weighted average of array over the given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Data to be averaged.Masked entries are not taken into account in the computation.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which to average a.  The default,axis=None, will average over all of the elements of the input array.If axis is a tuple of ints, averaging is performed on all of the axesspecified in the tuple instead of a single axis or all the axes asbefore.'}, {'name': 'weights', 'type': 'array_like, optional', 'description': 'An array of weights associated with the values in a. Each value ina contributes to the average according to its associated weight.The array of weights must be the same shape as a if no axis isspecified, otherwise the weights must have dimensions and shapeconsistent with a along the specified axis.If weights=None, then all data in a are assumed to have aweight equal to one.The calculation is:avg = sum(a * weights) / sum(weights)where the sum is over all included elements.The only constraint on the values of weights is that sum(weights)must not be 0.'}, {'name': 'returned', 'type': 'bool, optional', 'description': 'Flag indicating whether a tuple (result, sum of weights)should be returned as output (True), or just the result (False).Default is False.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.Note: keepdims will not work with instances of numpy.matrixor other classes whose methods do not support keepdims.New in version 1.23.0.'}]}, {'Returns': [{'name': 'average, [sum_of_weights]', 'type': '(tuple of) scalar or MaskedArray', 'description': 'The average along the specified axis. When returned is True,return a tuple with the average as the first element and the sumof the weights as the second element. The return type is np.float64if a is of integer type and floats smaller than float64, or theinput data-type, otherwise. If returned, sum_of_weights is alwaysfloat64.'}]}, {'Raises': [{'name': 'ZeroDivisionError', 'type': None, 'description': 'When all weights along axis are zero. See numpy.ma.average for aversion robust to this type of error.'}, {'name': 'TypeError', 'type': None, 'description': 'When weights does not have the same shape as a, and axis=None.'}, {'name': 'ValueError', 'type': None, 'description': 'When weights does not have dimensions and shape consistent with aalong specified axis.'}]}]",">>> import numpy as np
>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
>>> np.ma.average(a, weights=[3, 1, 0, 0])
1.25
>>> x = np.ma.arange(6.).reshape(3, 2)
>>> x
masked_array(
  data=[[0., 1.],
        [2., 3.],
        [4., 5.]],
  mask=False,
  fill_value=1e+20)
>>> data = np.arange(8).reshape((2, 2, 2))
>>> data
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> np.ma.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])
masked_array(data=[3.4, 4.4],
         mask=[False, False],
   fill_value=1e+20)
>>> np.ma.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])
Traceback (most recent call last):
    ...
ValueError: Shape of weights must be consistent
with shape of a along specified axis.
>>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],
...                                 returned=True)
>>> avg
masked_array(data=[2.6666666666666665, 3.6666666666666665],
             mask=[False, False],
       fill_value=1e+20)
>>> np.ma.average(x, axis=1, keepdims=True)
masked_array(
  data=[[0.5],
        [2.5],
        [4.5]],
  mask=False,
  fill_value=1e+20)"
numpy.ma.conjugate,"Return the complex conjugate, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input value.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The complex conjugate of x, with same dtype as y.This is a scalar if x is a scalar.'}]}]",">>> np.conj is np.conjugate
True
>>> import numpy as np
>>> np.conjugate(1+2j)
(1-2j)
>>> x = np.eye(2) + 1j * np.eye(2)
>>> np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])"
numpy.ma.corrcoef,Return Pearson product-moment correlation coefficients.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'A 1-D or 2-D array containing multiple variables and observations.Each row of x represents a variable, and each column a singleobservation of all those variables. Also see rowvar below.'}, {'name': 'y', 'type': 'array_like, optional', 'description': 'An additional set of variables and observations. y has the sameshape as x.'}, {'name': 'rowvar', 'type': 'bool, optional', 'description': 'If rowvar is True (default), then each row represents avariable, with observations in the columns. Otherwise, the relationshipis transposed: each column represents a variable, while the rowscontain observations.'}, {'name': 'bias', 'type': '_NoValue, optional', 'description': 'Has no effect, do not use.Deprecated since version 1.10.0.'}, {'name': 'allow_masked', 'type': 'bool, optional', 'description': 'If True, masked values are propagated pair-wise: if a value is maskedin x, the corresponding value is masked in y.If False, raises an exception.  Because bias is deprecated, thisargument needs to be treated as keyword only to avoid a warning.'}, {'name': 'ddof', 'type': '_NoValue, optional', 'description': 'Has no effect, do not use.Deprecated since version 1.10.0.'}]}]",">>> import numpy as np
>>> x = np.ma.array([[0, 1], [1, 1]], mask=[0, 1, 0, 1])
>>> np.ma.corrcoef(x)
masked_array(
  data=[[--, --],
        [--, --]],
  mask=[[ True,  True],
        [ True,  True]],
  fill_value=1e+20,
  dtype=float64)"
numpy.ma.cov,Estimate the covariance matrix.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'A 1-D or 2-D array containing multiple variables and observations.Each row of x represents a variable, and each column a singleobservation of all those variables. Also see rowvar below.'}, {'name': 'y', 'type': 'array_like, optional', 'description': 'An additional set of variables and observations. y has the sameshape as x.'}, {'name': 'rowvar', 'type': 'bool, optional', 'description': 'If rowvar is True (default), then each row represents avariable, with observations in the columns. Otherwise, the relationshipis transposed: each column represents a variable, while the rowscontain observations.'}, {'name': 'bias', 'type': 'bool, optional', 'description': 'Default normalization (False) is by (N-1), where N is thenumber of observations given (unbiased estimate). If bias is True,then normalization is by N. This keyword can be overridden bythe keyword ddof in numpy versions >= 1.5.'}, {'name': 'allow_masked', 'type': 'bool, optional', 'description': 'If True, masked values are propagated pair-wise: if a value is maskedin x, the corresponding value is masked in y.If False, raises a ValueError exception when some values are missing.'}, {'name': 'ddof', 'type': '{None, int}, optional', 'description': 'If not None normalization is by (N - ddof), where N isthe number of observations; this overrides the value implied bybias. The default value is None.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'Raised if some values are missing and allow_masked is False.'}]}]",">>> import numpy as np
>>> x = np.ma.array([[0, 1], [1, 1]], mask=[0, 1, 0, 1])
>>> y = np.ma.array([[1, 0], [0, 1]], mask=[0, 0, 1, 1])
>>> np.ma.cov(x, y)
masked_array(
data=[[--, --, --, --],
      [--, --, --, --],
      [--, --, --, --],
      [--, --, --, --]],
mask=[[ True,  True,  True,  True],
      [ True,  True,  True,  True],
      [ True,  True,  True,  True],
      [ True,  True,  True,  True]],
fill_value=1e+20,
dtype=float64)"
numpy.ma.cumsum,Return the cumulative sum of the array elements over the given axis.,[],">>> import numpy as np
>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
>>> marr.cumsum()
masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
             mask=[False, False, False,  True,  True,  True, False, False,
                   False, False],
       fill_value=999999)"
numpy.ma.cumprod,Return the cumulative product of the array elements over the given axis.,[],
numpy.ma.mean,Returns the average of the array elements along given axis.,[],">>> import numpy as np
>>> a = np.ma.array([1,2,3], mask=[False, False, True])
>>> a
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.mean()
1.5"
numpy.ma.median,Compute the median along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array or object that can be converted to an array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the medians are computed. The default (None) isto compute the median along a flattened version of the array.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type will be cast if necessary.'}, {'name': 'overwrite_input', 'type': 'bool, optional', 'description': 'If True, then allow use of memory of input array (a) forcalculations. The input array will be modified by the call tomedian. This will save memory when you do not need to preservethe contents of the input array. Treat the input as undefined,but it will probably be fully or partially sorted. Default isFalse. Note that, if overwrite_input is True, and the inputis not already an ndarray, an error will be raised.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.'}]}, {'Returns': [{'name': 'median', 'type': 'ndarray', 'description': 'A new array holding the result is returned unless out isspecified, in which case a reference to out is returned.Return data-type is float64 for integers and floats smaller thanfloat64, or the input data-type, otherwise.'}]}]",">>> import numpy as np
>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
>>> np.ma.median(x)
1.5
>>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
>>> np.ma.median(x)
2.5
>>> np.ma.median(x, axis=-1, overwrite_input=True)
masked_array(data=[2.0, 5.0],
             mask=[False, False],
       fill_value=1e+20)"
numpy.ma.power,Returns element-wise base array raised to power from second array.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11.2, -3.973, 0.801, -1.41]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11.2, -3.973, 0.801, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)
>>> ma.power(masked_x, 2)
masked_array(data=[125.43999999999998, 15.784728999999999,
               0.6416010000000001, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)
>>> y = [-0.5, 2, 0, 17]
>>> masked_y = ma.masked_array(y, mask)
>>> masked_y
masked_array(data=[-0.5, 2.0, 0.0, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)
>>> ma.power(masked_x, masked_y)
masked_array(data=[0.2988071523335984, 15.784728999999999, 1.0, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)"
numpy.ma.prod,Return the product of the array elements over the given axis.,[],
numpy.ma.std,Returns the standard deviation of the array elements along given axis.,[],
numpy.ma.sum,Return the sum of the array elements over the given axis.,[],">>> import numpy as np
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.sum()
25
>>> x.sum(axis=1)
masked_array(data=[4, 5, 16],
             mask=[False, False, False],
       fill_value=999999)
>>> x.sum(axis=0)
masked_array(data=[8, 5, 12],
             mask=[False, False, False],
       fill_value=999999)
>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
<class 'numpy.int64'>"
numpy.ma.var,Compute the variance along the specified axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose variance is desired.  If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which the variance is computed.  The default is tocompute the variance of the flattened array.If this is a tuple of ints, a variance is performed over multiple axes,instead of a single axis or all the axes as before.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Type to use in computing the variance.  For arrays of integer typethe default is float64; for arrays of float types it is the same asthe array type.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  It must havethe same shape as the expected output, but the type is cast ifnecessary.'}, {'name': 'ddof', 'type': '{int, float}, optional', 'description': '“Delta Degrees of Freedom”: the divisor used in the calculation isN - ddof, where N represents the number of elements. Bydefault ddof is zero. See notes for details about use of ddof.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the var method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the variance. See reduce fordetails.New in version 1.20.0.'}, {'name': 'mean', 'type': 'array like, optional', 'description': 'Provide the mean to prevent its recalculation. The mean should havea shape as if it was calculated with keepdims=True.The axis for the calculation of the mean should be the same as used inthe call to this var function.New in version 2.0.0.'}, {'name': 'correction', 'type': '{int, float}, optional', 'description': 'Array API compatible name for the ddof parameter. Only one of themcan be provided at the same time.New in version 2.0.0.'}]}, {'Returns': [{'name': 'variance', 'type': 'ndarray, see dtype parameter above', 'description': 'If out=None, returns a new array containing the variance;otherwise, a reference to the output array is returned.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])
>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
np.float32(0.20250003)
>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> np.var(a)
6.833333333333333 # may vary
>>> np.var(a, where=[[True], [True], [False]])
4.0
>>> import numpy as np
>>> from timeit import timeit
>>>
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> mean = np.mean(a, axis=1, keepdims=True)
>>>
>>> g = globals()
>>> n = 10000
>>> t1 = timeit(""var = np.var(a, axis=1, mean=mean)"", globals=g, number=n)
>>> t2 = timeit(""var = np.var(a, axis=1)"", globals=g, number=n)
>>> print(f'Percentage execution time saved {100*(t2-t1)/t2:.0f}%')

Percentage execution time saved 32%"
numpy.ma.MaskedArray.anom,method,"[{'Parameters': [{'name': 'axis', 'type': 'int, optional', 'description': 'Axis over which the anomalies are taken.The default is to use the mean of the flattened array as reference.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type to use in computing the variance. For arrays of integer typethe default is float32; for arrays of float types it is the same asthe array type.'}, {'name': 'Type to use in computing the variance. For arrays of integer type', 'type': None, 'description': 'the default is float32; for arrays of float types it is the same asthe array type.'}]}]",">>> import numpy as np
>>> a = np.ma.array([1,2,3])
>>> a.anom()
masked_array(data=[-1.,  0.,  1.],
             mask=False,
       fill_value=1e+20)"
numpy.ma.MaskedArray.cumprod,method,[],
numpy.ma.MaskedArray.cumsum,method,[],">>> import numpy as np
>>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
>>> marr.cumsum()
masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
             mask=[False, False, False,  True,  True,  True, False, False,
                   False, False],
       fill_value=999999)"
numpy.ma.MaskedArray.mean,method,[],">>> import numpy as np
>>> a = np.ma.array([1,2,3], mask=[False, False, True])
>>> a
masked_array(data=[1, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.mean()
1.5"
numpy.ma.MaskedArray.prod,method,[],
numpy.ma.MaskedArray.std,method,[],
numpy.ma.MaskedArray.sum,method,[],">>> import numpy as np
>>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
>>> x
masked_array(
  data=[[1, --, 3],
        [--, 5, --],
        [7, --, 9]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> x.sum()
25
>>> x.sum(axis=1)
masked_array(data=[4, 5, 16],
             mask=[False, False, False],
       fill_value=999999)
>>> x.sum(axis=0)
masked_array(data=[8, 5, 12],
             mask=[False, False, False],
       fill_value=999999)
>>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
<class 'numpy.int64'>"
numpy.ma.MaskedArray.var,method,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose variance is desired.  If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which the variance is computed.  The default is tocompute the variance of the flattened array.If this is a tuple of ints, a variance is performed over multiple axes,instead of a single axis or all the axes as before.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Type to use in computing the variance.  For arrays of integer typethe default is float64; for arrays of float types it is the same asthe array type.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  It must havethe same shape as the expected output, but the type is cast ifnecessary.'}, {'name': 'ddof', 'type': '{int, float}, optional', 'description': '“Delta Degrees of Freedom”: the divisor used in the calculation isN - ddof, where N represents the number of elements. Bydefault ddof is zero. See notes for details about use of ddof.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the var method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the variance. See reduce fordetails.New in version 1.20.0.'}, {'name': 'mean', 'type': 'array like, optional', 'description': 'Provide the mean to prevent its recalculation. The mean should havea shape as if it was calculated with keepdims=True.The axis for the calculation of the mean should be the same as used inthe call to this var function.New in version 2.0.0.'}, {'name': 'correction', 'type': '{int, float}, optional', 'description': 'Array API compatible name for the ddof parameter. Only one of themcan be provided at the same time.New in version 2.0.0.'}]}, {'Returns': [{'name': 'variance', 'type': 'ndarray, see dtype parameter above', 'description': 'If out=None, returns a new array containing the variance;otherwise, a reference to the output array is returned.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, 4]])
>>> np.var(a)
1.25
>>> np.var(a, axis=0)
array([1.,  1.])
>>> np.var(a, axis=1)
array([0.25,  0.25])
>>> a = np.zeros((2, 512*512), dtype=np.float32)
>>> a[0, :] = 1.0
>>> a[1, :] = 0.1
>>> np.var(a)
np.float32(0.20250003)
>>> np.var(a, dtype=np.float64)
0.20249999932944759 # may vary
>>> ((1-0.55)**2 + (0.1-0.55)**2)/2
0.2025
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> np.var(a)
6.833333333333333 # may vary
>>> np.var(a, where=[[True], [True], [False]])
4.0
>>> import numpy as np
>>> from timeit import timeit
>>>
>>> a = np.array([[14, 8, 11, 10], [7, 9, 10, 11], [10, 15, 5, 10]])
>>> mean = np.mean(a, axis=1, keepdims=True)
>>>
>>> g = globals()
>>> n = 10000
>>> t1 = timeit(""var = np.var(a, axis=1, mean=mean)"", globals=g, number=n)
>>> t2 = timeit(""var = np.var(a, axis=1)"", globals=g, number=n)
>>> print(f'Percentage execution time saved {100*(t2-t1)/t2:.0f}%')

Percentage execution time saved 32%"
numpy.ma.argmax,"Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.","[{'Parameters': [{'name': 'axis', 'type': '{None, integer}', 'description': 'If None, the index is into the flattened array, otherwise alongthe specified axis'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.  If None, the output ofmaximum_fill_value(self._data) is used instead.'}, {'name': 'out', 'type': '{None, array}, optional', 'description': 'Array into which the result can be placed. Its type is preservedand it must be of the right shape to hold the output.'}]}, {'Returns': [{'name': 'index_array', 'type': '{integer_array}', 'description': ''}]}]",">>> import numpy as np
>>> a = np.arange(6).reshape(2,3)
>>> a.argmax()
5
>>> a.argmax(0)
array([1, 1, 1])
>>> a.argmax(1)
array([2, 2])"
numpy.ma.argmin,Return array of indices to the minimum values along the given axis.,"[{'Parameters': [{'name': 'axis', 'type': '{None, integer}', 'description': 'If None, the index is into the flattened array, otherwise alongthe specified axis'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.  If None, the output ofminimum_fill_value(self._data) is used instead.'}, {'name': 'out', 'type': '{None, array}, optional', 'description': 'Array into which the result can be placed. Its type is preservedand it must be of the right shape to hold the output.'}]}, {'Returns': [{'name': 'ndarray or scalar', 'type': None, 'description': 'If multi-dimension input, returns a new ndarray of indices to theminimum values along the given axis.  Otherwise, returns a scalarof index to the minimum values along the given axis.'}]}]",">>> import numpy as np
>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
>>> x.shape = (2,2)
>>> x
masked_array(
  data=[[--, --],
        [2, 3]],
  mask=[[ True,  True],
        [False, False]],
  fill_value=999999)
>>> x.argmin(axis=0, fill_value=-1)
array([0, 0])
>>> x.argmin(axis=0, fill_value=9)
array([1, 1])"
numpy.ma.max,Return the maximum along a given axis.,"[{'Parameters': [{'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis along which to operate.  By default, axis is None and theflattened input is used.If this is a tuple of ints, the maximum is selected over multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'array_like, optional', 'description': 'Alternative output array in which to place the result.  Mustbe of the same shape and buffer length as the expected output.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.If None, use the output of maximum_fill_value().'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'amax', 'type': 'array_like', 'description': 'New array holding the result.If out was specified, out is returned.'}]}]",">>> import numpy.ma as ma
>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]
>>> mask = [[0, 0], [1, 0], [1, 0]]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(
  data=[[-1.0, 2.5],
        [--, -2.0],
        [--, 0.0]],
  mask=[[False, False],
        [ True, False],
        [ True, False]],
  fill_value=1e+20)
>>> ma.max(masked_x)
2.5
>>> ma.max(masked_x, axis=0)
masked_array(data=[-1.0, 2.5],
             mask=[False, False],
       fill_value=1e+20)
>>> ma.max(masked_x, axis=1, keepdims=True)
masked_array(
  data=[[2.5],
        [-2.0],
        [0.0]],
  mask=[[False],
        [False],
        [False]],
  fill_value=1e+20)
>>> mask = [[1, 1], [1, 1], [1, 1]]
>>> masked_x = ma.masked_array(x, mask)
>>> ma.max(masked_x, axis=1)
masked_array(data=[--, --, --],
             mask=[ True,  True,  True],
       fill_value=1e+20,
            dtype=float64)"
numpy.ma.min,Return the minimum along a given axis.,"[{'Parameters': [{'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis along which to operate.  By default, axis is None and theflattened input is used.If this is a tuple of ints, the minimum is selected over multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'array_like, optional', 'description': 'Alternative output array in which to place the result.  Must be ofthe same shape and buffer length as the expected output.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.If None, use the output of minimum_fill_value.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'amin', 'type': 'array_like', 'description': 'New array holding the result.If out was specified, out is returned.'}]}]",">>> import numpy.ma as ma
>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]
>>> mask = [[1, 1, 0], [0, 0, 1]]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(
  data=[[--, --, 3.0],
        [0.2, -0.7, --]],
  mask=[[ True,  True, False],
        [False, False,  True]],
  fill_value=1e+20)
>>> ma.min(masked_x)
-0.7
>>> ma.min(masked_x, axis=-1)
masked_array(data=[3.0, -0.7],
             mask=[False, False],
        fill_value=1e+20)
>>> ma.min(masked_x, axis=0, keepdims=True)
masked_array(data=[[0.2, -0.7, 3.0]],
             mask=[[False, False, False]],
        fill_value=1e+20)
>>> mask = [[1, 1, 1,], [1, 1, 1]]
>>> masked_x = ma.masked_array(x, mask)
>>> ma.min(masked_x, axis=0)
masked_array(data=[--, --, --],
             mask=[ True,  True,  True],
        fill_value=1e+20,
            dtype=float64)"
numpy.ma.ptp,"Return (maximum - minimum) along the given dimension
(i.e. peak-to-peak value).","[{'Parameters': [{'name': 'axis', 'type': '{None, int}, optional', 'description': 'Axis along which to find the peaks.  If None (default) theflattened array is used.'}, {'name': 'out', 'type': '{None, array_like}, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type will be cast if necessary.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'ptp', 'type': 'ndarray.', 'description': 'A new array holding the result, unless out wasspecified, in which case a reference to out is returned.'}]}]",">>> import numpy as np
>>> x = np.ma.MaskedArray([[4, 9, 2, 10],
...                        [6, 9, 7, 12]])
>>> x.ptp(axis=1)
masked_array(data=[8, 6],
             mask=False,
       fill_value=999999)
>>> x.ptp(axis=0)
masked_array(data=[2, 0, 5, 2],
             mask=False,
       fill_value=999999)
>>> x.ptp()
10
>>> y = np.ma.MaskedArray([[1, 127],
...                        [0, 127],
...                        [-1, 127],
...                        [-2, 127]], dtype=np.int8)
>>> y.ptp(axis=1)
masked_array(data=[ 126,  127, -128, -127],
             mask=False,
       fill_value=np.int64(999999),
            dtype=int8)
>>> y.ptp(axis=1).view(np.uint8)
masked_array(data=[126, 127, 128, 129],
             mask=False,
       fill_value=np.uint64(999999),
            dtype=uint8)"
numpy.ma.diff,"Calculate the n-th discrete difference along the given axis.
The first difference is given by out[i] = a[i+1] - a[i] along
the given axis, higher differences are calculated by using diff
recursively.
Preserves the input mask.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array'}, {'name': 'n', 'type': 'int, optional', 'description': 'The number of times values are differenced. If zero, the inputis returned as-is.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which the difference is taken, default is thelast axis.'}, {'name': 'prepend, append', 'type': 'array_like, optional', 'description': 'Values to prepend or append to a along axis prior toperforming the difference.  Scalar values are expanded toarrays with length 1 in the direction of axis and the shapeof the input array in along all other axes.  Otherwise thedimension and shape must match a except along axis.'}]}, {'Returns': [{'name': 'diff', 'type': 'MaskedArray', 'description': 'The n-th differences. The shape of the output is the same as aexcept along axis where the dimension is smaller by n. Thetype of the output is the same as the type of the differencebetween any two elements of a. This is the same as the type ofa in most cases. A notable exception is datetime64, whichresults in a timedelta64 output array.'}]}]",">>> u8_arr = np.array([1, 0], dtype=np.uint8)
>>> np.ma.diff(u8_arr)
masked_array(data=[255],
             mask=False,
       fill_value=np.uint64(999999),
            dtype=uint8)
>>> u8_arr[1,...] - u8_arr[0,...]
np.uint8(255)
>>> i16_arr = u8_arr.astype(np.int16)
>>> np.ma.diff(i16_arr)
masked_array(data=[-1],
             mask=False,
       fill_value=np.int64(999999),
            dtype=int16)
>>> import numpy as np
>>> a = np.array([1, 2, 3, 4, 7, 0, 2, 3])
>>> x = np.ma.masked_where(a < 2, a)
>>> np.ma.diff(x)
masked_array(data=[--, 1, 1, 3, --, --, 1],
        mask=[ True, False, False, False,  True,  True, False],
    fill_value=999999)
>>> np.ma.diff(x, n=2)
masked_array(data=[--, 0, 2, --, --, --],
            mask=[ True, False, False,  True,  True,  True],
    fill_value=999999)
>>> a = np.array([[1, 3, 1, 5, 10], [0, 1, 5, 6, 8]])
>>> x = np.ma.masked_equal(a, value=1)
>>> np.ma.diff(x)
masked_array(
    data=[[--, --, --, 5],
            [--, --, 1, 2]],
    mask=[[ True,  True,  True, False],
            [ True,  True, False, False]],
    fill_value=1)
>>> np.ma.diff(x, axis=0)
masked_array(data=[[--, --, --, 1, -2]],
        mask=[[ True,  True,  True, False, False]],
    fill_value=1)"
numpy.ma.MaskedArray.argmax,method,"[{'Parameters': [{'name': 'axis', 'type': '{None, integer}', 'description': 'If None, the index is into the flattened array, otherwise alongthe specified axis'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.  If None, the output ofmaximum_fill_value(self._data) is used instead.'}, {'name': 'out', 'type': '{None, array}, optional', 'description': 'Array into which the result can be placed. Its type is preservedand it must be of the right shape to hold the output.'}]}, {'Returns': [{'name': 'index_array', 'type': '{integer_array}', 'description': ''}]}]",">>> import numpy as np
>>> a = np.arange(6).reshape(2,3)
>>> a.argmax()
5
>>> a.argmax(0)
array([1, 1, 1])
>>> a.argmax(1)
array([2, 2])"
numpy.ma.MaskedArray.argmin,method,"[{'Parameters': [{'name': 'axis', 'type': '{None, integer}', 'description': 'If None, the index is into the flattened array, otherwise alongthe specified axis'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.  If None, the output ofminimum_fill_value(self._data) is used instead.'}, {'name': 'out', 'type': '{None, array}, optional', 'description': 'Array into which the result can be placed. Its type is preservedand it must be of the right shape to hold the output.'}]}, {'Returns': [{'name': 'ndarray or scalar', 'type': None, 'description': 'If multi-dimension input, returns a new ndarray of indices to theminimum values along the given axis.  Otherwise, returns a scalarof index to the minimum values along the given axis.'}]}]",">>> import numpy as np
>>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
>>> x.shape = (2,2)
>>> x
masked_array(
  data=[[--, --],
        [2, 3]],
  mask=[[ True,  True],
        [False, False]],
  fill_value=999999)
>>> x.argmin(axis=0, fill_value=-1)
array([0, 0])
>>> x.argmin(axis=0, fill_value=9)
array([1, 1])"
numpy.ma.MaskedArray.max,method,"[{'Parameters': [{'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis along which to operate.  By default, axis is None and theflattened input is used.If this is a tuple of ints, the maximum is selected over multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'array_like, optional', 'description': 'Alternative output array in which to place the result.  Mustbe of the same shape and buffer length as the expected output.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.If None, use the output of maximum_fill_value().'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'amax', 'type': 'array_like', 'description': 'New array holding the result.If out was specified, out is returned.'}]}]",">>> import numpy.ma as ma
>>> x = [[-1., 2.5], [4., -2.], [3., 0.]]
>>> mask = [[0, 0], [1, 0], [1, 0]]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(
  data=[[-1.0, 2.5],
        [--, -2.0],
        [--, 0.0]],
  mask=[[False, False],
        [ True, False],
        [ True, False]],
  fill_value=1e+20)
>>> ma.max(masked_x)
2.5
>>> ma.max(masked_x, axis=0)
masked_array(data=[-1.0, 2.5],
             mask=[False, False],
       fill_value=1e+20)
>>> ma.max(masked_x, axis=1, keepdims=True)
masked_array(
  data=[[2.5],
        [-2.0],
        [0.0]],
  mask=[[False],
        [False],
        [False]],
  fill_value=1e+20)
>>> mask = [[1, 1], [1, 1], [1, 1]]
>>> masked_x = ma.masked_array(x, mask)
>>> ma.max(masked_x, axis=1)
masked_array(data=[--, --, --],
             mask=[ True,  True,  True],
       fill_value=1e+20,
            dtype=float64)"
numpy.ma.MaskedArray.min,method,"[{'Parameters': [{'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis along which to operate.  By default, axis is None and theflattened input is used.If this is a tuple of ints, the minimum is selected over multipleaxes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'array_like, optional', 'description': 'Alternative output array in which to place the result.  Must be ofthe same shape and buffer length as the expected output.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.If None, use the output of minimum_fill_value.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'amin', 'type': 'array_like', 'description': 'New array holding the result.If out was specified, out is returned.'}]}]",">>> import numpy.ma as ma
>>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]
>>> mask = [[1, 1, 0], [0, 0, 1]]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(
  data=[[--, --, 3.0],
        [0.2, -0.7, --]],
  mask=[[ True,  True, False],
        [False, False,  True]],
  fill_value=1e+20)
>>> ma.min(masked_x)
-0.7
>>> ma.min(masked_x, axis=-1)
masked_array(data=[3.0, -0.7],
             mask=[False, False],
        fill_value=1e+20)
>>> ma.min(masked_x, axis=0, keepdims=True)
masked_array(data=[[0.2, -0.7, 3.0]],
             mask=[[False, False, False]],
        fill_value=1e+20)
>>> mask = [[1, 1, 1,], [1, 1, 1]]
>>> masked_x = ma.masked_array(x, mask)
>>> ma.min(masked_x, axis=0)
masked_array(data=[--, --, --],
             mask=[ True,  True,  True],
        fill_value=1e+20,
            dtype=float64)"
numpy.ma.MaskedArray.ptp,method,"[{'Parameters': [{'name': 'axis', 'type': '{None, int}, optional', 'description': 'Axis along which to find the peaks.  If None (default) theflattened array is used.'}, {'name': 'out', 'type': '{None, array_like}, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type will be cast if necessary.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used to fill in the masked values.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.'}]}, {'Returns': [{'name': 'ptp', 'type': 'ndarray.', 'description': 'A new array holding the result, unless out wasspecified, in which case a reference to out is returned.'}]}]",">>> import numpy as np
>>> x = np.ma.MaskedArray([[4, 9, 2, 10],
...                        [6, 9, 7, 12]])
>>> x.ptp(axis=1)
masked_array(data=[8, 6],
             mask=False,
       fill_value=999999)
>>> x.ptp(axis=0)
masked_array(data=[2, 0, 5, 2],
             mask=False,
       fill_value=999999)
>>> x.ptp()
10
>>> y = np.ma.MaskedArray([[1, 127],
...                        [0, 127],
...                        [-1, 127],
...                        [-2, 127]], dtype=np.int8)
>>> y.ptp(axis=1)
masked_array(data=[ 126,  127, -128, -127],
             mask=False,
       fill_value=np.int64(999999),
            dtype=int8)
>>> y.ptp(axis=1).view(np.uint8)
masked_array(data=[126, 127, 128, 129],
             mask=False,
       fill_value=np.uint64(999999),
            dtype=uint8)"
numpy.ma.argsort,"Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
fill_value.","[{'Parameters': [{'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to sort. If None, the default, the flattened arrayis used.'}, {'name': 'kind', 'type': '{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional', 'description': 'The sorting algorithm used.'}, {'name': 'order', 'type': 'list, optional', 'description': 'When a is an array with fields defined, this argument specifieswhich fields to compare first, second, etc.  Not all fields need bespecified.'}, {'name': 'endwith', 'type': '{True, False}, optional', 'description': 'Whether missing values (if any) should be treated as the largest values(True) or the smallest values (False)When the array contains unmasked values at the same extremes of thedatatype, the ordering of these values and the masked values isundefined.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used internally for the masked values.If fill_value is not None, it supersedes endwith.'}, {'name': 'stable', 'type': 'bool, optional', 'description': 'Only for compatibility with np.argsort. Ignored.'}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray, int', 'description': 'Array of indices that sort a along the specified axis.In other words, a[index_array] yields a sorted a.'}]}]",">>> import numpy as np
>>> a = np.ma.array([3,2,1], mask=[False, False, True])
>>> a
masked_array(data=[3, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.argsort()
array([1, 0, 2])"
numpy.ma.sort,Return a sorted copy of the masked array.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11.2, -3.973, 0.801, -1.41]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11.2, -3.973, 0.801, --],
             mask=[False, False, False,  True],
       fill_value=1e+20)
>>> ma.sort(masked_x)
masked_array(data=[-3.973, 0.801, 11.2, --],
             mask=[False, False, False,  True],
       fill_value=1e+20)"
numpy.ma.MaskedArray.argsort,method,"[{'Parameters': [{'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to sort. If None, the default, the flattened arrayis used.'}, {'name': 'kind', 'type': '{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional', 'description': 'The sorting algorithm used.'}, {'name': 'order', 'type': 'list, optional', 'description': 'When a is an array with fields defined, this argument specifieswhich fields to compare first, second, etc.  Not all fields need bespecified.'}, {'name': 'endwith', 'type': '{True, False}, optional', 'description': 'Whether missing values (if any) should be treated as the largest values(True) or the smallest values (False)When the array contains unmasked values at the same extremes of thedatatype, the ordering of these values and the masked values isundefined.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used internally for the masked values.If fill_value is not None, it supersedes endwith.'}, {'name': 'stable', 'type': 'bool, optional', 'description': 'Only for compatibility with np.argsort. Ignored.'}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray, int', 'description': 'Array of indices that sort a along the specified axis.In other words, a[index_array] yields a sorted a.'}]}]",">>> import numpy as np
>>> a = np.ma.array([3,2,1], mask=[False, False, True])
>>> a
masked_array(data=[3, 2, --],
             mask=[False, False,  True],
       fill_value=999999)
>>> a.argsort()
array([1, 0, 2])"
numpy.ma.MaskedArray.sort,method,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array to be sorted.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to sort. If None, the array is flattened beforesorting. The default is -1, which sorts along the last axis.'}, {'name': 'kind', 'type': '{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional', 'description': 'The sorting algorithm used.'}, {'name': 'order', 'type': 'list, optional', 'description': 'When a is a structured array, this argument specifies which fieldsto compare first, second, and so on.  This list does not need toinclude all of the fields.'}, {'name': 'endwith', 'type': '{True, False}, optional', 'description': 'Whether missing values (if any) should be treated as the largest values(True) or the smallest values (False)When the array contains unmasked values sorting at the same extremes of thedatatype, the ordering of these values and the masked values isundefined.'}, {'name': 'fill_value', 'type': 'scalar or None, optional', 'description': 'Value used internally for the masked values.If fill_value is not None, it supersedes endwith.'}, {'name': 'stable', 'type': 'bool, optional', 'description': 'Only for compatibility with np.sort. Ignored.'}]}, {'Returns': [{'name': 'sorted_array', 'type': 'ndarray', 'description': 'Array of the same type and shape as a.'}]}]",">>> import numpy as np
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Default
>>> a.sort()
>>> a
masked_array(data=[1, 3, 5, --, --],
             mask=[False, False, False,  True,  True],
       fill_value=999999)
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # Put missing values in the front
>>> a.sort(endwith=False)
>>> a
masked_array(data=[--, --, 1, 3, 5],
             mask=[ True,  True, False, False, False],
       fill_value=999999)
>>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
>>> # fill_value takes over endwith
>>> a.sort(endwith=False, fill_value=3)
>>> a
masked_array(data=[1, --, --, 3, 5],
             mask=[False,  True,  True, False, False],
       fill_value=999999)"
numpy.ma.diag,Extract a diagonal or construct a diagonal array.,[],">>> import numpy as np
>>> import numpy as np
>>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])
>>> masked_x = np.ma.masked_array(x, mask=x < 0)
>>> masked_x
masked_array(
  data=[[11.2, --, 18.0],
        [0.801, --, 12.0],
        [7.0, 33.0, --]],
  mask=[[False,  True, False],
        [False,  True, False],
        [False, False,  True]],
  fill_value=1e+20)
>>> np.ma.diag(masked_x)
masked_array(data=[11.2, --, --],
             mask=[False,  True,  True],
       fill_value=1e+20)
>>> np.ma.diag(masked_x, -1)
masked_array(data=[0.801, 33.0],
             mask=[False, False],
       fill_value=1e+20)"
numpy.ma.dot,Return the dot product of two arrays.,"[{'Parameters': [{'name': 'a, b', 'type': 'masked_array_like', 'description': 'Inputs arrays.'}, {'name': 'strict', 'type': 'bool, optional', 'description': 'Whether masked data are propagated (True) or set to 0 (False) forthe computation. Default is False.  Propagating the mask means thatif a masked value appears in a row or column, the whole row orcolumn is considered masked.'}, {'name': 'out', 'type': 'masked_array, optional', 'description': 'Output argument. This must have the exact kind that would be returnedif it was not used. In particular, it must have the right type, must beC-contiguous, and its dtype must be the dtype that would be returnedfor dot(a,b). This is a performance feature. Therefore, if theseconditions are not met, an exception is raised, instead of attemptingto be flexible.'}]}]",">>> import numpy as np
>>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
>>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
>>> np.ma.dot(a, b)
masked_array(
  data=[[21, 26],
        [45, 64]],
  mask=[[False, False],
        [False, False]],
  fill_value=999999)
>>> np.ma.dot(a, b, strict=True)
masked_array(
  data=[[--, --],
        [--, 64]],
  mask=[[ True,  True],
        [ True, False]],
  fill_value=999999)"
numpy.ma.identity,Return the identity array.,"[{'Parameters': [{'name': 'n', 'type': 'int', 'description': 'Number of rows (and columns) in n x n output.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the output.  Defaults to float.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'n x n array with its main diagonal set to one,and all other elements 0.'}]}]",">>> import numpy as np
>>> np.identity(3)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])"
numpy.ma.inner,Inner product of two arrays.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'If a and b are nonscalar, their last dimensions must match.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'If a and b are bothscalars or both 1-D arrays then a scalar is returned; otherwisean array is returned.out.shape = (*a.shape[:-1], *b.shape[:-1])'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If both a and b are nonscalar and their last dimensions havedifferent sizes.'}]}]",">>> import numpy as np
>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2
>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> c = np.inner(a, b)
>>> c.shape
(2, 3)
>>> c
array([[ 14,  38,  62],
       [ 86, 110, 134]])
>>> a = np.arange(2).reshape((1,1,2))
>>> b = np.arange(6).reshape((3,2))
>>> c = np.inner(a, b)
>>> c.shape
(1, 1, 3)
>>> c
array([[[1, 3, 5]]])
>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])"
numpy.ma.innerproduct,Inner product of two arrays.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'If a and b are nonscalar, their last dimensions must match.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'If a and b are bothscalars or both 1-D arrays then a scalar is returned; otherwisean array is returned.out.shape = (*a.shape[:-1], *b.shape[:-1])'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If both a and b are nonscalar and their last dimensions havedifferent sizes.'}]}]",">>> import numpy as np
>>> a = np.array([1,2,3])
>>> b = np.array([0,1,0])
>>> np.inner(a, b)
2
>>> a = np.arange(24).reshape((2,3,4))
>>> b = np.arange(4)
>>> c = np.inner(a, b)
>>> c.shape
(2, 3)
>>> c
array([[ 14,  38,  62],
       [ 86, 110, 134]])
>>> a = np.arange(2).reshape((1,1,2))
>>> b = np.arange(6).reshape((3,2))
>>> c = np.inner(a, b)
>>> c.shape
(1, 1, 3)
>>> c
array([[[1, 3, 5]]])
>>> np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])"
numpy.ma.outer,Compute the outer product of two vectors.,"[{'Parameters': [{'name': 'a', 'type': '(M,) array_like', 'description': 'First input vector.  Input is flattened ifnot already 1-dimensional.'}, {'name': 'b', 'type': '(N,) array_like', 'description': 'Second input vector.  Input is flattened ifnot already 1-dimensional.'}, {'name': 'out', 'type': '(M, N) ndarray, optional', 'description': 'A location where the result is stored'}]}, {'Returns': [{'name': 'out', 'type': '(M, N) ndarray', 'description': 'out[i, j] = a[i] * b[j]'}]}]",">>> import numpy as np
>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)"
numpy.ma.outerproduct,Compute the outer product of two vectors.,"[{'Parameters': [{'name': 'a', 'type': '(M,) array_like', 'description': 'First input vector.  Input is flattened ifnot already 1-dimensional.'}, {'name': 'b', 'type': '(N,) array_like', 'description': 'Second input vector.  Input is flattened ifnot already 1-dimensional.'}, {'name': 'out', 'type': '(M, N) ndarray, optional', 'description': 'A location where the result is stored'}]}, {'Returns': [{'name': 'out', 'type': '(M, N) ndarray', 'description': 'out[i, j] = a[i] * b[j]'}]}]",">>> import numpy as np
>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)"
numpy.ma.trace,Return the sum along diagonals of the array.,[],
numpy.ma.MaskedArray.trace,method,[],
numpy.ma.vander,Generate a Vandermonde matrix.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': '1-D input array.'}, {'name': 'N', 'type': 'int, optional', 'description': 'Number of columns in the output.  If N is not specified, a squarearray is returned (N = len(x)).'}, {'name': 'increasing', 'type': 'bool, optional', 'description': 'Order of the powers of the columns.  If True, the powers increasefrom left to right, if False (the default) they are reversed.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Vandermonde matrix.  If increasing is False, the first column isx^(N-1), the second x^(N-2) and so forth. If increasing isTrue, the columns are x^0, x^1, ..., x^(N-1).'}]}]",">>> import numpy as np
>>> x = np.array([1, 2, 3, 5])
>>> N = 3
>>> np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])
>>> np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])
>>> x = np.array([1, 2, 3, 5])
>>> np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
>>> np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])
>>> np.linalg.det(np.vander(x))
48.000000000000043 # may vary
>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48"
numpy.ma.polyfit,Least squares polynomial fit.,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (M,)', 'description': 'x-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'y', 'type': 'array_like, shape (M,) or (M, K)', 'description': 'y-coordinates of the sample points. Several data sets of samplepoints sharing the same x-coordinates can be fitted at once bypassing in a 2D-array that contains one dataset per column.'}, {'name': 'deg', 'type': 'int', 'description': 'Degree of the fitting polynomial'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Relative condition number of the fit. Singular values smaller thanthis relative to the largest singular value will be ignored. Thedefault value is len(x)*eps, where eps is the relative precision ofthe float type, about 2e-16 in most cases.'}, {'name': 'full', 'type': 'bool, optional', 'description': 'Switch determining nature of return value. When it is False (thedefault) just the coefficients are returned, when True diagnosticinformation from the singular value decomposition is also returned.'}, {'name': 'w', 'type': 'array_like, shape (M,), optional', 'description': 'Weights. If not None, the weight w[i] applies to the unsquaredresidual y[i] - y_hat[i] at x[i]. Ideally the weights arechosen so that the errors of the products w[i]*y[i] all have thesame variance.  When using inverse-variance weighting, usew[i] = 1/sigma(y[i]).  The default value is None.'}, {'name': 'cov', 'type': 'bool or str, optional', 'description': ""If given and not False, return not just the estimate but also itscovariance matrix. By default, the covariance are scaled bychi2/dof, where dof = M - (deg + 1), i.e., the weights are presumedto be unreliable except in a relative sense and everything is scaledsuch that the reduced chi2 is unity. This scaling is omitted ifcov='unscaled', as is relevant for the case that the weights arew = 1/sigma, with sigma known to be a reliable estimate of theuncertainty.""}]}, {'Returns': [{'name': 'p', 'type': 'ndarray, shape (deg + 1,) or (deg + 1, K)', 'description': 'Polynomial coefficients, highest power first.  If y was 2-D, thecoefficients for k-th data set are in p[:,k].'}, {'name': 'residuals, rank, singular_values, rcond', 'type': None, 'description': 'These values are only returned if full == Trueresiduals – sum of squared residuals of the least squares fitrank – the effective rank of the scaled Vandermondecoefficient matrixsingular_values – singular values of the scaled Vandermondecoefficient matrixrcond – value of rcond.For more details, see numpy.linalg.lstsq.'}, {'name': 'rank – the effective rank of the scaled Vandermonde', 'type': None, 'description': 'coefficient matrix'}, {'name': 'singular_values – singular values of the scaled Vandermonde', 'type': None, 'description': 'coefficient matrix'}, {'name': 'V', 'type': 'ndarray, shape (deg + 1, deg + 1) or (deg + 1, deg + 1, K)', 'description': 'Present only if full == False and cov == True.  The covariancematrix of the polynomial coefficient estimates.  The diagonal ofthis matrix are the variance estimates for each coefficient.  If yis a 2-D array, then the covariance matrix for the k-th data setare in V[:,:,k]'}]}, {'Warns': [{'name': 'RankWarning', 'type': None, 'description': ""The rank of the coefficient matrix in the least-squares fit isdeficient. The warning is only raised if full == False.The warnings can be turned off by>>> import warnings>>> warnings.simplefilter('ignore', np.exceptions.RankWarning)""}]}]",">>> import warnings
>>> warnings.simplefilter('ignore', np.exceptions.RankWarning)
>>> import numpy as np
>>> import warnings
>>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
>>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
>>> z = np.polyfit(x, y, 3)
>>> z
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary
>>> p = np.poly1d(z)
>>> p(0.5)
0.6143849206349179 # may vary
>>> p(3.5)
-0.34732142857143039 # may vary
>>> p(10)
22.579365079365115 # may vary
>>> with warnings.catch_warnings():
...     warnings.simplefilter('ignore', np.exceptions.RankWarning)
...     p30 = np.poly1d(np.polyfit(x, y, 30))
...
>>> p30(4)
-0.80000000000000204 # may vary
>>> p30(5)
-0.99999999999999445 # may vary
>>> p30(4.5)
-0.10547061179440398 # may vary
>>> import matplotlib.pyplot as plt
>>> xp = np.linspace(-2, 6, 100)
>>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
>>> plt.ylim(-2,2)
(-2, 2)
>>> plt.show()"
numpy.ma.around,Round an array to the given number of decimals.,[],
numpy.ma.clip,Clip (limit) the values in an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing elements to clip.'}, {'name': 'a_min, a_max', 'type': 'array_like or None', 'description': 'Minimum and maximum value. If None, clipping is not performed onthe corresponding edge. If both a_min and a_max are None,the elements of the returned array stay the same. Both are broadcastedagainst a.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'The results will be placed in this array. It may be the inputarray for in-place clipping.  out must be of the right shapeto hold the output.  Its type is preserved.'}, {'name': 'min, max', 'type': 'array_like or None', 'description': 'Array API compatible alternatives for a_min and a_maxarguments. Either a_min and a_max or min and maxcan be passed at the same time. Default: None.New in version 2.1.0.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'clipped_array', 'type': 'MaskedArray', 'description': 'An array with the elements of a, but where values< a_min are replaced with a_min, and those > a_maxwith a_max.'}]}]",">>> import numpy as np
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
>>> np.clip(a, 8, 1)
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
>>> np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
>>> a
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])"
numpy.ma.round,"Return a copy of a, rounded to ‘decimals’ places.","[{'Parameters': [{'name': 'decimals', 'type': 'int', 'description': 'Number of decimals to round to. May be negative.'}, {'name': 'out', 'type': 'array_like', 'description': 'Existing array to use for output.If not given, returns a default copy of a.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11.2, -3.973, 0.801, -1.41]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11.2, -3.973, 0.801, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round_(masked_x)
masked_array(data=[11.0, -4.0, 1.0, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round(masked_x, decimals=1)
masked_array(data=[11.2, -4.0, 0.8, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round_(masked_x, decimals=-1)
masked_array(data=[10.0, -0.0, 0.0, --],
             mask=[False, False, False, True],
    fill_value=1e+20)"
numpy.ma.MaskedArray.clip,method,[],
numpy.ma.MaskedArray.round,method,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.array([1.35, 2.5, 1.5, 1.75, 2.25, 2.75],
...              mask=[0, 0, 0, 1, 0, 0])
>>> ma.round(x)
masked_array(data=[1.0, 2.0, 2.0, --, 2.0, 3.0],
             mask=[False, False, False,  True, False, False],
        fill_value=1e+20)"
numpy.ma.intersect1d,Returns the unique elements common to both arrays.,[],">>> import numpy as np
>>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])
>>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])
>>> np.ma.intersect1d(x, y)
masked_array(data=[1, 3, --],
             mask=[False, False,  True],
       fill_value=999999)"
numpy.ma.setdiff1d,Set difference of 1D arrays with unique elements.,[],">>> import numpy as np
>>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
>>> np.ma.setdiff1d(x, [1, 2])
masked_array(data=[3, --],
             mask=[False,  True],
       fill_value=999999)"
numpy.ma.setxor1d,Set exclusive-or of 1-D arrays with unique elements.,[],">>> import numpy as np
>>> ar1 = np.ma.array([1, 2, 3, 2, 4])
>>> ar2 = np.ma.array([2, 3, 5, 7, 5])
>>> np.ma.setxor1d(ar1, ar2)
masked_array(data=[1, 4, 5, 7],
             mask=False,
       fill_value=999999)"
numpy.ma.union1d,Union of two arrays.,[],">>> import numpy as np
>>> ar1 = np.ma.array([1, 2, 3, 4])
>>> ar2 = np.ma.array([3, 4, 5, 6])
>>> np.ma.union1d(ar1, ar2)
masked_array(data=[1, 2, 3, 4, 5, 6],
         mask=False,
   fill_value=999999)"
numpy.ma.allequal,"Return True if all entries of a and b are equal, using
fill_value as a truth value where either or both are masked.","[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'Input arrays to compare.'}, {'name': 'fill_value', 'type': 'bool, optional', 'description': 'Whether masked values in a or b are considered equal (True) or not(False).'}]}, {'Returns': [{'name': 'y', 'type': 'bool', 'description': 'Returns True if the two arrays are equal within the giventolerance, False otherwise. If either array contains NaN,then False is returned.'}]}]",">>> import numpy as np
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)
>>> b = np.array([1e10, 1e-7, -42.0])
>>> b
array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
>>> np.ma.allequal(a, b, fill_value=False)
False
>>> np.ma.allequal(a, b)
True"
numpy.ma.allclose,Returns True if two arrays are element-wise equal within a tolerance.,"[{'Parameters': [{'name': 'a, b', 'type': 'array_like', 'description': 'Input arrays to compare.'}, {'name': 'masked_equal', 'type': 'bool, optional', 'description': 'Whether masked values in a and b are considered equal (True) or not(False). They are considered equal by default.'}, {'name': 'rtol', 'type': 'float, optional', 'description': 'Relative tolerance. The relative difference is equal to rtol * b.Default is 1e-5.'}, {'name': 'atol', 'type': 'float, optional', 'description': 'Absolute tolerance. The absolute difference is equal to atol.Default is 1e-8.'}]}, {'Returns': [{'name': 'y', 'type': 'bool', 'description': 'Returns True if the two arrays are equal within the giventolerance, False otherwise. If either array contains NaN, thenFalse is returned.'}]}]",">>> import numpy as np
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)
>>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
False
>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False
>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False"
numpy.ma.amax,Return the maximum of an array or maximum along an axis.,[],
numpy.ma.amin,Return the minimum of an array or minimum along an axis.,[],
numpy.ma.apply_along_axis,Apply a function to 1-D slices along the given axis.,"[{'Parameters': [{'name': 'func1d', 'type': 'function (M,) -> (Nj…)', 'description': 'This function should accept 1-D arrays. It is applied to 1-Dslices of arr along the specified axis.'}, {'name': 'axis', 'type': 'integer', 'description': 'Axis along which arr is sliced.'}, {'name': 'arr', 'type': 'ndarray (Ni…, M, Nk…)', 'description': 'Input array.'}, {'name': 'args', 'type': 'any', 'description': 'Additional arguments to func1d.'}, {'name': 'kwargs', 'type': 'any', 'description': 'Additional named arguments to func1d.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray  (Ni…, Nj…, Nk…)', 'description': 'The output array. The shape of out is identical to the shape ofarr, except along the axis dimension. This axis is removed, andreplaced with new dimensions equal to the shape of the return valueof func1d. So if func1d returns a scalar out will have onefewer dimensions than arr.'}]}]",">>> import numpy as np
>>> def my_func(a):
...     """"""Average first and last element of a 1-D array""""""
...     return (a[0] + a[-1]) * 0.5
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(my_func, 0, b)
array([4., 5., 6.])
>>> np.apply_along_axis(my_func, 1, b)
array([2.,  5.,  8.])
>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
>>> np.apply_along_axis(sorted, 1, b)
array([[1, 7, 8],
       [3, 4, 9],
       [2, 5, 6]])
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(np.diag, -1, b)
array([[[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]],
       [[4, 0, 0],
        [0, 5, 0],
        [0, 0, 6]],
       [[7, 0, 0],
        [0, 8, 0],
        [0, 0, 9]]])"
numpy.ma.apply_over_axes,Apply a function repeatedly over multiple axes.,"[{'Parameters': [{'name': 'func', 'type': 'function', 'description': 'This function must take two arguments, func(a, axis).'}, {'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axes', 'type': 'array_like', 'description': 'Axes over which func is applied; the elements must be integers.'}]}, {'Returns': [{'name': 'apply_over_axis', 'type': 'ndarray', 'description': 'The output array.  The number of dimensions is the same as a,but the shape can be different.  This depends on whether funcchanges the shape of its output with respect to its input.'}]}]",">>> import numpy as np
>>> a = np.ma.arange(24).reshape(2,3,4)
>>> a[:,0,1] = np.ma.masked
>>> a[:,1,:] = np.ma.masked
>>> a
masked_array(
  data=[[[0, --, 2, 3],
         [--, --, --, --],
         [8, 9, 10, 11]],
        [[12, --, 14, 15],
         [--, --, --, --],
         [20, 21, 22, 23]]],
  mask=[[[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]],
        [[False,  True, False, False],
         [ True,  True,  True,  True],
         [False, False, False, False]]],
  fill_value=999999)
>>> np.ma.apply_over_axes(np.ma.sum, a, [0,2])
masked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)
>>> np.ma.sum(a, axis=(0,2)).reshape((1,-1,1))
masked_array(
  data=[[[46],
         [--],
         [124]]],
  mask=[[[False],
         [ True],
         [False]]],
  fill_value=999999)"
numpy.ma.arange,Return evenly spaced values within a given interval.,"[{'Parameters': [{'name': 'start', 'type': 'integer or real, optional', 'description': 'Start of interval.  The interval includes this value.  The defaultstart value is 0.'}, {'name': 'stop', 'type': 'integer or real', 'description': 'End of interval.  The interval does not include this value, exceptin some cases where step is not an integer and floating pointround-off affects the length of out.'}, {'name': 'step', 'type': 'integer or real, optional', 'description': 'Spacing between values.  For any output out, this is the distancebetween two adjacent values, out[i+1] - out[i].  The defaultstep size is 1.  If step is specified as a position argument,start must also be given.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'The type of the output array.  If dtype is not given, infer the datatype from the other input arguments.'}, {'name': 'device', 'type': 'str, optional', 'description': 'The device on which to place the created array. Default: None.For Array-API interoperability only, so must be ""cpu"" if passed.New in version 2.0.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'arange', 'type': 'MaskedArray', 'description': 'Array of evenly spaced values.For floating point arguments, the length of the result isceil((stop - start)/step).  Because of floating point overflow,this rule may result in the last element of out being greaterthan stop.'}]}]",">>> import numpy as np
>>> np.arange(3)
array([0, 1, 2])
>>> np.arange(3.0)
array([ 0.,  1.,  2.])
>>> np.arange(3,7)
array([3, 4, 5, 6])
>>> np.arange(3,7,2)
array([3, 5])"
numpy.ma.choose,Use an index array to construct a new array from a list of choices.,"[{'Parameters': [{'name': 'indices', 'type': 'ndarray of ints', 'description': 'This array must contain integers in [0, n-1], where n is thenumber of choices.'}, {'name': 'choices', 'type': 'sequence of arrays', 'description': 'Choice arrays. The index array and all of the choices should bebroadcastable to the same shape.'}, {'name': 'out', 'type': 'array, optional', 'description': 'If provided, the result will be inserted into this array. It shouldbe of the appropriate shape and dtype.'}, {'name': 'mode', 'type': '{‘raise’, ‘wrap’, ‘clip’}, optional', 'description': 'Specifies how out-of-bounds indices will behave.‘raise’ : raise an error‘wrap’ : wrap around‘clip’ : clip to the range'}]}, {'Returns': [{'name': 'merged_array', 'type': 'array', 'description': ''}]}]",">>> import numpy as np
>>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
>>> a = np.array([2, 1, 0])
>>> np.ma.choose(a, choice)
masked_array(data=[3, 2, 1],
             mask=False,
       fill_value=999999)"
numpy.ma.compress_nd,Suppress slices from multiple dimensions which contain masked values.,"[{'Parameters': [{'name': 'x', 'type': 'array_like, MaskedArray', 'description': 'The array to operate on. If not a MaskedArray instance (or if no arrayelements are masked), x is interpreted as a MaskedArray with maskset to nomask.'}, {'name': 'axis', 'type': 'tuple of ints or int, optional', 'description': 'Which dimensions to suppress slices from can be configured with thisparameter.- If axis is a tuple of ints, those are the axes to suppress slices from.- If axis is an int, then that is the only axis to suppress slices from.- If axis is None, all axis are selected.'}]}, {'Returns': [{'name': 'compress_array', 'type': 'ndarray', 'description': 'The compressed array.'}]}]",">>> import numpy as np
>>> arr = [[1, 2], [3, 4]]
>>> mask = [[0, 1], [0, 0]]
>>> x = np.ma.array(arr, mask=mask)
>>> np.ma.compress_nd(x, axis=0)
array([[3, 4]])
>>> np.ma.compress_nd(x, axis=1)
array([[1],
       [3]])
>>> np.ma.compress_nd(x)
array([[3]])"
numpy.ma.convolve,"Returns the discrete, linear convolution of two one-dimensional sequences.","[{'Parameters': [{'name': 'a, v', 'type': 'array_like', 'description': 'Input sequences.'}, {'name': 'mode', 'type': '{‘valid’, ‘same’, ‘full’}, optional', 'description': 'Refer to the np.convolve docstring.'}, {'name': 'propagate_mask', 'type': 'bool', 'description': 'If True, then if any masked element is included in the sum for a resultelement, then the result is masked.If False, then the result element is only masked if no non-masked cellscontribute towards it'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Discrete, linear convolution of a and v.'}]}]",
numpy.ma.correlate,Cross-correlation of two 1-dimensional sequences.,"[{'Parameters': [{'name': 'a, v', 'type': 'array_like', 'description': 'Input sequences.'}, {'name': 'mode', 'type': '{‘valid’, ‘same’, ‘full’}, optional', 'description': 'Refer to the np.convolve docstring.  Note that the defaultis ‘valid’, unlike convolve, which uses ‘full’.'}, {'name': 'propagate_mask', 'type': 'bool', 'description': 'If True, then a result element is masked if any masked element contributes towards it.If False, then a result element is only masked if no non-masked elementcontribute towards it'}]}, {'Returns': [{'name': 'out', 'type': 'MaskedArray', 'description': 'Discrete cross-correlation of a and v.'}]}]",">>> a = np.ma.array([1, 2, 3])
>>> v = np.ma.array([0, 1, 0])
>>> np.ma.correlate(a, v, mode='valid')
masked_array(data=[2],
             mask=[False],
       fill_value=999999)
>>> a = np.ma.array([1, 2, 3], mask=[False, True, False])
>>> v = np.ma.array([0, 1, 0])
>>> np.ma.correlate(a, v, mode='valid', propagate_mask=True)
masked_array(data=[--],
             mask=[ True],
       fill_value=999999,
            dtype=int64)
>>> a = np.ma.array([1, 2, 3])
>>> v = np.ma.array([0, 1, 0])
>>> np.ma.correlate(a, v, mode='full')
masked_array(data=[0, 1, 2, 3, 0],
             mask=[False, False, False, False, False],
       fill_value=999999)"
numpy.ma.ediff1d,Compute the differences between consecutive elements of an array.,[],">>> import numpy as np
>>> arr = np.ma.array([1, 2, 4, 7, 0])
>>> np.ma.ediff1d(arr)
masked_array(data=[ 1,  2,  3, -7],
             mask=False,
       fill_value=999999)"
numpy.ma.flatten_mask,"Returns a completely flattened version of the mask, where nested fields
are collapsed.","[{'Parameters': [{'name': 'mask', 'type': 'array_like', 'description': 'Input array, which will be interpreted as booleans.'}]}, {'Returns': [{'name': 'flattened_mask', 'type': 'ndarray of bools', 'description': 'The flattened input.'}]}]",">>> import numpy as np
>>> mask = np.array([0, 0, 1])
>>> np.ma.flatten_mask(mask)
array([False, False,  True])
>>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
>>> np.ma.flatten_mask(mask)
array([False, False, False,  True])
>>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
>>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
>>> np.ma.flatten_mask(mask)
array([False, False, False, False, False,  True])"
numpy.ma.flatten_structured_array,Flatten a structured array.,"[{'Parameters': [{'name': 'a', 'type': 'structured array', 'description': ''}]}, {'Returns': [{'name': 'output', 'type': 'masked array or ndarray', 'description': 'A flattened masked array if the input is a masked array, otherwise astandard ndarray.'}]}]",">>> import numpy as np
>>> ndtype = [('a', int), ('b', float)]
>>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)
>>> np.ma.flatten_structured_array(a)
array([[1., 1.],
       [2., 2.]])"
numpy.ma.fromflex,Build a masked array from a suitable flexible-type array.,"[{'Parameters': [{'name': 'fxarray', 'type': 'ndarray', 'description': 'The structured input array, containing _data and _maskfields. If present, other fields are discarded.'}]}, {'Returns': [{'name': 'result', 'type': 'MaskedArray', 'description': 'The constructed masked array.'}]}]",">>> import numpy as np
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
>>> rec = x.toflex()
>>> rec
array([[(0, False), (1,  True), (2, False)],
       [(3,  True), (4, False), (5,  True)],
       [(6, False), (7,  True), (8, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])
>>> x2 = np.ma.fromflex(rec)
>>> x2
masked_array(
  data=[[0, --, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)
>>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]
>>> rec2 = np.zeros((2, 2), dtype=dt)
>>> rec2
array([[(0, False, 0.), (0, False, 0.)],
       [(0, False, 0.), (0, False, 0.)]],
      dtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])
>>> y = np.ma.fromflex(rec2)
>>> y
masked_array(
  data=[[0, 0],
        [0, 0]],
  mask=[[False, False],
        [False, False]],
  fill_value=np.int64(999999),
  dtype=int32)"
numpy.ma.indices,Return an array representing the indices of a grid.,"[{'Parameters': [{'name': 'dimensions', 'type': 'sequence of ints', 'description': 'The shape of the grid.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data type of the result.'}, {'name': 'sparse', 'type': 'boolean, optional', 'description': 'Return a sparse representation of the grid instead of a denserepresentation. Default is False.'}]}, {'Returns': [{'name': 'grid', 'type': 'one MaskedArray or tuple of MaskedArrays', 'description': 'If sparse is False:Returns one array of grid indices,grid.shape = (len(dimensions),) + tuple(dimensions).If sparse is True:Returns a tuple of arrays, withgrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) withdimensions[i] in the ith place'}, {'name': 'If sparse is False:', 'type': None, 'description': 'Returns one array of grid indices,grid.shape = (len(dimensions),) + tuple(dimensions).'}, {'name': 'If sparse is True:', 'type': None, 'description': 'Returns a tuple of arrays, withgrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) withdimensions[i] in the ith place'}]}]",">>> import numpy as np
>>> grid = np.indices((2, 3))
>>> grid.shape
(2, 2, 3)
>>> grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
>>> grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])
>>> x = np.arange(20).reshape(5, 4)
>>> row, col = np.indices((2, 3))
>>> x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])
>>> i, j = np.indices((2, 3), sparse=True)
>>> i.shape
(2, 1)
>>> j.shape
(1, 3)
>>> i        # row indices
array([[0],
       [1]])
>>> j        # column indices
array([[0, 1, 2]])"
numpy.ma.left_shift,Shift the bits of an integer to the left.,[],">>> arr = np.ma.array([10, 20, 30], mask=[False, True, False])
>>> np.ma.left_shift(arr, 1)
masked_array(data=[20, --, 60],
             mask=[False,  True, False],
       fill_value=999999)
>>> np.ma.left_shift(10, 10)
masked_array(data=10240,
             mask=False,
       fill_value=999999)
>>> scalar = 10
>>> arr = np.ma.array([1, 2, 3], mask=[False, True, False])
>>> np.ma.left_shift(scalar, arr)
masked_array(data=[20, --, 80],
             mask=[False,  True, False],
       fill_value=999999)"
numpy.ma.ndim,Return the number of dimensions of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.  If it is not already an ndarray, a conversion isattempted.'}]}, {'Returns': [{'name': 'number_of_dimensions', 'type': 'int', 'description': 'The number of dimensions in a.  Scalars are zero-dimensional.'}]}]",">>> import numpy as np
>>> np.ndim([[1,2,3],[4,5,6]])
2
>>> np.ndim(np.array([[1,2,3],[4,5,6]]))
2
>>> np.ndim(1)
0"
numpy.ma.put,Set storage-indexed locations to corresponding values.,[],">>> a = np.ma.array([1, 2, 3, 4], mask=[False, True, False, False])
>>> np.ma.put(a, [1, 3], [10, 30])
>>> a
masked_array(data=[ 1, 10,  3, 30],
             mask=False,
       fill_value=999999)
>>> b = np.ma.array([[1, 2], [3, 4]], mask=[[False, True], [False, False]])
>>> np.ma.put(b, [[0, 1], [1, 0]], [[10, 20], [30, 40]])
>>> b
masked_array(
  data=[[40, 30],
        [ 3,  4]],
  mask=False,
  fill_value=999999)"
numpy.ma.putmask,Changes elements of an array based on conditional and input values.,[],">>> import numpy as np
>>> arr = [[1, 2], [3, 4]]
>>> mask = [[1, 0], [0, 0]]
>>> x = np.ma.array(arr, mask=mask)
>>> np.ma.putmask(x, x < 4, 10*x)
>>> x
masked_array(
  data=[[--, 20],
        [30, 4]],
  mask=[[ True, False],
        [False, False]],
  fill_value=999999)
>>> x.data
array([[10, 20],
       [30,  4]])"
numpy.ma.right_shift,Shift the bits of an integer to the right.,[],">>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11, 3, 8, 1]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11, 3, 8, --],
             mask=[False, False, False,  True],
       fill_value=999999)
>>> ma.right_shift(masked_x,1)
masked_array(data=[5, 1, 4, --],
             mask=[False, False, False,  True],
       fill_value=999999)"
numpy.ma.round_,"Return a copy of a, rounded to ‘decimals’ places.","[{'Parameters': [{'name': 'decimals', 'type': 'int', 'description': 'Number of decimals to round to. May be negative.'}, {'name': 'out', 'type': 'array_like', 'description': 'Existing array to use for output.If not given, returns a default copy of a.'}]}]",">>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11.2, -3.973, 0.801, -1.41]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11.2, -3.973, 0.801, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round_(masked_x)
masked_array(data=[11.0, -4.0, 1.0, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round(masked_x, decimals=1)
masked_array(data=[11.2, -4.0, 0.8, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round_(masked_x, decimals=-1)
masked_array(data=[10.0, -0.0, 0.0, --],
             mask=[False, False, False, True],
    fill_value=1e+20)"
numpy.load,"Load arrays or pickled objects from .npy, .npz or pickled files.","[{'Parameters': [{'name': 'file', 'type': 'file-like object, string, or pathlib.Path', 'description': 'The file to read. File-like objects must support theseek() and read() methods and must alwaysbe opened in binary mode.  Pickled files require that thefile-like object support the readline() method as well.'}, {'name': 'mmap_mode', 'type': '{None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional', 'description': 'If not None, then memory-map the file, using the given mode (seenumpy.memmap for a detailed description of the modes).  Amemory-mapped array is kept on disk. However, it can be accessedand sliced like any ndarray.  Memory mapping is especially usefulfor accessing small fragments of large files without reading theentire file into memory.'}, {'name': 'allow_pickle', 'type': 'bool, optional', 'description': 'Allow loading pickled object arrays stored in npy files. Reasons fordisallowing pickles include security, as loading pickled data canexecute arbitrary code. If pickles are disallowed, loading objectarrays will fail. Default: False'}, {'name': 'fix_imports', 'type': 'bool, optional', 'description': 'Only useful when loading Python 2 generated pickled files on Python 3,which includes npy/npz files containing object arrays. If fix_importsis True, pickle will try to map the old Python 2 names to the new namesused in Python 3.'}, {'name': 'encoding', 'type': 'str, optional', 'description': 'What encoding to use when reading Python 2 strings. Only useful whenloading Python 2 generated pickled files in Python 3, which includesnpy/npz files containing object arrays. Values other than ‘latin1’,‘ASCII’, and ‘bytes’ are not allowed, as they can corrupt numericaldata. Default: ‘ASCII’'}, {'name': 'max_header_size', 'type': 'int, optional', 'description': 'Maximum allowed size of the header.  Large headers may not be safeto load securely and thus require explicitly passing a larger value.See ast.literal_eval for details.This option is ignored when allow_pickle is passed.  In that casethe file is by definition trusted and the limit is unnecessary.'}]}, {'Returns': [{'name': 'result', 'type': 'array, tuple, dict, etc.', 'description': 'Data stored in the file. For .npz files, the returned instanceof NpzFile class must be closed to avoid leaking file descriptors.'}]}, {'Raises': [{'name': 'OSError', 'type': None, 'description': 'If the input file does not exist or cannot be read.'}, {'name': 'UnpicklingError', 'type': None, 'description': 'If allow_pickle=True, but the file cannot be loaded as a pickle.'}, {'name': 'ValueError', 'type': None, 'description': 'The file contains an object array, but allow_pickle=False given.'}, {'name': 'EOFError', 'type': None, 'description': 'When calling np.load multiple times on the same file handle,if all data has already been read'}]}]",">>> import numpy as np
>>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))
>>> np.load('/tmp/123.npy')
array([[1, 2, 3],
       [4, 5, 6]])
>>> a=np.array([[1, 2, 3], [4, 5, 6]])
>>> b=np.array([1, 2])
>>> np.savez('/tmp/123.npz', a=a, b=b)
>>> data = np.load('/tmp/123.npz')
>>> data['a']
array([[1, 2, 3],
       [4, 5, 6]])
>>> data['b']
array([1, 2])
>>> data.close()
>>> X = np.load('/tmp/123.npy', mmap_mode='r')
>>> X[1, :]
memmap([4, 5, 6])"
numpy.save,Save an array to a binary file in NumPy .npy format.,"[{'Parameters': [{'name': 'file', 'type': 'file, str, or pathlib.Path', 'description': 'File or filename to which the data is saved. If file is a file-object,then the filename is unchanged.  If file is a string or Path,a .npy extension will be appended to the filename if it does notalready have one.'}, {'name': 'arr', 'type': 'array_like', 'description': 'Array data to be saved.'}, {'name': 'allow_pickle', 'type': 'bool, optional', 'description': 'Allow saving object arrays using Python pickles. Reasons fordisallowing pickles include security (loading pickled data can executearbitrary code) and portability (pickled objects may not be loadableon different Python installations, for example if the stored objectsrequire libraries that are not available, and not all pickled data iscompatible between different versions of Python).Default: True'}, {'name': 'fix_imports', 'type': 'bool, optional', 'description': 'The fix_imports flag is deprecated and has no effect.Deprecated since version 2.1: This flag is ignored since NumPy 1.17 and was only needed tosupport loading some files in Python 2 written in Python 3.'}]}]",">>> import numpy as np
>>> from tempfile import TemporaryFile
>>> outfile = TemporaryFile()
>>> x = np.arange(10)
>>> np.save(outfile, x)
>>> _ = outfile.seek(0) # Only needed to simulate closing & reopening file
>>> np.load(outfile)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> with open('test.npy', 'wb') as f:
...     np.save(f, np.array([1, 2]))
...     np.save(f, np.array([1, 3]))
>>> with open('test.npy', 'rb') as f:
...     a = np.load(f)
...     b = np.load(f)
>>> print(a, b)
# [1 2] [1 3]"
numpy.savez,Save several arrays into a single file in uncompressed .npz format.,"[{'Parameters': [{'name': 'file', 'type': 'file, str, or pathlib.Path', 'description': 'Either the filename (string) or an open file (file-like object)where the data will be saved. If file is a string or a Path, the.npz extension will be appended to the filename if it is notalready there.'}, {'name': 'args', 'type': 'Arguments, optional', 'description': 'Arrays to save to the file. Please use keyword arguments (seekwds below) to assign names to arrays.  Arrays specified asargs will be named “arr_0”, “arr_1”, and so on.'}, {'name': 'allow_pickle', 'type': 'bool, optional', 'description': 'Allow saving object arrays using Python pickles. Reasons fordisallowing pickles include security (loading pickled data can executearbitrary code) and portability (pickled objects may not be loadableon different Python installations, for example if the stored objectsrequire libraries that are not available, and not all pickled data iscompatible between different versions of Python).Default: True'}, {'name': 'kwds', 'type': 'Keyword arguments, optional', 'description': 'Arrays to save to the file. Each array will be saved to theoutput file with its corresponding keyword name.'}]}, {'Returns': [{'name': 'None', 'type': None, 'description': ''}]}]",">>> import numpy as np
>>> from tempfile import TemporaryFile
>>> outfile = TemporaryFile()
>>> x = np.arange(10)
>>> y = np.sin(x)
>>> np.savez(outfile, x, y)
>>> _ = outfile.seek(0) # Only needed to simulate closing & reopening file
>>> npzfile = np.load(outfile)
>>> npzfile.files
['arr_0', 'arr_1']
>>> npzfile['arr_0']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> outfile = TemporaryFile()
>>> np.savez(outfile, x=x, y=y)
>>> _ = outfile.seek(0)
>>> npzfile = np.load(outfile)
>>> sorted(npzfile.files)
['x', 'y']
>>> npzfile['x']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])"
numpy.savez_compressed,Save several arrays into a single file in compressed .npz format.,"[{'Parameters': [{'name': 'file', 'type': 'file, str, or pathlib.Path', 'description': 'Either the filename (string) or an open file (file-like object)where the data will be saved. If file is a string or a Path, the.npz extension will be appended to the filename if it is notalready there.'}, {'name': 'args', 'type': 'Arguments, optional', 'description': 'Arrays to save to the file. Please use keyword arguments (seekwds below) to assign names to arrays.  Arrays specified asargs will be named “arr_0”, “arr_1”, and so on.'}, {'name': 'allow_pickle', 'type': 'bool, optional', 'description': 'Allow saving object arrays using Python pickles. Reasons fordisallowing pickles include security (loading pickled data can executearbitrary code) and portability (pickled objects may not be loadableon different Python installations, for example if the stored objectsrequire libraries that are not available, and not all pickled data iscompatible between different versions of Python).Default: True'}, {'name': 'kwds', 'type': 'Keyword arguments, optional', 'description': 'Arrays to save to the file. Each array will be saved to theoutput file with its corresponding keyword name.'}]}, {'Returns': [{'name': 'None', 'type': None, 'description': ''}]}]",">>> import numpy as np
>>> test_array = np.random.rand(3, 2)
>>> test_vector = np.random.rand(4)
>>> np.savez_compressed('/tmp/123', a=test_array, b=test_vector)
>>> loaded = np.load('/tmp/123.npz')
>>> print(np.array_equal(test_array, loaded['a']))
True
>>> print(np.array_equal(test_vector, loaded['b']))
True"
numpy.lib.npyio.NpzFile,"A dictionary-like object with lazy-loading of files in the zipped
archive provided on construction.","[{'Parameters': [{'name': 'fid', 'type': 'file, str, or pathlib.Path', 'description': 'The zipped archive to open. This is either a file-like objector a string containing the path to the archive.'}, {'name': 'own_fid', 'type': 'bool, optional', 'description': 'Whether NpzFile should close the file handle.Requires that fid is a file-like object.'}]}, {'Attributes': [{'name': 'files', 'type': 'list of str', 'description': 'List of all files in the archive with a .npy extension.'}, {'name': 'zip', 'type': 'ZipFile instance', 'description': 'The ZipFile object initialized with the zipped archive.'}, {'name': 'f', 'type': 'BagObj instance', 'description': 'An object on which attribute can be performed as an alternativeto getitem access on the NpzFile instance itself.'}, {'name': 'allow_pickle', 'type': 'bool, optional', 'description': 'Allow loading pickled data. Default: False'}, {'name': 'pickle_kwargs', 'type': 'dict, optional', 'description': 'Additional keyword arguments to pass on to pickle.load.These are only useful when loading object arrays saved onPython 2 when using Python 3.'}, {'name': 'max_header_size', 'type': 'int, optional', 'description': 'Maximum allowed size of the header.  Large headers may not be safeto load securely and thus require explicitly passing a larger value.See ast.literal_eval for details.This option is ignored when allow_pickle is passed.  In that casethe file is by definition trusted and the limit is unnecessary.'}]}]",">>> import numpy as np
>>> from tempfile import TemporaryFile
>>> outfile = TemporaryFile()
>>> x = np.arange(10)
>>> y = np.sin(x)
>>> np.savez(outfile, x=x, y=y)
>>> _ = outfile.seek(0)
>>> npz = np.load(outfile)
>>> isinstance(npz, np.lib.npyio.NpzFile)
True
>>> npz
NpzFile 'object' with keys: x, y
>>> sorted(npz.files)
['x', 'y']
>>> npz['x']  # getitem access
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> npz.f.x  # attribute lookup
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])"
numpy.loadtxt,Load data from a text file.,"[{'Parameters': [{'name': 'fname', 'type': 'file, str, pathlib.Path, list of str, generator', 'description': 'File, filename, list, or generator to read.  If the filenameextension is .gz or .bz2, the file is first decompressed. Notethat generators must return bytes or strings. The stringsin a list or produced by a generator are treated as lines.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'Data-type of the resulting array; default: float.  If this is astructured data-type, the resulting array will be 1-dimensional, andeach row will be interpreted as an element of the array.  In thiscase, the number of columns used must match the number of fields inthe data-type.'}, {'name': 'comments', 'type': 'str or sequence of str or None, optional', 'description': 'The characters or list of characters used to indicate the start of acomment. None implies no comments. For backwards compatibility, bytestrings will be decoded as ‘latin1’. The default is ‘#’.'}, {'name': 'delimiter', 'type': 'str, optional', 'description': 'The character used to separate the values. For backwards compatibility,byte strings will be decoded as ‘latin1’. The default is whitespace.Changed in version 1.23.0: Only single character delimiters are supported. Newline characterscannot be used as the delimiter.'}, {'name': 'converters', 'type': 'dict or callable, optional', 'description': 'Converter functions to customize value parsing. If converters iscallable, the function is applied to all columns, else it must be adict that maps column number to a parser function.See examples for further details.Default: None.Changed in version 1.23.0: The ability to pass a single callable to be applied to all columnswas added.'}, {'name': 'skiprows', 'type': 'int, optional', 'description': 'Skip the first skiprows lines, including comments; default: 0.'}, {'name': 'usecols', 'type': 'int or sequence, optional', 'description': 'Which columns to read, with 0 being the first. For example,usecols = (1,4,5) will extract the 2nd, 5th and 6th columns.The default, None, results in all columns being read.'}, {'name': 'unpack', 'type': 'bool, optional', 'description': 'If True, the returned array is transposed, so that arguments may beunpacked using x, y, z = loadtxt(...).  When used with astructured data-type, arrays are returned for each field.Default is False.'}, {'name': 'ndmin', 'type': 'int, optional', 'description': 'The returned array will have at least ndmin dimensions.Otherwise mono-dimensional axes will be squeezed.Legal values: 0 (default), 1 or 2.'}, {'name': 'encoding', 'type': 'str, optional', 'description': ""Encoding used to decode the inputfile. Does not apply to input streams.The special value ‘bytes’ enables backward compatibility workaroundsthat ensures you receive byte arrays as results if possible and passes‘latin1’ encoded strings to converters. Override this value to receiveunicode arrays and pass strings as input to converters.  If set to Nonethe system default is used. The default value is ‘bytes’.Changed in version 2.0: Before NumPy 2, the default was 'bytes' for Python 2compatibility. The default is now None.""}, {'name': 'max_rows', 'type': 'int, optional', 'description': 'Read max_rows rows of content after skiprows lines. The default isto read all the rows. Note that empty rows containing no data such asempty lines and comment lines are not counted towards max_rows,while such lines are counted in skiprows.Changed in version 1.23.0: Lines containing no data, including comment lines (e.g., linesstarting with ‘#’ or as specified via comments) are not countedtowards max_rows.'}, {'name': 'quotechar', 'type': 'unicode character or None, optional', 'description': 'The character used to denote the start and end of a quoted item.Occurrences of the delimiter or comment characters are ignored withina quoted item. The default value is quotechar=None, which meansquoting support is disabled.If two consecutive instances of quotechar are found within a quotedfield, the first is treated as an escape character. See examples.New in version 1.23.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Data read from the text file.'}]}]",">>> import numpy as np
>>> from io import StringIO   # StringIO behaves like a file object
>>> c = StringIO(""0 1\n2 3"")
>>> np.loadtxt(c)
array([[0., 1.],
       [2., 3.]])
>>> d = StringIO(""M 21 72\nF 35 58"")
>>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
...                      'formats': ('S1', 'i4', 'f4')})
array([(b'M', 21, 72.), (b'F', 35, 58.)],
      dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])
>>> c = StringIO(""1,0,2\n3,0,4"")
>>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)
>>> x
array([1., 3.])
>>> y
array([2., 4.])
>>> s = StringIO(""1.618, 2.296\n3.141, 4.669\n"")
>>> conv = {
...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0
...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1
... }
>>> np.loadtxt(s, delimiter="","", converters=conv)
array([[1., 3.],
       [3., 5.]])
>>> s = StringIO(""0xDE 0xAD\n0xC0 0xDE"")
>>> import functools
>>> conv = functools.partial(int, base=16)
>>> np.loadtxt(s, converters=conv)
array([[222., 173.],
       [192., 222.]])
>>> s = StringIO(""10.01 31.25-\n19.22 64.31\n17.57- 63.94"")
>>> def conv(fld):
...     return -float(fld[:-1]) if fld.endswith(""-"") else float(fld)
...
>>> np.loadtxt(s, converters=conv)
array([[ 10.01, -31.25],
       [ 19.22,  64.31],
       [-17.57,  63.94]])
>>> s = StringIO(""1 2.7 100_000"")
>>> np.loadtxt(s, converters=float)
array([1.e+00, 2.7e+00, 1.e+05])
>>> def conv(val):
...     try:
...         return float(val)
...     except ValueError:
...         return float.fromhex(val)
>>> s = StringIO(""1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2"")
>>> np.loadtxt(s, delimiter="","", converters=conv)
array([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])
>>> s = StringIO(""10.01 31.25-\n19.22 64.31\n17.57- 63.94"")
>>> conv = lambda x: -float(x[:-1]) if x.endswith(""-"") else float(x)
>>> np.loadtxt(s, converters=conv)
array([[ 10.01, -31.25],
       [ 19.22,  64.31],
       [-17.57,  63.94]])
>>> s = StringIO('""alpha, #42"", 10.0\n""beta, #64"", 2.0\n')
>>> dtype = np.dtype([(""label"", ""U12""), (""value"", float)])
>>> np.loadtxt(s, dtype=dtype, delimiter="","", quotechar='""')
array([('alpha, #42', 10.), ('beta, #64',  2.)],
      dtype=[('label', '<U12'), ('value', '<f8')])
>>> s = StringIO('""alpha, #42""       10.0\n""beta, #64"" 2.0\n')
>>> dtype = np.dtype([(""label"", ""U12""), (""value"", float)])
>>> np.loadtxt(s, dtype=dtype, delimiter=None, quotechar='""')
array([('alpha, #42', 10.), ('beta, #64',  2.)],
      dtype=[('label', '<U12'), ('value', '<f8')])
>>> s = StringIO('""Hello, my name is """"Monty""""!""')
>>> np.loadtxt(s, dtype=""U"", delimiter="","", quotechar='""')
array('Hello, my name is ""Monty""!', dtype='<U26')
>>> d = StringIO(""1 2\n2 4\n3 9 12\n4 16 20"")
>>> np.loadtxt(d, usecols=(0, 1))
array([[ 1.,  2.],
       [ 2.,  4.],
       [ 3.,  9.],
       [ 4., 16.]])"
numpy.savetxt,Save an array to a text file.,"[{'Parameters': [{'name': 'fname', 'type': 'filename, file handle or pathlib.Path', 'description': 'If the filename ends in .gz, the file is automatically saved incompressed gzip format.  loadtxt understands gzipped filestransparently.'}, {'name': 'X', 'type': '1D or 2D array_like', 'description': 'Data to be saved to a text file.'}, {'name': 'fmt', 'type': 'str or sequence of strs, optional', 'description': ""A single format (%10.5f), a sequence of formats, or amulti-format string, e.g. ‘Iteration %d – %10.5f’, in whichcase delimiter is ignored. For complex X, the legal optionsfor fmt are:a single specifier, fmt='%.4e', resulting in numbers formattedlike ' (%s+%sj)' % (fmt, fmt)a full string specifying every real and imaginary part, e.g.' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej' for 3 columnsa list of specifiers, one per column - in this case, the realand imaginary part must have separate specifiers,e.g. ['%.3e + %.3ej', '(%.15e%+.15ej)'] for 2 columns""}, {'name': 'delimiter', 'type': 'str, optional', 'description': 'String or character separating columns.'}, {'name': 'newline', 'type': 'str, optional', 'description': 'String or character separating lines.'}, {'name': 'header', 'type': 'str, optional', 'description': 'String that will be written at the beginning of the file.'}, {'name': 'footer', 'type': 'str, optional', 'description': 'String that will be written at the end of the file.'}, {'name': 'comments', 'type': 'str, optional', 'description': 'String that will be prepended to the header and footer strings,to mark them as comments. Default: ‘# ‘,  as expected by e.g.numpy.loadtxt.'}, {'name': 'encoding', 'type': '{None, str}, optional', 'description': 'Encoding used to encode the outputfile. Does not apply to outputstreams. If the encoding is something other than ‘bytes’ or ‘latin1’you will not be able to load the file in NumPy versions < 1.14. Defaultis ‘latin1’.'}]}]",">>> import numpy as np
>>> x = y = z = np.arange(0.0,5.0,1.0)
>>> np.savetxt('test.out', x, delimiter=',')   # X is an array
>>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays
>>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation"
numpy.genfromtxt,"Load data from a text file, with missing values handled as specified.","[{'Parameters': [{'name': 'fname', 'type': 'file, str, pathlib.Path, list of str, generator', 'description': 'File, filename, list, or generator to read.  If the filenameextension is .gz or .bz2, the file is first decompressed. Notethat generators must return bytes or strings. The stringsin a list or produced by a generator are treated as lines.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Data type of the resulting array.If None, the dtypes will be determined by the contents of eachcolumn, individually.'}, {'name': 'comments', 'type': 'str, optional', 'description': 'The character used to indicate the start of a comment.All the characters occurring on a line after a comment are discarded.'}, {'name': 'delimiter', 'type': 'str, int, or sequence, optional', 'description': 'The string used to separate values.  By default, any consecutivewhitespaces act as delimiter.  An integer or sequence of integerscan also be provided as width(s) of each field.'}, {'name': 'skiprows', 'type': 'int, optional', 'description': 'skiprows was removed in numpy 1.10. Please use skip_header instead.'}, {'name': 'skip_header', 'type': 'int, optional', 'description': 'The number of lines to skip at the beginning of the file.'}, {'name': 'skip_footer', 'type': 'int, optional', 'description': 'The number of lines to skip at the end of the file.'}, {'name': 'converters', 'type': 'variable, optional', 'description': 'The set of functions that convert the data of a column to a value.The converters can also be used to provide a default valuefor missing data: converters = {3: lambda s: float(s or 0)}.'}, {'name': 'missing', 'type': 'variable, optional', 'description': 'missing was removed in numpy 1.10. Please use missing_valuesinstead.'}, {'name': 'missing_values', 'type': 'variable, optional', 'description': 'The set of strings corresponding to missing data.'}, {'name': 'filling_values', 'type': 'variable, optional', 'description': 'The set of values to be used as default when the data are missing.'}, {'name': 'usecols', 'type': 'sequence, optional', 'description': 'Which columns to read, with 0 being the first.  For example,usecols = (1, 4, 5) will extract the 2nd, 5th and 6th columns.'}, {'name': 'names', 'type': '{None, True, str, sequence}, optional', 'description': 'If names is True, the field names are read from the first line afterthe first skip_header lines. This line can optionally be precededby a comment delimiter. Any content before the comment delimiter isdiscarded. If names is a sequence or a single-string ofcomma-separated names, the names will be used to define the fieldnames in a structured dtype. If names is None, the names of thedtype fields will be used, if any.'}, {'name': 'excludelist', 'type': 'sequence, optional', 'description': 'A list of names to exclude. This list is appended to the default list[‘return’,’file’,’print’]. Excluded names are appended with anunderscore: for example, file would become file_.'}, {'name': 'deletechars', 'type': 'str, optional', 'description': 'A string combining invalid characters that must be deleted from thenames.'}, {'name': 'defaultfmt', 'type': 'str, optional', 'description': 'A format used to define default field names, such as “f%i” or “f_%02i”.'}, {'name': 'autostrip', 'type': 'bool, optional', 'description': 'Whether to automatically strip white spaces from the variables.'}, {'name': 'replace_space', 'type': 'char, optional', 'description': 'Character(s) used in replacement of white spaces in the variablenames. By default, use a ‘_’.'}, {'name': 'case_sensitive', 'type': '{True, False, ‘upper’, ‘lower’}, optional', 'description': 'If True, field names are case sensitive.If False or ‘upper’, field names are converted to upper case.If ‘lower’, field names are converted to lower case.'}, {'name': 'unpack', 'type': 'bool, optional', 'description': 'If True, the returned array is transposed, so that arguments may beunpacked using x, y, z = genfromtxt(...).  When used with astructured data-type, arrays are returned for each field.Default is False.'}, {'name': 'usemask', 'type': 'bool, optional', 'description': 'If True, return a masked array.If False, return a regular array.'}, {'name': 'loose', 'type': 'bool, optional', 'description': 'If True, do not raise errors for invalid values.'}, {'name': 'invalid_raise', 'type': 'bool, optional', 'description': 'If True, an exception is raised if an inconsistency is detected in thenumber of columns.If False, a warning is emitted and the offending lines are skipped.'}, {'name': 'max_rows', 'type': 'int,  optional', 'description': 'The maximum number of rows to read. Must not be used with skip_footerat the same time.  If given, the value must be at least 1. Default isto read the entire file.'}, {'name': 'encoding', 'type': 'str, optional', 'description': ""Encoding used to decode the inputfile. Does not apply when fnameis a file object. The special value ‘bytes’ enables backwardcompatibility workarounds that ensure that you receive byte arrayswhen possible and passes latin1 encoded strings to converters.Override this value to receive unicode arrays and pass stringsas input to converters.  If set to None the system default is used.The default value is ‘bytes’.Changed in version 2.0: Before NumPy 2, the default was 'bytes' for Python 2compatibility. The default is now None.""}, {'name': 'ndmin', 'type': 'int, optional', 'description': 'Same parameter as loadtxtNew in version 1.23.0.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Data read from the text file. If usemask is True, this is amasked array.'}]}]",">>> from io import StringIO
>>> import numpy as np
>>> s = StringIO(""1,1.3,abcde"")
>>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),
... ('mystring','S5')], delimiter="","")
>>> data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])
>>> _ = s.seek(0) # needed for StringIO example only
>>> data = np.genfromtxt(s, dtype=None,
... names = ['myint','myfloat','mystring'], delimiter="","")
>>> data
array((1, 1.3, 'abcde'),
      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '<U5')])
>>> _ = s.seek(0)
>>> data = np.genfromtxt(s, dtype=""i8,f8,S5"",
... names=['myint','myfloat','mystring'], delimiter="","")
>>> data
array((1, 1.3, b'abcde'),
      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])
>>> s = StringIO(""11.3abcde"")
>>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],
...     delimiter=[1,3,5])
>>> data
array((1, 1.3, 'abcde'),
      dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '<U5')])
>>> f = StringIO('''
... text,# of chars
... hello world,11
... numpy,5''')
>>> np.genfromtxt(f, dtype='S12,S12', delimiter=',')
array([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],
  dtype=[('f0', 'S12'), ('f1', 'S12')])"
numpy.fromregex,"Construct an array from a text file, using regular expression parsing.","[{'Parameters': [{'name': 'file', 'type': 'file, str, or pathlib.Path', 'description': 'Filename or file object to read.Changed in version 1.22.0: Now accepts os.PathLike implementations.'}, {'name': 'regexp', 'type': 'str or regexp', 'description': 'Regular expression used to parse the file.Groups in the regular expression correspond to fields in the dtype.'}, {'name': 'dtype', 'type': 'dtype or list of dtypes', 'description': 'Dtype for the structured array; must be a structured datatype.'}, {'name': 'encoding', 'type': 'str, optional', 'description': 'Encoding used to decode the inputfile. Does not apply to input streams.'}]}, {'Returns': [{'name': 'output', 'type': 'ndarray', 'description': 'The output array, containing the part of the content of file thatwas matched by regexp. output is always a structured array.'}]}, {'Raises': [{'name': 'TypeError', 'type': None, 'description': 'When dtype is not a valid dtype for a structured array.'}]}]",">>> import numpy as np
>>> from io import StringIO
>>> text = StringIO(""1312 foo\n1534  bar\n444   qux"")
>>> regexp = r""(\d+)\s+(...)""  # match [digits, whitespace, anything]
>>> output = np.fromregex(text, regexp,
...                       [('num', np.int64), ('key', 'S3')])
>>> output
array([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],
      dtype=[('num', '<i8'), ('key', 'S3')])
>>> output['num']
array([1312, 1534,  444])"
numpy.fromstring,A new 1-D array initialized from text data in a string.,"[{'Parameters': [{'name': 'string', 'type': 'str', 'description': 'A string containing the data.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The data type of the array; default: float.  For binary input data,the data must be in exactly this format. Most builtin numeric types aresupported and extension types may be supported.'}, {'name': 'count', 'type': 'int, optional', 'description': 'Read this number of dtype elements from the data.  If this isnegative (the default), the count will be determined from thelength of the data.'}, {'name': 'sep', 'type': 'str, optional', 'description': ""The string separating numbers in the data; extra whitespace betweenelements is also ignored.Deprecated since version 1.14: Passing sep='', the default, is deprecated since it willtrigger the deprecated binary mode of this function. This modeinterprets string as binary bytes, rather than ASCII text withdecimal numbers, an operation which is better speltfrombuffer(string, dtype, count). If string contains unicodetext, the binary mode of fromstring will first encode it intobytes using utf-8, which will not produce sane results.""}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}, {'Returns': [{'name': 'arr', 'type': 'ndarray', 'description': 'The constructed array.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the string is not the correct size to satisfy the requesteddtype and count.'}]}]",">>> import numpy as np
>>> np.fromstring('1 2', dtype=int, sep=' ')
array([1, 2])
>>> np.fromstring('1, 2', dtype=int, sep=',')
array([1, 2])"
numpy.ndarray.tofile,method,"[{'Parameters': [{'name': 'fid', 'type': 'file or str or Path', 'description': 'An open file object, or a string containing a filename.'}, {'name': 'sep', 'type': 'str', 'description': 'Separator between array items for text output.If “” (empty), a binary file is written, equivalent tofile.write(a.tobytes()).'}, {'name': 'format', 'type': 'str', 'description': 'Format string for text file output.Each entry in the array is formatted to text by first convertingit to the closest Python type, and then using “format” % item.'}]}]",
numpy.ndarray.tolist,method,"[{'Parameters': [{'name': 'none', 'type': None, 'description': ''}]}, {'Returns': [{'name': 'y', 'type': 'object, or list of object, or list of list of object, or …', 'description': 'The possibly nested list of array elements.'}]}]",">>> import numpy as np
>>> a = np.uint32([1, 2])
>>> a_list = list(a)
>>> a_list
[np.uint32(1), np.uint32(2)]
>>> type(a_list[0])
<class 'numpy.uint32'>
>>> a_tolist = a.tolist()
>>> a_tolist
[1, 2]
>>> type(a_tolist[0])
<class 'int'>
>>> a = np.array([[1, 2], [3, 4]])
>>> list(a)
[array([1, 2]), array([3, 4])]
>>> a.tolist()
[[1, 2], [3, 4]]
>>> a = np.array(1)
>>> list(a)
Traceback (most recent call last):
  ...
TypeError: iteration over a 0-d array
>>> a.tolist()
1"
numpy.fromfile,Construct an array from data in a text or binary file.,"[{'Parameters': [{'name': 'file', 'type': 'file or str or Path', 'description': 'Open file object or filename.'}, {'name': 'dtype', 'type': 'data-type', 'description': 'Data type of the returned array.For binary files, it is used to determine the size and byte-orderof the items in the file.Most builtin numeric types are supported and extension types may be supported.'}, {'name': 'count', 'type': 'int', 'description': 'Number of items to read. -1 means all items (i.e., the completefile).'}, {'name': 'sep', 'type': 'str', 'description': 'Separator between items if file is a text file.Empty (“”) separator means the file should be treated as binary.Spaces (” “) in the separator match zero or more whitespace characters.A separator consisting only of spaces must match at least onewhitespace.'}, {'name': 'offset', 'type': 'int', 'description': 'The offset (in bytes) from the file’s current position. Defaults to 0.Only permitted for binary files.'}, {'name': 'like', 'type': 'array_like, optional', 'description': 'Reference object to allow the creation of arrays which are notNumPy arrays. If an array-like passed in as like supportsthe __array_function__ protocol, the result will be definedby it. In this case, it ensures the creation of an array objectcompatible with that passed in via this argument.New in version 1.20.0.'}]}]",">>> import numpy as np
>>> dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),
...                ('temp', float)])
>>> x = np.zeros((1,), dtype=dt)
>>> x['time']['min'] = 10; x['temp'] = 98.25
>>> x
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
>>> import tempfile
>>> fname = tempfile.mkstemp()[1]
>>> x.tofile(fname)
>>> np.fromfile(fname, dtype=dt)
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
>>> np.save(fname, x)
>>> np.load(fname + '.npy')
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])"
numpy.array2string,Return a string representation of an array.,"[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'Input array.'}, {'name': 'max_line_width', 'type': 'int, optional', 'description': ""Inserts newlines if text is longer than max_line_width.Defaults to numpy.get_printoptions()['linewidth'].""}, {'name': 'precision', 'type': 'int or None, optional', 'description': ""Floating point precision.Defaults to numpy.get_printoptions()['precision'].""}, {'name': 'suppress_small', 'type': 'bool, optional', 'description': ""Represent numbers “very close” to zero as zero; default is False.Very close is defined by precision: if the precision is 8, e.g.,numbers smaller (in absolute value) than 5e-9 are represented aszero.Defaults to numpy.get_printoptions()['suppress'].""}, {'name': 'separator', 'type': 'str, optional', 'description': 'Inserted between elements.'}, {'name': 'prefix', 'type': 'str, optional', 'description': ''}, {'name': 'suffix', 'type': 'str, optional', 'description': 'The length of the prefix and suffix strings are used to respectivelyalign and wrap the output. An array is typically printed as:prefix + array2string(a) + suffixThe output is left-padded by the length of the prefix string, andwrapping is forced at the column max_line_width - len(suffix).It should be noted that the content of prefix and suffix strings arenot included in the output.'}, {'name': 'style', 'type': '_NoValue, optional', 'description': 'Has no effect, do not use.Deprecated since version 1.14.0.'}, {'name': 'formatter', 'type': 'dict of callables, optional', 'description': 'If not None, the keys should indicate the type(s) that the respectiveformatting function applies to.  Callables should return a string.Types that are not specified (by their corresponding keys) are handledby the default formatters.  Individual types for which a formattercan be set are:‘bool’‘int’‘timedelta’ : a numpy.timedelta64‘datetime’ : a numpy.datetime64‘float’‘longfloat’ : 128-bit floats‘complexfloat’‘longcomplexfloat’ : composed of two 128-bit floats‘void’ : type numpy.void‘numpystr’ : types numpy.bytes_ and numpy.str_Other keys that can be used to set a group of types at once are:‘all’ : sets all types‘int_kind’ : sets ‘int’‘float_kind’ : sets ‘float’ and ‘longfloat’‘complex_kind’ : sets ‘complexfloat’ and ‘longcomplexfloat’‘str_kind’ : sets ‘numpystr’'}, {'name': 'threshold', 'type': 'int, optional', 'description': ""Total number of array elements which trigger summarizationrather than full repr.Defaults to numpy.get_printoptions()['threshold'].""}, {'name': 'edgeitems', 'type': 'int, optional', 'description': ""Number of array items in summary at beginning and end ofeach dimension.Defaults to numpy.get_printoptions()['edgeitems'].""}, {'name': 'sign', 'type': 'string, either ‘-’, ‘+’, or ‘ ‘, optional', 'description': ""Controls printing of the sign of floating-point types. If ‘+’, alwaysprint the sign of positive values. If ‘ ‘, always prints a space(whitespace character) in the sign position of positive values.  If‘-’, omit the sign character of positive values.Defaults to numpy.get_printoptions()['sign'].Changed in version 2.0: The sign parameter can now be an integer type, previouslytypes were floating-point types.""}, {'name': 'floatmode', 'type': 'str, optional', 'description': ""Controls the interpretation of the precision option forfloating-point types.Defaults to numpy.get_printoptions()['floatmode'].Can take the following values:‘fixed’: Always print exactly precision fractional digits,even if this would print more or fewer digits thannecessary to specify the value uniquely.‘unique’: Print the minimum number of fractional digits necessaryto represent each value uniquely. Different elements mayhave a different number of digits.  The value of theprecision option is ignored.‘maxprec’: Print at most precision fractional digits, but ifan element can be uniquely represented with fewer digitsonly print it with that many.‘maxprec_equal’: Print at most precision fractional digits,but if every element in the array can be uniquelyrepresented with an equal number of fewer digits, use thatmany digits for all elements.""}, {'name': 'legacy', 'type': 'string or False, optional', 'description': ""If set to the string '1.13' enables 1.13 legacy printing mode. Thisapproximates numpy 1.13 print output by including a space in the signposition of floats and different behavior for 0d arrays. If set toFalse, disables legacy mode. Unrecognized strings will be ignoredwith a warning for forward compatibility.""}]}, {'Returns': [{'name': 'array_str', 'type': 'str', 'description': 'String representation of the array.'}]}, {'Raises': [{'name': 'TypeError', 'type': None, 'description': 'if a callable in formatter does not return a string.'}]}]",">>> import numpy as np
>>> x = np.array([1e-16,1,2,3])
>>> np.array2string(x, precision=2, separator=',',
...                       suppress_small=True)
'[0.,1.,2.,3.]'
>>> x  = np.arange(3.)
>>> np.array2string(x, formatter={'float_kind':lambda x: ""%.2f"" % x})
'[0.00 1.00 2.00]'
>>> x  = np.arange(3)
>>> np.array2string(x, formatter={'int':lambda x: hex(x)})
'[0x0 0x1 0x2]'"
numpy.array_repr,Return the string representation of an array.,"[{'Parameters': [{'name': 'arr', 'type': 'ndarray', 'description': 'Input array.'}, {'name': 'max_line_width', 'type': 'int, optional', 'description': ""Inserts newlines if text is longer than max_line_width.Defaults to numpy.get_printoptions()['linewidth'].""}, {'name': 'precision', 'type': 'int, optional', 'description': ""Floating point precision.Defaults to numpy.get_printoptions()['precision'].""}, {'name': 'suppress_small', 'type': 'bool, optional', 'description': ""Represent numbers “very close” to zero as zero; default is False.Very close is defined by precision: if the precision is 8, e.g.,numbers smaller (in absolute value) than 5e-9 are represented aszero.Defaults to numpy.get_printoptions()['suppress'].""}]}, {'Returns': [{'name': 'string', 'type': 'str', 'description': 'The string representation of an array.'}]}]",">>> import numpy as np
>>> np.array_repr(np.array([1,2]))
'array([1, 2])'
>>> np.array_repr(np.ma.array([0.]))
'MaskedArray([0.])'
>>> np.array_repr(np.array([], np.int32))
'array([], dtype=int32)'
>>> x = np.array([1e-6, 4e-7, 2, 3])
>>> np.array_repr(x, precision=6, suppress_small=True)
'array([0.000001,  0.      ,  2.      ,  3.      ])'"
numpy.array_str,Return a string representation of the data in an array.,"[{'Parameters': [{'name': 'a', 'type': 'ndarray', 'description': 'Input array.'}, {'name': 'max_line_width', 'type': 'int, optional', 'description': ""Inserts newlines if text is longer than max_line_width.Defaults to numpy.get_printoptions()['linewidth'].""}, {'name': 'precision', 'type': 'int, optional', 'description': ""Floating point precision.Defaults to numpy.get_printoptions()['precision'].""}, {'name': 'suppress_small', 'type': 'bool, optional', 'description': ""Represent numbers “very close” to zero as zero; default is False.Very close is defined by precision: if the precision is 8, e.g.,numbers smaller (in absolute value) than 5e-9 are represented aszero.Defaults to numpy.get_printoptions()['suppress'].""}]}]",">>> import numpy as np
>>> np.array_str(np.arange(3))
'[0 1 2]'"
numpy.format_float_positional,Format a floating-point scalar as a decimal string in positional notation.,"[{'Parameters': [{'name': 'x', 'type': 'python float or numpy floating scalar', 'description': 'Value to format.'}, {'name': 'precision', 'type': 'non-negative integer or None, optional', 'description': 'Maximum number of digits to print. May be None if unique isTrue, but must be an integer if unique is False.'}, {'name': 'unique', 'type': 'boolean, optional', 'description': 'If True, use a digit-generation strategy which gives the shortestrepresentation which uniquely identifies the floating-point number fromother values of the same type, by judicious rounding. If precisionis given fewer digits than necessary can be printed, or if min_digitsis given more can be printed, in which cases the last digit is roundedwith unbiased rounding.If False, digits are generated as if printing an infinite-precisionvalue and stopping after precision digits, rounding the remainingvalue with unbiased rounding'}, {'name': 'fractional', 'type': 'boolean, optional', 'description': 'If True, the cutoffs of precision and min_digits refer to thetotal number of digits after the decimal point, including leadingzeros.If False, precision and min_digits refer to the total number ofsignificant digits, before or after the decimal point, ignoring leadingzeros.'}, {'name': 'trim', 'type': 'one of ‘k’, ‘.’, ‘0’, ‘-’, optional', 'description': 'Controls post-processing trimming of trailing digits, as follows:‘k’ : keep trailing zeros, keep decimal point (no trimming)‘.’ : trim all trailing zeros, leave decimal point‘0’ : trim all but the zero before the decimal point. Insert thezero if it is missing.‘-’ : trim trailing zeros and any trailing decimal point'}, {'name': 'sign', 'type': 'boolean, optional', 'description': 'Whether to show the sign for positive values.'}, {'name': 'pad_left', 'type': 'non-negative integer, optional', 'description': 'Pad the left side of the string with whitespace until at least thatmany characters are to the left of the decimal point.'}, {'name': 'pad_right', 'type': 'non-negative integer, optional', 'description': 'Pad the right side of the string with whitespace until at least thatmany characters are to the right of the decimal point.'}, {'name': 'min_digits', 'type': 'non-negative integer or None, optional', 'description': 'Minimum number of digits to print. Only has an effect if unique=Truein which case additional digits past those necessary to uniquelyidentify the value may be printed, rounding the last additional digit.New in version 1.21.0.'}]}, {'Returns': [{'name': 'rep', 'type': 'string', 'description': 'The string representation of the floating point value'}]}]",">>> import numpy as np
>>> np.format_float_positional(np.float32(np.pi))
'3.1415927'
>>> np.format_float_positional(np.float16(np.pi))
'3.14'
>>> np.format_float_positional(np.float16(0.3))
'0.3'
>>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)
'0.3000488281'"
numpy.format_float_scientific,Format a floating-point scalar as a decimal string in scientific notation.,"[{'Parameters': [{'name': 'x', 'type': 'python float or numpy floating scalar', 'description': 'Value to format.'}, {'name': 'precision', 'type': 'non-negative integer or None, optional', 'description': 'Maximum number of digits to print. May be None if unique isTrue, but must be an integer if unique is False.'}, {'name': 'unique', 'type': 'boolean, optional', 'description': 'If True, use a digit-generation strategy which gives the shortestrepresentation which uniquely identifies the floating-point number fromother values of the same type, by judicious rounding. If precisionis given fewer digits than necessary can be printed. If min_digitsis given more can be printed, in which cases the last digit is roundedwith unbiased rounding.If False, digits are generated as if printing an infinite-precisionvalue and stopping after precision digits, rounding the remainingvalue with unbiased rounding'}, {'name': 'trim', 'type': 'one of ‘k’, ‘.’, ‘0’, ‘-’, optional', 'description': 'Controls post-processing trimming of trailing digits, as follows:‘k’ : keep trailing zeros, keep decimal point (no trimming)‘.’ : trim all trailing zeros, leave decimal point‘0’ : trim all but the zero before the decimal point. Insert thezero if it is missing.‘-’ : trim trailing zeros and any trailing decimal point'}, {'name': 'sign', 'type': 'boolean, optional', 'description': 'Whether to show the sign for positive values.'}, {'name': 'pad_left', 'type': 'non-negative integer, optional', 'description': 'Pad the left side of the string with whitespace until at least thatmany characters are to the left of the decimal point.'}, {'name': 'exp_digits', 'type': 'non-negative integer, optional', 'description': 'Pad the exponent with zeros until it contains at least thismany digits. If omitted, the exponent will be at least 2 digits.'}, {'name': 'min_digits', 'type': 'non-negative integer or None, optional', 'description': 'Minimum number of digits to print. This only has an effect forunique=True. In that case more digits than necessary to uniquelyidentify the value may be printed and rounded unbiased.New in version 1.21.0.'}]}, {'Returns': [{'name': 'rep', 'type': 'string', 'description': 'The string representation of the floating point value'}]}]",">>> import numpy as np
>>> np.format_float_scientific(np.float32(np.pi))
'3.1415927e+00'
>>> s = np.float32(1.23e24)
>>> np.format_float_scientific(s, unique=False, precision=15)
'1.230000071797338e+24'
>>> np.format_float_scientific(s, exp_digits=4)
'1.23e+0024'"
numpy.memmap,Create a memory-map to an array stored in a binary file on disk.,"[{'Parameters': [{'name': 'filename', 'type': 'str, file-like object, or pathlib.Path instance', 'description': 'The file name or file object to be used as the array data buffer.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The data-type used to interpret the file contents.Default is uint8.'}, {'name': 'mode', 'type': '{‘r+’, ‘r’, ‘w+’, ‘c’}, optional', 'description': ""The file is opened in this mode:‘r’Open existing file for reading only.‘r+’Open existing file for reading and writing.‘w+’Create or overwrite existing file for reading and writing.If mode == 'w+' then shape must also be specified.‘c’Copy-on-write: assignments affect data in memory, butchanges are not saved to disk.  The file on disk isread-only.Default is ‘r+’.""}, {'name': 'offset', 'type': 'int, optional', 'description': ""In the file, array data starts at this offset. Since offset ismeasured in bytes, it should normally be a multiple of the byte-sizeof dtype. When mode != 'r', even positive offsets beyond end offile are valid; The file will be extended to accommodate theadditional data. By default, memmap will start at the beginning ofthe file, even if filename is a file pointer fp andfp.tell() != 0.""}, {'name': 'shape', 'type': 'int or sequence of ints, optional', 'description': ""The desired shape of the array. If mode == 'r' and the numberof remaining bytes after offset is not a multiple of the byte-sizeof dtype, you must specify shape. By default, the returned arraywill be 1-D with the number of elements determined by file sizeand data-type.Changed in version 2.0: The shape parameter can now be any integer sequence type, previouslytypes were limited to tuple and int.""}, {'name': 'order', 'type': '{‘C’, ‘F’}, optional', 'description': 'Specify the order of the ndarray memory layout:row-major, C-style or column-major,Fortran-style.  This only has an effect if the shape isgreater than 1-D.  The default order is ‘C’.'}]}, {'Attributes': [{'name': 'filename', 'type': 'str or pathlib.Path instance', 'description': 'Path to the mapped file.'}, {'name': 'offset', 'type': 'int', 'description': 'Offset position in the file.'}, {'name': 'mode', 'type': 'str', 'description': 'File mode.'}]}]",">>> import numpy as np
>>> data = np.arange(12, dtype='float32')
>>> data.resize((3,4))
>>> from tempfile import mkdtemp
>>> import os.path as path
>>> filename = path.join(mkdtemp(), 'newfile.dat')
>>> fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))
>>> fp
memmap([[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]], dtype=float32)
>>> fp[:] = data[:]
>>> fp
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)
>>> fp.filename == path.abspath(filename)
True
>>> fp.flush()
>>> newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
>>> newfp
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)
>>> fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
>>> fpr.flags.writeable
False
>>> fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))
>>> fpc.flags.writeable
True
>>> fpc
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)
>>> fpc[0,:] = 0
>>> fpc
memmap([[  0.,   0.,   0.,   0.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)
>>> fpr
memmap([[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.]], dtype=float32)
>>> fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)
>>> fpo
memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)"
numpy.lib.format.open_memmap,Open a .npy file as a memory-mapped array.,"[{'Parameters': [{'name': 'filename', 'type': 'str or path-like', 'description': 'The name of the file on disk.  This may not be a file-likeobject.'}, {'name': 'mode', 'type': 'str, optional', 'description': 'The mode in which to open the file; the default is ‘r+’.  Inaddition to the standard file modes, ‘c’ is also accepted to mean“copy on write.”  See memmap for the available mode strings.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The data type of the array if we are creating a new file in “write”mode, if not, dtype is ignored.  The default value is None, whichresults in a data-type of float64.'}, {'name': 'shape', 'type': 'tuple of int', 'description': 'The shape of the array if we are creating a new file in “write”mode, in which case this parameter is required.  Otherwise, thisparameter is ignored and is thus optional.'}, {'name': 'fortran_order', 'type': 'bool, optional', 'description': 'Whether the array should be Fortran-contiguous (True) orC-contiguous (False, the default) if we are creating a new file in“write” mode.'}, {'name': 'version', 'type': 'tuple of int (major, minor) or None', 'description': 'If the mode is a “write” mode, then this is the version of the fileformat used to create the file.  None means use the oldestsupported version that is able to store the data.  Default: None'}, {'name': 'max_header_size', 'type': 'int, optional', 'description': 'Maximum allowed size of the header.  Large headers may not be safeto load securely and thus require explicitly passing a larger value.See ast.literal_eval for details.'}]}, {'Returns': [{'name': 'marray', 'type': 'memmap', 'description': 'The memory-mapped array.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the data or the mode is invalid.'}, {'name': 'OSError', 'type': None, 'description': 'If the file is not found or cannot be opened correctly.'}]}]",
numpy.set_printoptions,Set printing options.,"[{'Parameters': [{'name': 'precision', 'type': 'int or None, optional', 'description': 'Number of digits of precision for floating point output (default 8).May be None if floatmode is not fixed, to print as many digits asnecessary to uniquely specify the value.'}, {'name': 'threshold', 'type': 'int, optional', 'description': 'Total number of array elements which trigger summarizationrather than full repr (default 1000).To always use the full repr without summarization, pass sys.maxsize.'}, {'name': 'edgeitems', 'type': 'int, optional', 'description': 'Number of array items in summary at beginning and end ofeach dimension (default 3).'}, {'name': 'linewidth', 'type': 'int, optional', 'description': 'The number of characters per line for the purpose of insertingline breaks (default 75).'}, {'name': 'suppress', 'type': 'bool, optional', 'description': 'If True, always print floating point numbers using fixed pointnotation, in which case numbers equal to zero in the current precisionwill print as zero.  If False, then scientific notation is used whenabsolute value of the smallest number is < 1e-4 or the ratio of themaximum absolute value to the minimum is > 1e3. The default is False.'}, {'name': 'nanstr', 'type': 'str, optional', 'description': 'String representation of floating point not-a-number (default nan).'}, {'name': 'infstr', 'type': 'str, optional', 'description': 'String representation of floating point infinity (default inf).'}, {'name': 'sign', 'type': 'string, either ‘-’, ‘+’, or ‘ ‘, optional', 'description': 'Controls printing of the sign of floating-point types. If ‘+’, alwaysprint the sign of positive values. If ‘ ‘, always prints a space(whitespace character) in the sign position of positive values.  If‘-’, omit the sign character of positive values. (default ‘-‘)Changed in version 2.0: The sign parameter can now be an integer type, previouslytypes were floating-point types.'}, {'name': 'formatter', 'type': 'dict of callables, optional', 'description': 'If not None, the keys should indicate the type(s) that the respectiveformatting function applies to.  Callables should return a string.Types that are not specified (by their corresponding keys) are handledby the default formatters.  Individual types for which a formattercan be set are:‘bool’‘int’‘timedelta’ : a numpy.timedelta64‘datetime’ : a numpy.datetime64‘float’‘longfloat’ : 128-bit floats‘complexfloat’‘longcomplexfloat’ : composed of two 128-bit floats‘numpystr’ : types numpy.bytes_ and numpy.str_‘object’ : np.object_ arraysOther keys that can be used to set a group of types at once are:‘all’ : sets all types‘int_kind’ : sets ‘int’‘float_kind’ : sets ‘float’ and ‘longfloat’‘complex_kind’ : sets ‘complexfloat’ and ‘longcomplexfloat’‘str_kind’ : sets ‘numpystr’'}, {'name': 'floatmode', 'type': 'str, optional', 'description': 'Controls the interpretation of the precision option forfloating-point types. Can take the following values(default maxprec_equal):‘fixed’: Always print exactly precision fractional digits,even if this would print more or fewer digits thannecessary to specify the value uniquely.‘unique’: Print the minimum number of fractional digits necessaryto represent each value uniquely. Different elements mayhave a different number of digits. The value of theprecision option is ignored.‘maxprec’: Print at most precision fractional digits, but ifan element can be uniquely represented with fewer digitsonly print it with that many.‘maxprec_equal’: Print at most precision fractional digits,but if every element in the array can be uniquelyrepresented with an equal number of fewer digits, use thatmany digits for all elements.'}, {'name': '‘fixed’: Always print exactly precision fractional digits,', 'type': None, 'description': 'even if this would print more or fewer digits thannecessary to specify the value uniquely.'}, {'name': '‘unique’: Print the minimum number of fractional digits necessary', 'type': None, 'description': 'to represent each value uniquely. Different elements mayhave a different number of digits. The value of theprecision option is ignored.'}, {'name': '‘maxprec’: Print at most precision fractional digits, but if', 'type': None, 'description': 'an element can be uniquely represented with fewer digitsonly print it with that many.'}, {'name': '‘maxprec_equal’: Print at most precision fractional digits,', 'type': None, 'description': 'but if every element in the array can be uniquelyrepresented with an equal number of fewer digits, use thatmany digits for all elements.'}, {'name': 'legacy', 'type': 'string or False, optional', 'description': ""If set to the string '1.13' enables 1.13 legacy printing mode. Thisapproximates numpy 1.13 print output by including a space in the signposition of floats and different behavior for 0d arrays. This alsoenables 1.21 legacy printing mode (described below).If set to the string '1.21' enables 1.21 legacy printing mode. Thisapproximates numpy 1.21 print output of complex structured dtypesby not inserting spaces after commas that separate fields and aftercolons.If set to '1.25' approximates printing of 1.25 which mainly meansthat numeric scalars are printed without their type information, e.g.as 3.0 rather than np.float64(3.0).If set to '2.1', shape information is not given when arrays aresummarized (i.e., multiple elements replaced with ...).If set to False, disables legacy mode.Unrecognized strings will be ignored with a warning for forwardcompatibility.Changed in version 1.22.0.Changed in version 2.2.""}, {'name': 'override_repr: callable, optional', 'type': None, 'description': 'If set a passed function will be used for generating arrays’ repr.Other options will be ignored.'}]}]",">>> import numpy as np
>>> np.set_printoptions(precision=4)
>>> np.array([1.123456789])
[1.1235]
>>> np.set_printoptions(threshold=5)
>>> np.arange(10)
array([0, 1, 2, ..., 7, 8, 9], shape=(10,))
>>> eps = np.finfo(float).eps
>>> x = np.arange(4.)
>>> x**2 - (x + eps)**2
array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])
>>> np.set_printoptions(suppress=True)
>>> x**2 - (x + eps)**2
array([-0., -0.,  0.,  0.])
>>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})
>>> x = np.arange(3)
>>> x
array([int: 0, int: -1, int: -2])
>>> np.set_printoptions()  # formatter gets reset
>>> x
array([0, 1, 2])
>>> np.set_printoptions(edgeitems=3, infstr='inf',
... linewidth=75, nanstr='nan', precision=8,
... suppress=False, threshold=1000, formatter=None)
>>> with np.printoptions(precision=2, suppress=True, threshold=5):
...     np.linspace(0, 10, 10)
array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ], shape=(10,))"
numpy.get_printoptions,Return the current print options.,"[{'Returns': [{'name': 'print_opts', 'type': 'dict', 'description': 'Dictionary of current print options with keysprecision : intthreshold : intedgeitems : intlinewidth : intsuppress : boolnanstr : strinfstr : strsign : strformatter : dict of callablesfloatmode : strlegacy : str or FalseFor a full description of these options, see set_printoptions.'}]}]",">>> import numpy as np
>>> np.get_printoptions()
{'edgeitems': 3, 'threshold': 1000, ..., 'override_repr': None}
>>> np.get_printoptions()['linewidth']
75
>>> np.set_printoptions(linewidth=100)
>>> np.get_printoptions()['linewidth']
100"
numpy.printoptions,Context manager for setting print options.,[],">>> import numpy as np
>>> from numpy.testing import assert_equal
>>> with np.printoptions(precision=2):
...     np.array([2.0]) / 3
array([0.67])
>>> with np.printoptions(precision=2) as opts:
...      assert_equal(opts, np.get_printoptions())"
numpy.binary_repr,Return the binary representation of the input number as a string.,"[{'Parameters': [{'name': 'num', 'type': 'int', 'description': 'Only an integer decimal number can be used.'}, {'name': 'width', 'type': 'int, optional', 'description': 'The length of the returned string if num is positive, or the lengthof the two’s complement if num is negative, provided that width isat least a sufficient number of bits for num to be represented inthe designated form. If the width value is insufficient, an error israised.'}]}, {'Returns': [{'name': 'bin', 'type': 'str', 'description': 'Binary representation of num or two’s complement of num.'}]}]",">>> import numpy as np
>>> np.binary_repr(3)
'11'
>>> np.binary_repr(-3)
'-11'
>>> np.binary_repr(3, width=4)
'0011'
>>> np.binary_repr(-3, width=3)
'101'
>>> np.binary_repr(-3, width=5)
'11101'"
numpy.base_repr,Return a string representation of a number in the given base system.,"[{'Parameters': [{'name': 'number', 'type': 'int', 'description': 'The value to convert. Positive and negative values are handled.'}, {'name': 'base', 'type': 'int, optional', 'description': 'Convert number to the base number system. The valid range is 2-36,the default value is 2.'}, {'name': 'padding', 'type': 'int, optional', 'description': 'Number of zeros padded on the left. Default is 0 (no padding).'}]}, {'Returns': [{'name': 'out', 'type': 'str', 'description': 'String representation of number in base system.'}]}]",">>> import numpy as np
>>> np.base_repr(5)
'101'
>>> np.base_repr(6, 5)
'11'
>>> np.base_repr(7, base=5, padding=3)
'00012'
>>> np.base_repr(10, base=16)
'A'
>>> np.base_repr(32, base=16)
'20'"
numpy.lib.npyio.DataSource,"A generic data source file (file, http, ftp, …).","[{'Parameters': [{'name': 'destpath', 'type': 'str or None, optional', 'description': 'Path to the directory where the source file gets downloaded to foruse.  If destpath is None, a temporary directory will be created.The default path is the current directory.'}]}]",
numpy.lib.format,Binary serialization,[],
numpy.polynomial.hermite.Hermite,An Hermite series class.,"[{'Parameters': [{'name': 'coef', 'type': 'array_like', 'description': 'Hermite coefficients in order of increasing degree, i.e,(1, 2, 3) gives 1*H_0(x) + 2*H_1(x) + 3*H_2(x).'}, {'name': 'domain', 'type': '(2,) array_like, optional', 'description': 'Domain to use. The interval [domain[0], domain[1]] is mappedto the interval [window[0], window[1]] by shifting and scaling.The default value is [-1., 1.].'}, {'name': 'window', 'type': '(2,) array_like, optional', 'description': 'Window, see domain for its use. The default value is [-1., 1.].'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol used to represent the independent variable in stringrepresentations of the polynomial expression, e.g. for printing.The symbol must be a valid Python identifier. Default value is ‘x’.New in version 1.24.'}]}, {'Attributes': [{'name': 'symbol', 'type': None, 'description': ''}]}]",
numpy.polynomial.hermite.Hermite.__call__,method,[],
numpy.polynomial.hermite.Hermite.basis,method,"[{'Parameters': [{'name': 'deg', 'type': 'int', 'description': 'Degree of the basis polynomial for the series. Must be >= 0.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series with the coefficient of the deg term set to one andall others zero.'}]}]",
numpy.polynomial.hermite.Hermite.cast,method,"[{'Parameters': [{'name': 'series', 'type': 'series', 'description': 'The series instance to be converted.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series of the same kind as the calling class and equal toseries when evaluated.'}]}]",
numpy.polynomial.hermite.Hermite.convert,method,"[{'Parameters': [{'name': 'domain', 'type': 'array_like, optional', 'description': 'The domain of the converted series. If the value is None,the default domain of kind is used.'}, {'name': 'kind', 'type': 'class, optional', 'description': 'The polynomial series type class to which the current instanceshould be converted. If kind is None, then the class of thecurrent instance is used.'}, {'name': 'window', 'type': 'array_like, optional', 'description': 'The window of the converted series. If the value is None,the default window of kind is used.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'The returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.'}]}]",
numpy.polynomial.hermite.Hermite.copy,method,"[{'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Copy of self.'}]}]",
numpy.polynomial.hermite.Hermite.cutdeg,method,"[{'Parameters': [{'name': 'deg', 'type': 'non-negative int', 'description': 'The series is reduced to degree deg by discarding the highorder terms. The value of deg must be a non-negative integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with reduced degree.'}]}]",
numpy.polynomial.hermite.Hermite.degree,method,"[{'Returns': [{'name': 'degree', 'type': 'int', 'description': 'Degree of the series, one less than the number of coefficients.'}]}]",">>> poly = np.polynomial.Polynomial([1, 7, 4])
>>> print(poly)
1.0 + 7.0·x + 4.0·x²
>>> poly.degree()
2
>>> poly = np.polynomial.Polynomial([1, 7, 0])
>>> print(poly)
1.0 + 7.0·x + 0.0·x²
>>> poly.degree()
2
>>> poly.trim().degree()
1"
numpy.polynomial.hermite.Hermite.deriv,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'Find the derivative of order m.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the derivative. The domain is the sameas the domain of the differentiated series.'}]}]",
numpy.polynomial.hermite.Hermite.fit,method,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (M,)', 'description': 'x-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'y', 'type': 'array_like, shape (M,)', 'description': 'y-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'deg', 'type': 'int or 1-D array_like', 'description': 'Degree(s) of the fitting polynomials. If deg is a single integerall terms up to and including the deg’th term are included in thefit. For NumPy versions >= 1.11.0 a list of integers specifying thedegrees of the terms to include may be used instead.'}, {'name': 'domain', 'type': '{None, [beg, end], []}, optional', 'description': 'Domain to use for the returned series. If None,then a minimal domain that covers the points x is chosen.  If[] the class domain is used. The default value was theclass domain in NumPy 1.4 and None in later versions.The [] option was added in numpy 1.5.0.'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Relative condition number of the fit. Singular values smallerthan this relative to the largest singular value will beignored. The default value is len(x)*eps, where eps is therelative precision of the float type, about 2e-16 in mostcases.'}, {'name': 'full', 'type': 'bool, optional', 'description': 'Switch determining nature of return value. When it is False(the default) just the coefficients are returned, when Truediagnostic information from the singular value decomposition isalso returned.'}, {'name': 'w', 'type': 'array_like, shape (M,), optional', 'description': 'Weights. If not None, the weight w[i] applies to the unsquaredresidual y[i] - y_hat[i] at x[i]. Ideally the weights arechosen so that the errors of the products w[i]*y[i] all havethe same variance.  When using inverse-variance weighting, usew[i] = 1/sigma(y[i]).  The default value is None.'}, {'name': 'window', 'type': '{[beg, end]}, optional', 'description': 'Window to use for the returned series. The defaultvalue is the default class domain'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.'}, {'name': '[resid, rank, sv, rcond]', 'type': 'list', 'description': 'These values are only returned if full == Trueresid – sum of squared residuals of the least squares fitrank – the numerical rank of the scaled Vandermonde matrixsv – singular values of the scaled Vandermonde matrixrcond – value of rcond.For more details, see linalg.lstsq.'}]}]",
numpy.polynomial.hermite.Hermite.fromroots,method,"[{'Parameters': [{'name': 'roots', 'type': 'array_like', 'description': 'List of roots.'}, {'name': 'domain', 'type': '{[], None, array_like}, optional', 'description': 'Domain for the resulting series. If None the domain is theinterval from the smallest root to the largest. If [] thedomain is the class domain. The default is [].'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'Window for the returned series. If None the class window isused. The default is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series with the specified roots.'}]}]",
numpy.polynomial.hermite.Hermite.has_samecoef,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the coef attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the coefficients are the same, False otherwise.'}]}]",
numpy.polynomial.hermite.Hermite.has_samedomain,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the domain attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the domains are the same, False otherwise.'}]}]",
numpy.polynomial.hermite.Hermite.has_sametype,method,"[{'Parameters': [{'name': 'other', 'type': 'object', 'description': 'Class instance.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if other is same class as self'}]}]",
numpy.polynomial.hermite.Hermite.has_samewindow,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the window attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the windows are the same, False otherwise.'}]}]",
numpy.polynomial.hermite.Hermite.identity,method,"[{'Parameters': [{'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series of representing the identity.'}]}]",
numpy.polynomial.hermite.Hermite.integ,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'The number of integrations to perform.'}, {'name': 'k', 'type': 'array_like', 'description': 'Integration constants. The first constant is applied to thefirst integration, the second to the second, and so on. Thelist of values must less than or equal to m in length and anymissing values are set to zero.'}, {'name': 'lbnd', 'type': 'Scalar', 'description': 'The lower bound of the definite integral.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the integral. The domain is the sameas the domain of the integrated series.'}]}]",
numpy.polynomial.hermite.Hermite.linspace,method,"[{'Parameters': [{'name': 'n', 'type': 'int, optional', 'description': 'Number of point pairs to return. The default value is 100.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If not None, the specified domain is used instead of that ofthe calling instance. It should be of the form [beg,end].The default is None which case the class domain is used.'}]}, {'Returns': [{'name': 'x, y', 'type': 'ndarray', 'description': 'x is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.'}]}]",
numpy.polynomial.hermite.Hermite.mapparms,method,"[{'Returns': [{'name': 'off, scl', 'type': 'float or complex', 'description': 'The mapping function is defined by off + scl*x.'}]}]",
numpy.polynomial.hermite.Hermite.roots,method,"[{'Returns': [{'name': 'roots', 'type': 'ndarray', 'description': 'Array containing the roots of the series.'}]}]",
numpy.polynomial.hermite.Hermite.trim,method,"[{'Parameters': [{'name': 'tol', 'type': 'non-negative number.', 'description': 'All trailing coefficients less than tol will be removed.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with trimmed coefficients.'}]}]",
numpy.polynomial.hermite.Hermite.truncate,method,"[{'Parameters': [{'name': 'size', 'type': 'positive int', 'description': 'The series is reduced to length size by discarding the highdegree terms. The value of size must be a positive integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with truncated coefficients.'}]}]",
numpy.setbufsize,Set the size of the buffer used in ufuncs.,"[{'Parameters': [{'name': 'size', 'type': 'int', 'description': 'Size of buffer.'}]}, {'Returns': [{'name': 'bufsize', 'type': 'int', 'description': 'Previous size of ufunc buffer in bytes.'}]}]",">>> import numpy as np
>>> with np.errstate():
...     np.setbufsize(4096)
...     print(np.getbufsize())
...
8192
4096
>>> np.getbufsize()
8192"
numpy.getbufsize,Return the size of the buffer used in ufuncs.,"[{'Returns': [{'name': 'getbufsize', 'type': 'int', 'description': 'Size of ufunc buffer in bytes.'}]}]",">>> import numpy as np
>>> np.getbufsize()
8192"
numpy.shares_memory,Determine if two arrays share memory.,"[{'Parameters': [{'name': 'a, b', 'type': 'ndarray', 'description': 'Input arrays'}, {'name': 'max_work', 'type': 'int, optional', 'description': 'Effort to spend on solving the overlap problem (maximum numberof candidate solutions to consider). The following specialvalues are recognized:max_work=-1 (default)The problem is solved exactly. In this case, the function returnsTrue only if there is an element shared between the arrays. Findingthe exact solution may take extremely long in some cases.max_work=0Only the memory bounds of a and b are checked.This is equivalent to using may_share_memory().'}, {'name': 'max_work=-1 (default)', 'type': None, 'description': 'The problem is solved exactly. In this case, the function returnsTrue only if there is an element shared between the arrays. Findingthe exact solution may take extremely long in some cases.'}, {'name': 'max_work=0', 'type': None, 'description': 'Only the memory bounds of a and b are checked.This is equivalent to using may_share_memory().'}]}, {'Returns': [{'name': 'out', 'type': 'bool', 'description': ''}]}, {'Raises': [{'name': 'numpy.exceptions.TooHardError', 'type': None, 'description': 'Exceeded max_work.'}]}]",">>> import numpy as np
>>> x = np.array([1, 2, 3, 4])
>>> np.shares_memory(x, np.array([5, 6, 7]))
False
>>> np.shares_memory(x[::2], x)
True
>>> np.shares_memory(x[::2], x[1::2])
False
>>> from numpy.lib.stride_tricks import as_strided
>>> x = np.zeros([192163377], dtype=np.int8)
>>> x1 = as_strided(
...     x, strides=(36674, 61119, 85569), shape=(1049, 1049, 1049))
>>> x2 = as_strided(
...     x[64023025:], strides=(12223, 12224, 1), shape=(1049, 1049, 1))
>>> np.shares_memory(x1, x2, max_work=1000)
Traceback (most recent call last):
...
numpy.exceptions.TooHardError: Exceeded max_work"
numpy.may_share_memory,Determine if two arrays might share memory,"[{'Parameters': [{'name': 'a, b', 'type': 'ndarray', 'description': 'Input arrays'}, {'name': 'max_work', 'type': 'int, optional', 'description': 'Effort to spend on solving the overlap problem.  Seeshares_memory for details.  Default for may_share_memoryis to do a bounds check.'}]}, {'Returns': [{'name': 'out', 'type': 'bool', 'description': ''}]}]",">>> import numpy as np
>>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
False
>>> x = np.zeros([3, 4])
>>> np.may_share_memory(x[:,0], x[:,1])
True"
numpy.get_include,Return the directory that contains the NumPy *.h header files.,[],">>> np.get_include()
'.../site-packages/numpy/core/include'  # may vary"
numpy.show_config,"Show libraries and system information on which NumPy was built
and is being used","[{'Parameters': [{'name': 'mode', 'type': '{‘stdout’, ‘dicts’}, optional.', 'description': 'Indicates how to display the config information.‘stdout’ prints to console, ‘dicts’ returns a dictionaryof the configuration.'}]}, {'Returns': [{'name': 'out', 'type': '{dict, None}', 'description': 'If mode is ‘dicts’, a dict is returned, else None'}]}]",
numpy.show_runtime,"Print information about various resources in the system
including available intrinsic support and BLAS/LAPACK library
in use",[],
numpy.broadcast_shapes,Broadcast the input shapes into a single shape.,"[{'Parameters': [{'name': '*args', 'type': 'tuples of ints, or ints', 'description': 'The shapes to be broadcast against each other.'}]}, {'Returns': [{'name': 'tuple', 'type': None, 'description': 'Broadcasted shape.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If the shapes are not compatible and cannot be broadcast accordingto NumPy’s broadcasting rules.'}]}]",">>> import numpy as np
>>> np.broadcast_shapes((1, 2), (3, 1), (3, 2))
(3, 2)
>>> np.broadcast_shapes((6, 7), (5, 6, 1), (7,), (5, 1, 7))
(5, 6, 7)"
numpy.info,"Get help information for an array, function, class, or module.","[{'Parameters': [{'name': 'object', 'type': 'object or str, optional', 'description': 'Input object or name to get information about. If object isan ndarray instance, information about the array is printed.If object is a numpy object, its docstring is given. If it isa string, available modules are searched for matching objects.If None, information about info itself is returned.'}, {'name': 'maxwidth', 'type': 'int, optional', 'description': 'Printing width.'}, {'name': 'output', 'type': 'file like object, optional', 'description': 'File like object that the output is written to, default isNone, in which case sys.stdout will be used.The object has to be opened in ‘w’ or ‘a’ mode.'}, {'name': 'toplevel', 'type': 'str, optional', 'description': 'Start search at this level.'}]}]",">>> np.info(np.polyval) 
   polyval(p, x)
     Evaluate the polynomial p at x.
     ...
>>> np.info('fft') 
     *** Found in numpy ***
Core FFT routines
...
     *** Found in numpy.fft ***
 fft(a, n=None, axis=-1)
...
     *** Repeat reference found in numpy.fft.fftpack ***
     *** Total of 3 references found. ***
>>> a = np.array([[1 + 2j, 3, -4], [-5j, 6, 0]], dtype=np.complex64)
>>> np.info(a)
class:  ndarray
shape:  (2, 3)
strides:  (24, 8)
itemsize:  8
aligned:  True
contiguous:  True
fortran:  False
data pointer: 0x562b6e0d2860  # may vary
byteorder:  little
byteswap:  False
type: complex64"
numpy.exceptions.ComplexWarning,The warning raised when casting a complex dtype to a real dtype.,[],
numpy.exceptions.VisibleDeprecationWarning,Visible deprecation warning.,[],
numpy.exceptions.RankWarning,Matrix rank warning.,[],
numpy.exceptions.AxisError,Axis supplied was invalid.,"[{'Parameters': [{'name': 'axis', 'type': 'int or str', 'description': 'The out of bounds axis or a custom exception message.If an axis is provided, then ndim should be specified as well.'}, {'name': 'ndim', 'type': 'int, optional', 'description': 'The number of array dimensions.'}, {'name': 'msg_prefix', 'type': 'str, optional', 'description': 'A prefix for the exception message.'}]}, {'Attributes': [{'name': 'axis', 'type': 'int, optional', 'description': 'The out of bounds axis or None if a custom exceptionmessage was provided. This should be the axis as passed bythe user, before any normalization to resolve negative indices.New in version 1.22.'}, {'name': 'ndim', 'type': 'int, optional', 'description': 'The number of array dimensions or None if a custom exceptionmessage was provided.New in version 1.22.'}]}]",">>> import numpy as np
>>> array_1d = np.arange(10)
>>> np.cumsum(array_1d, axis=1)
Traceback (most recent call last):
  ...
numpy.exceptions.AxisError: axis 1 is out of bounds for array of dimension 1
>>> np.cumsum(array_1d, axis=-2)
Traceback (most recent call last):
  ...
numpy.exceptions.AxisError: axis -2 is out of bounds for array of dimension 1
>>> print(np.exceptions.AxisError(2, 1, msg_prefix='error'))
error: axis 2 is out of bounds for array of dimension 1
>>> print(np.exceptions.AxisError('Custom error message'))
Custom error message"
numpy.exceptions.DTypePromotionError,Multiple DTypes could not be converted to a common one.,[],">>> import numpy as np
>>> np.result_type(np.dtype(""M8[s]""), np.complex128)  
Traceback (most recent call last):
 ...
DTypePromotionError: The DType <class 'numpy.dtype[datetime64]'> could not
be promoted by <class 'numpy.dtype[complex128]'>. This means that no common
DType exists for the given inputs. For example they cannot be stored in a
single array unless the dtype is `object`. The full list of DTypes is:
(<class 'numpy.dtype[datetime64]'>, <class 'numpy.dtype[complex128]'>)
>>> dtype1 = np.dtype([(""field1"", np.float64), (""field2"", np.int64)])
>>> dtype2 = np.dtype([(""field1"", np.float64)])
>>> np.promote_types(dtype1, dtype2)  
Traceback (most recent call last):
 ...
DTypePromotionError: field names `('field1', 'field2')` and `('field1',)`
mismatch."
numpy.exceptions.TooHardError,max_work was exceeded.,[],
numpy.apply_along_axis,Apply a function to 1-D slices along the given axis.,"[{'Parameters': [{'name': 'func1d', 'type': 'function (M,) -> (Nj…)', 'description': 'This function should accept 1-D arrays. It is applied to 1-Dslices of arr along the specified axis.'}, {'name': 'axis', 'type': 'integer', 'description': 'Axis along which arr is sliced.'}, {'name': 'arr', 'type': 'ndarray (Ni…, M, Nk…)', 'description': 'Input array.'}, {'name': 'args', 'type': 'any', 'description': 'Additional arguments to func1d.'}, {'name': 'kwargs', 'type': 'any', 'description': 'Additional named arguments to func1d.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray  (Ni…, Nj…, Nk…)', 'description': 'The output array. The shape of out is identical to the shape ofarr, except along the axis dimension. This axis is removed, andreplaced with new dimensions equal to the shape of the return valueof func1d. So if func1d returns a scalar out will have onefewer dimensions than arr.'}]}]",">>> import numpy as np
>>> def my_func(a):
...     """"""Average first and last element of a 1-D array""""""
...     return (a[0] + a[-1]) * 0.5
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(my_func, 0, b)
array([4., 5., 6.])
>>> np.apply_along_axis(my_func, 1, b)
array([2.,  5.,  8.])
>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
>>> np.apply_along_axis(sorted, 1, b)
array([[1, 7, 8],
       [3, 4, 9],
       [2, 5, 6]])
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(np.diag, -1, b)
array([[[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]],
       [[4, 0, 0],
        [0, 5, 0],
        [0, 0, 6]],
       [[7, 0, 0],
        [0, 8, 0],
        [0, 0, 9]]])"
numpy.apply_over_axes,Apply a function repeatedly over multiple axes.,"[{'Parameters': [{'name': 'func', 'type': 'function', 'description': 'This function must take two arguments, func(a, axis).'}, {'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axes', 'type': 'array_like', 'description': 'Axes over which func is applied; the elements must be integers.'}]}, {'Returns': [{'name': 'apply_over_axis', 'type': 'ndarray', 'description': 'The output array.  The number of dimensions is the same as a,but the shape can be different.  This depends on whether funcchanges the shape of its output with respect to its input.'}]}]",">>> import numpy as np
>>> a = np.arange(24).reshape(2,3,4)
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])
>>> np.apply_over_axes(np.sum, a, [0,2])
array([[[ 60],
        [ 92],
        [124]]])
>>> np.sum(a, axis=(0,2), keepdims=True)
array([[[ 60],
        [ 92],
        [124]]])"
numpy.vectorize,"Returns an object that acts like pyfunc, but takes arrays as input.","[{'Parameters': [{'name': 'pyfunc', 'type': 'callable, optional', 'description': 'A python function or method.Can be omitted to produce a decorator with keyword arguments.'}, {'name': 'otypes', 'type': 'str or list of dtypes, optional', 'description': 'The output data type. It must be specified as either a string oftypecode characters or a list of data type specifiers. There shouldbe one data type specifier for each output.'}, {'name': 'doc', 'type': 'str, optional', 'description': 'The docstring for the function. If None, the docstring will be thepyfunc.__doc__.'}, {'name': 'excluded', 'type': 'set, optional', 'description': 'Set of strings or integers representing the positional or keywordarguments for which the function will not be vectorized. These will bepassed directly to pyfunc unmodified.'}, {'name': 'cache', 'type': 'bool, optional', 'description': 'If True, then cache the first function call that determines the numberof outputs if otypes is not provided.'}, {'name': 'signature', 'type': 'string, optional', 'description': 'Generalized universal function signature, e.g., (m,n),(n)->(m) forvectorized matrix-vector multiplication. If provided, pyfunc willbe called with (and expected to return) arrays with shapes given by thesize of corresponding core dimensions. By default, pyfunc isassumed to take scalars as input and output.'}]}, {'Returns': [{'name': 'out', 'type': 'callable', 'description': 'A vectorized function if pyfunc was provided,a decorator otherwise.'}]}]",">>> import numpy as np
>>> def myfunc(a, b):
...     ""Return a-b if a>b, otherwise return a+b""
...     if a > b:
...         return a - b
...     else:
...         return a + b
>>> vfunc = np.vectorize(myfunc)
>>> vfunc([1, 2, 3, 4], 2)
array([3, 4, 1, 2])
>>> vfunc.__doc__
'Return a-b if a>b, otherwise return a+b'
>>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')
>>> vfunc.__doc__
'Vectorized `myfunc`'
>>> out = vfunc([1, 2, 3, 4], 2)
>>> type(out[0])
<class 'numpy.int64'>
>>> vfunc = np.vectorize(myfunc, otypes=[float])
>>> out = vfunc([1, 2, 3, 4], 2)
>>> type(out[0])
<class 'numpy.float64'>
>>> def mypolyval(p, x):
...     _p = list(p)
...     res = _p.pop(0)
...     while _p:
...         res = res*x + _p.pop(0)
...     return res
>>> vpolyval = np.vectorize(mypolyval, excluded={0, 'p'})
>>> vpolyval([1, 2, 3], x=[0, 1])
array([3, 6])
>>> vpolyval(p=[1, 2, 3], x=[0, 1])
array([3, 6])
>>> import scipy.stats
>>> pearsonr = np.vectorize(scipy.stats.pearsonr,
...                 signature='(n),(n)->(),()')
>>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])
(array([ 1., -1.]), array([ 0.,  0.]))
>>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')
>>> convolve(np.eye(4), [1, 2, 1])
array([[1., 2., 1., 0., 0., 0.],
       [0., 1., 2., 1., 0., 0.],
       [0., 0., 1., 2., 1., 0.],
       [0., 0., 0., 1., 2., 1.]])
>>> @np.vectorize
... def identity(x):
...     return x
...
>>> identity([0, 1, 2])
array([0, 1, 2])
>>> @np.vectorize(otypes=[float])
... def as_float(x):
...     return x
...
>>> as_float([0, 1, 2])
array([0., 1., 2.])"
numpy.frompyfunc,Takes an arbitrary Python function and returns a NumPy ufunc.,"[{'Parameters': [{'name': 'func', 'type': 'Python function object', 'description': 'An arbitrary Python function.'}, {'name': 'nin', 'type': 'int', 'description': 'The number of input arguments.'}, {'name': 'nout', 'type': 'int', 'description': 'The number of objects returned by func.'}, {'name': 'identity', 'type': 'object, optional', 'description': 'The value to use for the identity attribute of the resultingobject. If specified, this is equivalent to setting the underlyingC identity field to PyUFunc_IdentityValue.If omitted, the identity is set to PyUFunc_None. Note that this is_not_ equivalent to setting the identity to None, which implies theoperation is reorderable.'}]}, {'Returns': [{'name': 'out', 'type': 'ufunc', 'description': 'Returns a NumPy universal function (ufunc) object.'}]}]",">>> import numpy as np
>>> oct_array = np.frompyfunc(oct, 1, 1)
>>> oct_array(np.array((10, 30, 100)))
array(['0o12', '0o36', '0o144'], dtype=object)
>>> np.array((oct(10), oct(30), oct(100))) # for comparison
array(['0o12', '0o36', '0o144'], dtype='<U5')"
numpy.piecewise,Evaluate a piecewise-defined function.,"[{'Parameters': [{'name': 'x', 'type': 'ndarray or scalar', 'description': 'The input domain.'}, {'name': 'condlist', 'type': 'list of bool arrays or bool scalars', 'description': 'Each boolean array corresponds to a function in funclist.  Wherevercondlist[i] is True, funclist[i](x) is used as the output value.Each boolean array in condlist selects a piece of x,and should therefore be of the same shape as x.The length of condlist must correspond to that of funclist.If one extra function is given, i.e. iflen(funclist) == len(condlist) + 1, then that extra functionis the default value, used wherever all conditions are false.'}, {'name': 'funclist', 'type': 'list of callables, f(x,*args,**kw), or scalars', 'description': 'Each function is evaluated over x wherever its correspondingcondition is True.  It should take a 1d array as input and give an 1darray or a scalar value as output.  If, instead of a callable,a scalar is provided then a constant function (lambda x: scalar) isassumed.'}, {'name': 'args', 'type': 'tuple, optional', 'description': ""Any further arguments given to piecewise are passed to the functionsupon execution, i.e., if called piecewise(..., ..., 1, 'a'), theneach function is called as f(x, 1, 'a').""}, {'name': 'kw', 'type': 'dict, optional', 'description': 'Keyword arguments used in calling piecewise are passed to thefunctions upon execution, i.e., if calledpiecewise(..., ..., alpha=1), then each function is called asf(x, alpha=1).'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'The output is the same shape and type as x and is found bycalling the functions in funclist on the appropriate portions of x,as defined by the boolean arrays in condlist.  Portions not coveredby any condition have a default value of 0.'}]}]",">>> import numpy as np
>>> x = np.linspace(-2.5, 2.5, 6)
>>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])
array([-1., -1., -1.,  1.,  1.,  1.])
>>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])
array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])
>>> y = -2
>>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])
array(2)"
numpy.sin,"Trigonometric sine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Angle, in radians (\\(2 \\pi\\) rad equals 360 degrees).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'array_like', 'description': 'The sine of each element of x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.sin(np.pi/2.)
1.0
>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])
>>> import matplotlib.pylab as plt
>>> x = np.linspace(-np.pi, np.pi, 201)
>>> plt.plot(x, np.sin(x))
>>> plt.xlabel('Angle [rad]')
>>> plt.ylabel('sin(x)')
>>> plt.axis('tight')
>>> plt.show()"
numpy.cos,Cosine element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array in radians.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding cosine values.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])
>>>
>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
numpy.tan,Compute tangent element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding tangent values.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> from math import pi
>>> np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])
>>>
>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.cos([0.1], out1)
>>> out2 is out1
True
>>>
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
numpy.arcsin,"Inverse sine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'y-coordinate on the unit circle.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'angle', 'type': 'ndarray', 'description': 'The inverse sine of each element in x, in radians and in theclosed interval [-pi/2, pi/2].This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arcsin(1)     # pi/2
1.5707963267948966
>>> np.arcsin(-1)    # -pi/2
-1.5707963267948966
>>> np.arcsin(0)
0.0"
numpy.asin,"Inverse sine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'y-coordinate on the unit circle.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'angle', 'type': 'ndarray', 'description': 'The inverse sine of each element in x, in radians and in theclosed interval [-pi/2, pi/2].This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arcsin(1)     # pi/2
1.5707963267948966
>>> np.arcsin(-1)    # -pi/2
-1.5707963267948966
>>> np.arcsin(0)
0.0"
numpy.arccos,"Trigonometric inverse cosine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'x-coordinate on the unit circle.For real arguments, the domain is [-1, 1].'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'angle', 'type': 'ndarray', 'description': 'The angle of the ray intersecting the unit circle at the givenx-coordinate in radians [0, pi].This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arccos([1, -1])
array([ 0.        ,  3.14159265])
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-1, 1, num=100)
>>> plt.plot(x, np.arccos(x))
>>> plt.axis('tight')
>>> plt.show()"
numpy.acos,"Trigonometric inverse cosine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'x-coordinate on the unit circle.For real arguments, the domain is [-1, 1].'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'angle', 'type': 'ndarray', 'description': 'The angle of the ray intersecting the unit circle at the givenx-coordinate in radians [0, pi].This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arccos([1, -1])
array([ 0.        ,  3.14159265])
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-1, 1, num=100)
>>> plt.plot(x, np.arccos(x))
>>> plt.axis('tight')
>>> plt.show()"
numpy.arctan,"Trigonometric inverse tangent, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Out has the same shape as x.  Its real part is in[-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2).This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arctan([0, 1])
array([ 0.        ,  0.78539816])
>>> np.pi/4
0.78539816339744828
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-10, 10)
>>> plt.plot(x, np.arctan(x))
>>> plt.axis('tight')
>>> plt.show()"
numpy.atan,"Trigonometric inverse tangent, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': ''}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Out has the same shape as x.  Its real part is in[-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2).This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arctan([0, 1])
array([ 0.        ,  0.78539816])
>>> np.pi/4
0.78539816339744828
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-10, 10)
>>> plt.plot(x, np.arctan(x))
>>> plt.axis('tight')
>>> plt.show()"
numpy.hypot,"Given the “legs” of a right triangle, return its hypotenuse.","[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Leg of the triangle(s).If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'z', 'type': 'ndarray', 'description': 'The hypotenuse of the triangle(s).This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
>>> np.hypot(3*np.ones((3, 3)), [4])
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])"
numpy.arctan2,Element-wise arc tangent of x1/x2 choosing the quadrant correctly.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like, real-valued', 'description': 'y-coordinates.'}, {'name': 'x2', 'type': 'array_like, real-valued', 'description': 'x-coordinates.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'angle', 'type': 'ndarray', 'description': 'Array of angles in radians, in the range [-pi, pi].This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> x = np.array([-1, +1, +1, -1])
>>> y = np.array([-1, -1, +1, +1])
>>> np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])
>>> np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([0.        , 3.14159265, 0.78539816])"
numpy.atan2,Element-wise arc tangent of x1/x2 choosing the quadrant correctly.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like, real-valued', 'description': 'y-coordinates.'}, {'name': 'x2', 'type': 'array_like, real-valued', 'description': 'x-coordinates.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'angle', 'type': 'ndarray', 'description': 'Array of angles in radians, in the range [-pi, pi].This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> x = np.array([-1, +1, +1, -1])
>>> y = np.array([-1, -1, +1, +1])
>>> np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])
>>> np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([0.        , 3.14159265, 0.78539816])"
numpy.degrees,Convert angles from radians to degrees.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array in radians.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray of floats', 'description': 'The corresponding degree values; if out was supplied this is areference to it.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> rad = np.arange(12.)*np.pi/6
>>> np.degrees(rad)
array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,
        270.,  300.,  330.])
>>> out = np.zeros((rad.shape))
>>> r = np.degrees(rad, out)
>>> np.all(r == out)
True"
numpy.radians,Convert angles from degrees to radians.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array in degrees.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding radian values.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> deg = np.arange(12.) * 30.
>>> np.radians(deg)
array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,
        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,
        5.23598776,  5.75958653])
>>> out = np.zeros((deg.shape))
>>> ret = np.radians(deg, out)
>>> ret is out
True"
numpy.unwrap,Unwrap by taking the complement of large deltas with respect to the period.,"[{'Parameters': [{'name': 'p', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'discont', 'type': 'float, optional', 'description': 'Maximum discontinuity between values, default is period/2.Values below period/2 are treated as if they were period/2.To have an effect different from the default, discont should belarger than period/2.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which unwrap will operate, default is the last axis.'}, {'name': 'period', 'type': 'float, optional', 'description': 'Size of the range over which the input wraps. By default, it is2 pi.New in version 1.21.0.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Output array.'}]}]",">>> import numpy as np
>>> phase = np.linspace(0, np.pi, num=5)
>>> phase[3:] += np.pi
>>> phase
array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary
>>> np.unwrap(phase)
array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary
>>> np.unwrap([0, 1, 2, -1, 0], period=4)
array([0, 1, 2, 3, 4])
>>> np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)
array([2, 3, 4, 5, 6, 7, 8, 9])
>>> phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180
>>> np.unwrap(phase_deg, period=360)
array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,
        180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,
        540.])"
numpy.deg2rad,Convert angles from degrees to radians.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Angles in degrees.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding angle in radians.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.deg2rad(180)
3.1415926535897931"
numpy.rad2deg,Convert angles from radians to degrees.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Angle in radians.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding angle in degrees.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.rad2deg(np.pi/2)
90.0"
numpy.sinh,"Hyperbolic sine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding hyperbolic sine values.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.sinh(0)
0.0
>>> np.sinh(np.pi*1j/2)
1j
>>> np.sinh(np.pi*1j) # (exact value is 0)
1.2246063538223773e-016j
>>> # Discrepancy due to vagaries of floating point arithmetic.
>>> # Example of providing the optional output parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.sinh([0.1], out1)
>>> out2 is out1
True
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
numpy.cosh,"Hyperbolic cosine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array of same shape as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.cosh(0)
1.0
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 1000)
>>> plt.plot(x, np.cosh(x))
>>> plt.show()"
numpy.tanh,Compute hyperbolic tangent element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding hyperbolic tangent values.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.tanh((0, np.pi*1j, np.pi*1j/2))
array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])
>>> # Example of providing the optional output parameter illustrating
>>> # that what is returned is a reference to said parameter
>>> out1 = np.array([0], dtype='d')
>>> out2 = np.tanh([0.1], out1)
>>> out2 is out1
True
>>> # Example of ValueError due to provision of shape mis-matched `out`
>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
  File ""<stdin>"", line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)"
numpy.arcsinh,Inverse hyperbolic sine element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Array of the same shape as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])"
numpy.asinh,Inverse hyperbolic sine element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Array of the same shape as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])"
numpy.arccosh,"Inverse hyperbolic cosine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'arccosh', 'type': 'ndarray', 'description': 'Array of the same shape as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
>>> np.arccosh(1)
0.0"
numpy.acosh,"Inverse hyperbolic cosine, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'arccosh', 'type': 'ndarray', 'description': 'Array of the same shape as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
>>> np.arccosh(1)
0.0"
numpy.arctanh,Inverse hyperbolic tangent element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Array of the same shape as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arctanh([0, -0.5])
array([ 0.        , -0.54930614])"
numpy.atanh,Inverse hyperbolic tangent element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Array of the same shape as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.arctanh([0, -0.5])
array([ 0.        , -0.54930614])"
numpy.round,Evenly round to the given number of decimals.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'decimals', 'type': 'int, optional', 'description': 'Number of decimal places to round to (default: 0).  Ifdecimals is negative, it specifies the number of positions tothe left of the decimal point.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It must havethe same shape as the expected output, but the type of the outputvalues will be cast if necessary. See Output type determinationfor more details.'}]}, {'Returns': [{'name': 'rounded_array', 'type': 'ndarray', 'description': 'An array of the same type as a, containing the rounded values.Unless out was specified, a new array is created.  A reference tothe result is returned.The real and imaginary parts of complex numbers are roundedseparately.  The result of rounding a float is a float.'}]}]",">>> np.round(56294995342131.5, 3)
56294995342131.51
>>> np.format_float_positional(56294995342131.5, precision=3)
'56294995342131.5'
>>> round(56294995342131.5, 3)
56294995342131.5
>>> np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
(16.06, 16.05)
>>> import numpy as np
>>> np.round([0.37, 1.64])
array([0., 2.])
>>> np.round([0.37, 1.64], decimals=1)
array([0.4, 1.6])
>>> np.round([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
array([0., 2., 2., 4., 4.])
>>> np.round([1,2,3,11], decimals=1) # ndarray of ints is returned
array([ 1,  2,  3, 11])
>>> np.round([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])"
numpy.around,Round an array to the given number of decimals.,[],
numpy.rint,Round elements of the array to the nearest integer.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array is same shape and type as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.rint(a)
array([-2., -2., -0.,  0.,  2.,  2.,  2.])"
numpy.fix,Round to nearest integer towards zero.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'An array to be rounded'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the input broadcasts to. If not provided or None, afreshly-allocated array is returned.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray of floats', 'description': 'An array with the same dimensions and data-type as the input.If second argument is not supplied then a new array is returnedwith the rounded values.If a second argument is supplied the result is stored there.The return value out is then a reference to that array.'}]}]",">>> import numpy as np
>>> np.fix(3.14)
3.0
>>> np.fix(3)
3
>>> np.fix([2.1, 2.9, -2.1, -2.9])
array([ 2.,  2., -2., -2.])"
numpy.floor,"Return the floor of the input, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The floor of each element in x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])"
numpy.ceil,"Return the ceiling of the input, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The ceiling of each element in x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])"
numpy.trunc,"Return the truncated value of the input, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The truncated value of each element in x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
>>> np.trunc(a)
array([-1., -1., -0.,  0.,  1.,  1.,  2.])"
numpy.prod,Return the product of array elements over a given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which a product is performed.  The default,axis=None, will calculate the product of all the elements in theinput array. If axis is negative it counts from the last to thefirst axis.If axis is a tuple of ints, a product is performed on all of theaxes specified in the tuple instead of a single axis or all theaxes as before.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'The type of the returned array, as well as of the accumulator inwhich the elements are multiplied.  The dtype of a is used bydefault unless a has an integer dtype of less precision than thedefault platform integer.  In that case, if a is signed then theplatform integer is used while if a is unsigned then an unsignedinteger of the same precision as the platform integer is used.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It must havethe same shape as the expected output, but the type of the outputvalues will be cast if necessary.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are left in theresult as dimensions with size one. With this option, the resultwill broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the prod method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'The starting value for this product. See reducefor details.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the product. See reducefor details.'}]}, {'Returns': [{'name': 'product_along_axis', 'type': 'ndarray, see dtype parameter above.', 'description': 'An array shaped as a but with the specified axis removed.Returns a reference to out if specified.'}]}]",">>> x = np.array([536870910, 536870910, 536870910, 536870910])
>>> np.prod(x)
16 # may vary
>>> np.prod([])
1.0
>>> import numpy as np
>>> np.prod([1.,2.])
2.0
>>> a = np.array([[1., 2.], [3., 4.]])
>>> np.prod(a)
24.0
>>> np.prod(a, axis=1)
array([  2.,  12.])
>>> np.prod(a, axis=0)
array([3., 8.])
>>> np.prod([1., np.nan, 3.], where=[True, False, True])
3.0
>>> x = np.array([1, 2, 3], dtype=np.uint8)
>>> np.prod(x).dtype == np.uint
True
>>> x = np.array([1, 2, 3], dtype=np.int8)
>>> np.prod(x).dtype == int
True
>>> np.prod([1, 2], initial=5)
10"
numpy.sum,Sum of array elements over a given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Elements to sum.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which a sum is performed.  The default,axis=None, will sum all of the elements of the input array.  Ifaxis is negative it counts from the last to the first axis. Ifaxis is a tuple of ints, a sum is performed on all of the axesspecified in the tuple instead of a single axis or all the axes asbefore.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'The type of the returned array and of the accumulator in which theelements are summed.  The dtype of a is used by default unless ahas an integer dtype of less precision than the default platforminteger.  In that case, if a is signed then the platform integeris used while if a is unsigned then an unsigned integer of thesame precision as the platform integer is used.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It must havethe same shape as the expected output, but the type of the outputvalues will be cast if necessary.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the sum method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'Starting value for the sum. See reduce for details.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the sum. See reduce for details.'}]}, {'Returns': [{'name': 'sum_along_axis', 'type': 'ndarray', 'description': 'An array with the same shape as a, with the specifiedaxis removed.   If a is a 0-d array, or if axis is None, a scalaris returned.  If an output array is specified, a reference toout is returned.'}]}]",">>> np.sum([])
0.0
>>> import numpy as np
>>> np.sum([0.5, 1.5])
2.0
>>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
np.int32(1)
>>> np.sum([[0, 1], [0, 5]])
6
>>> np.sum([[0, 1], [0, 5]], axis=0)
array([0, 6])
>>> np.sum([[0, 1], [0, 5]], axis=1)
array([1, 5])
>>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)
array([1., 5.])
>>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
np.int8(-128)
>>> np.sum([10], initial=5)
15"
numpy.nanprod,"Return the product of array elements over a given axis treating Not a
Numbers (NaNs) as ones.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose product is desired. If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the product is computed. The default is to computethe product of the flattened array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The type of the returned array and of the accumulator in which theelements are summed.  By default, the dtype of a is used.  Anexception is when a has an integer type with less precision thanthe platform (u)intp. In that case, the default will be either(u)int32 or (u)int64 depending on whether the platform is 32 or 64bits. For inexact inputs, dtype must be inexact.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  The defaultis None. If provided, it must have the same shape as theexpected output, but the type will be cast if necessary. SeeOutput type determination for more details. The casting of NaN to integercan yield unexpected results.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If True, the axes which are reduced are left in the result asdimensions with size one. With this option, the result willbroadcast correctly against the original arr.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'The starting value for this product. See reducefor details.New in version 1.22.0.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the product. See reducefor details.New in version 1.22.0.'}]}, {'Returns': [{'name': 'nanprod', 'type': 'ndarray', 'description': 'A new array holding the result is returned unless out isspecified, in which case it is returned.'}]}]",">>> import numpy as np
>>> np.nanprod(1)
1
>>> np.nanprod([1])
1
>>> np.nanprod([1, np.nan])
1.0
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nanprod(a)
6.0
>>> np.nanprod(a, axis=0)
array([3., 2.])"
numpy.nansum,"Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose sum is desired. If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the sum is computed. The default is to compute thesum of the flattened array.'}, {'name': 'dtype', 'type': 'data-type, optional', 'description': 'The type of the returned array and of the accumulator in which theelements are summed.  By default, the dtype of a is used.  Anexception is when a has an integer type with less precision thanthe platform (u)intp. In that case, the default will be either(u)int32 or (u)int64 depending on whether the platform is 32 or 64bits. For inexact inputs, dtype must be inexact.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  The defaultis None. If provided, it must have the same shape as theexpected output, but the type will be cast if necessary.  SeeOutput type determination for more details. The casting of NaN to integercan yield unexpected results.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.If the value is anything but the default, thenkeepdims will be passed through to the mean or sum methodsof sub-classes of ndarray.  If the sub-classes methodsdoes not implement keepdims any exceptions will be raised.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'Starting value for the sum. See reduce for details.New in version 1.22.0.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to include in the sum. See reduce for details.New in version 1.22.0.'}]}, {'Returns': [{'name': 'nansum', 'type': 'ndarray.', 'description': 'A new array holding the result is returned unless out isspecified, in which it is returned. The result has the samesize as a, and the same shape as a if axis is not Noneor a is a 1-d array.'}]}]",">>> import numpy as np
>>> np.nansum(1)
1
>>> np.nansum([1])
1
>>> np.nansum([1, np.nan])
1.0
>>> a = np.array([[1, 1], [1, np.nan]])
>>> np.nansum(a)
3.0
>>> np.nansum(a, axis=0)
array([2.,  1.])
>>> np.nansum([1, np.nan, np.inf])
inf
>>> np.nansum([1, np.nan, -np.inf])
-inf
>>> from numpy.testing import suppress_warnings
>>> with np.errstate(invalid=""ignore""):
...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
np.float64(nan)"
numpy.cumulative_sum,Return the cumulative sum of the elements along a given axis.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the cumulative sum is computed. The default(None) is only allowed for one-dimensional arrays. For arrayswith more than one dimension axis is required.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type of the returned array and of the accumulator in which theelements are summed.  If dtype is not specified, it defaultsto the dtype of x, unless x has an integer dtype witha precision less than that of the default platform integer.In that case, the default platform integer is used.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type will be cast if necessary. See Output type determinationfor more details.'}, {'name': 'include_initial', 'type': 'bool, optional', 'description': 'Boolean indicating whether to include the initial value (zeros) asthe first value in the output. With include_initial=Truethe shape of the output is different than the shape of the input.Default: False.'}]}, {'Returns': [{'name': 'cumulative_sum_along_axis', 'type': 'ndarray', 'description': 'A new array holding the result is returned unless out isspecified, in which case a reference to out is returned. Theresult has the same shape as x if include_initial=False.'}]}]",">>> a = np.array([1, 2, 3, 4, 5, 6])
>>> a
array([1, 2, 3, 4, 5, 6])
>>> np.cumulative_sum(a)
array([ 1,  3,  6, 10, 15, 21])
>>> np.cumulative_sum(a, dtype=float)  # specifies type of output value(s)
array([  1.,   3.,   6.,  10.,  15.,  21.])
>>> b = np.array([[1, 2, 3], [4, 5, 6]])
>>> np.cumulative_sum(b,axis=0)  # sum over rows for each of the 3 columns
array([[1, 2, 3],
       [5, 7, 9]])
>>> np.cumulative_sum(b,axis=1)  # sum over columns for each of the 2 rows
array([[ 1,  3,  6],
       [ 4,  9, 15]])
>>> c = np.array([1, 2e-9, 3e-9] * 1000000)
>>> np.cumulative_sum(c)[-1]
1000000.0050045159
>>> c.sum()
1000000.0050000029"
numpy.cumulative_prod,Return the cumulative product of elements along a given axis.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the cumulative product is computed. The default(None) is only allowed for one-dimensional arrays. For arrayswith more than one dimension axis is required.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type of the returned array, as well as of the accumulator in whichthe elements are multiplied.  If dtype is not specified, itdefaults to the dtype of x, unless x has an integer dtypewith a precision less than that of the default platform integer.In that case, the default platform integer is used instead.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type of the resulting values will be cast if necessary.See Output type determination for more details.'}, {'name': 'include_initial', 'type': 'bool, optional', 'description': 'Boolean indicating whether to include the initial value (ones) asthe first value in the output. With include_initial=Truethe shape of the output is different than the shape of the input.Default: False.'}]}, {'Returns': [{'name': 'cumulative_prod_along_axis', 'type': 'ndarray', 'description': 'A new array holding the result is returned unless out isspecified, in which case a reference to out is returned. Theresult has the same shape as x if include_initial=False.'}]}]",">>> a = np.array([1, 2, 3])
>>> np.cumulative_prod(a)  # intermediate results 1, 1*2
...                        # total product 1*2*3 = 6
array([1, 2, 6])
>>> a = np.array([1, 2, 3, 4, 5, 6])
>>> np.cumulative_prod(a, dtype=float) # specify type of output
array([   1.,    2.,    6.,   24.,  120.,  720.])
>>> b = np.array([[1, 2, 3], [4, 5, 6]])
>>> np.cumulative_prod(b, axis=0)
array([[ 1,  2,  3],
       [ 4, 10, 18]])
>>> np.cumulative_prod(b, axis=1)
array([[  1,   2,   6],
       [  4,  20, 120]])"
numpy.cumprod,Return the cumulative product of elements along a given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the cumulative product is computed.  By defaultthe input is flattened.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type of the returned array, as well as of the accumulator in whichthe elements are multiplied.  If dtype is not specified, itdefaults to the dtype of a, unless a has an integer dtype witha precision less than that of the default platform integer.  Inthat case, the default platform integer is used instead.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type of the resulting values will be cast if necessary.'}]}, {'Returns': [{'name': 'cumprod', 'type': 'ndarray', 'description': 'A new array holding the result is returned unless out isspecified, in which case a reference to out is returned.'}]}]",">>> import numpy as np
>>> a = np.array([1,2,3])
>>> np.cumprod(a) # intermediate results 1, 1*2
...               # total product 1*2*3 = 6
array([1, 2, 6])
>>> a = np.array([[1, 2, 3], [4, 5, 6]])
>>> np.cumprod(a, dtype=float) # specify type of output
array([   1.,    2.,    6.,   24.,  120.,  720.])
>>> np.cumprod(a, axis=0)
array([[ 1,  2,  3],
       [ 4, 10, 18]])
>>> np.cumprod(a,axis=1)
array([[  1,   2,   6],
       [  4,  20, 120]])"
numpy.cumsum,Return the cumulative sum of the elements along a given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the cumulative sum is computed. The default(None) is to compute the cumsum over the flattened array.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type of the returned array and of the accumulator in which theelements are summed.  If dtype is not specified, it defaultsto the dtype of a, unless a has an integer dtype with aprecision less than that of the default platform integer.  Inthat case, the default platform integer is used.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type will be cast if necessary. See Output type determinationfor more details.'}]}, {'Returns': [{'name': 'cumsum_along_axis', 'type': 'ndarray.', 'description': 'A new array holding the result is returned unless out isspecified, in which case a reference to out is returned. Theresult has the same size as a, and the same shape as a ifaxis is not None or a is a 1-d array.'}]}]",">>> import numpy as np
>>> a = np.array([[1,2,3], [4,5,6]])
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.cumsum(a)
array([ 1,  3,  6, 10, 15, 21])
>>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
array([  1.,   3.,   6.,  10.,  15.,  21.])
>>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
array([[1, 2, 3],
       [5, 7, 9]])
>>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
array([[ 1,  3,  6],
       [ 4,  9, 15]])
>>> b = np.array([1, 2e-9, 3e-9] * 1000000)
>>> b.cumsum()[-1]
1000000.0050045159
>>> b.sum()
1000000.0050000029"
numpy.nancumprod,"Return the cumulative product of array elements over a given axis treating Not a
Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the cumulative product is computed.  By defaultthe input is flattened.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type of the returned array, as well as of the accumulator in whichthe elements are multiplied.  If dtype is not specified, itdefaults to the dtype of a, unless a has an integer dtype witha precision less than that of the default platform integer.  Inthat case, the default platform integer is used instead.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type of the resulting values will be cast if necessary.'}]}, {'Returns': [{'name': 'nancumprod', 'type': 'ndarray', 'description': 'A new array holding the result is returned unless out isspecified, in which case it is returned.'}]}]",">>> import numpy as np
>>> np.nancumprod(1)
array([1])
>>> np.nancumprod([1])
array([1])
>>> np.nancumprod([1, np.nan])
array([1.,  1.])
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nancumprod(a)
array([1.,  2.,  6.,  6.])
>>> np.nancumprod(a, axis=0)
array([[1.,  2.],
       [3.,  2.]])
>>> np.nancumprod(a, axis=1)
array([[1.,  2.],
       [3.,  3.]])"
numpy.nancumsum,"Return the cumulative sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which the cumulative sum is computed. The default(None) is to compute the cumsum over the flattened array.'}, {'name': 'dtype', 'type': 'dtype, optional', 'description': 'Type of the returned array and of the accumulator in which theelements are summed.  If dtype is not specified, it defaultsto the dtype of a, unless a has an integer dtype with aprecision less than that of the default platform integer.  Inthat case, the default platform integer is used.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result. It musthave the same shape and buffer length as the expected outputbut the type will be cast if necessary. See Output type determination formore details.'}]}, {'Returns': [{'name': 'nancumsum', 'type': 'ndarray.', 'description': 'A new array holding the result is returned unless out isspecified, in which it is returned. The result has the samesize as a, and the same shape as a if axis is not Noneor a is a 1-d array.'}]}]",">>> import numpy as np
>>> np.nancumsum(1)
array([1])
>>> np.nancumsum([1])
array([1])
>>> np.nancumsum([1, np.nan])
array([1.,  1.])
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nancumsum(a)
array([1.,  3.,  6.,  6.])
>>> np.nancumsum(a, axis=0)
array([[1.,  2.],
       [4.,  2.]])
>>> np.nancumsum(a, axis=1)
array([[1.,  3.],
       [3.,  3.]])"
numpy.diff,Calculate the n-th discrete difference along the given axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array'}, {'name': 'n', 'type': 'int, optional', 'description': 'The number of times values are differenced. If zero, the inputis returned as-is.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which the difference is taken, default is thelast axis.'}, {'name': 'prepend, append', 'type': 'array_like, optional', 'description': 'Values to prepend or append to a along axis prior toperforming the difference.  Scalar values are expanded toarrays with length 1 in the direction of axis and the shapeof the input array in along all other axes.  Otherwise thedimension and shape must match a except along axis.'}]}, {'Returns': [{'name': 'diff', 'type': 'ndarray', 'description': 'The n-th differences. The shape of the output is the same as aexcept along axis where the dimension is smaller by n. Thetype of the output is the same as the type of the differencebetween any two elements of a. This is the same as the type ofa in most cases. A notable exception is datetime64, whichresults in a timedelta64 output array.'}]}]",">>> u8_arr = np.array([1, 0], dtype=np.uint8)
>>> np.diff(u8_arr)
array([255], dtype=uint8)
>>> u8_arr[1,...] - u8_arr[0,...]
np.uint8(255)
>>> i16_arr = u8_arr.astype(np.int16)
>>> np.diff(i16_arr)
array([-1], dtype=int16)
>>> import numpy as np
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.diff(x)
array([ 1,  2,  3, -7])
>>> np.diff(x, n=2)
array([  1,   1, -10])
>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
>>> np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
>>> np.diff(x, axis=0)
array([[-1,  2,  0, -2]])
>>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
>>> np.diff(x)
array([1, 1], dtype='timedelta64[D]')"
numpy.ediff1d,The differences between consecutive elements of an array.,"[{'Parameters': [{'name': 'ary', 'type': 'array_like', 'description': 'If necessary, will be flattened before the differences are taken.'}, {'name': 'to_end', 'type': 'array_like, optional', 'description': 'Number(s) to append at the end of the returned differences.'}, {'name': 'to_begin', 'type': 'array_like, optional', 'description': 'Number(s) to prepend at the beginning of the returned differences.'}]}, {'Returns': [{'name': 'ediff1d', 'type': 'ndarray', 'description': 'The differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].'}]}]",">>> import numpy as np
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.ediff1d(x)
array([ 1,  2,  3, -7])
>>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
array([-99,   1,   2, ...,  -7,  88,  99])
>>> y = [[1, 2, 4], [1, 6, 24]]
>>> np.ediff1d(y)
array([ 1,  2, -3,  5, 18])"
numpy.gradient,Return the gradient of an N-dimensional array.,"[{'Parameters': [{'name': 'f', 'type': 'array_like', 'description': 'An N-dimensional array containing samples of a scalar function.'}, {'name': 'varargs', 'type': 'list of scalar or array, optional', 'description': 'Spacing between f values. Default unitary spacing for all dimensions.Spacing can be specified using:single scalar to specify a sample distance for all dimensions.N scalars to specify a constant sample distance for each dimension.i.e. dx, dy, dz, …N arrays to specify the coordinates of the values along eachdimension of F. The length of the array must match the size ofthe corresponding dimensionAny combination of N scalars/arrays with the meaning of 2. and 3.If axis is given, the number of varargs must equal the number of axes.Default: 1. (see Examples below).'}, {'name': 'edge_order', 'type': '{1, 2}, optional', 'description': 'Gradient is calculated using N-th order accurate differencesat the boundaries. Default: 1.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Gradient is calculated only along the given axis or axesThe default (axis = None) is to calculate the gradient for all the axesof the input array. axis may be negative, in which case it counts fromthe last to the first axis.'}]}, {'Returns': [{'name': 'gradient', 'type': 'ndarray or tuple of ndarray', 'description': 'A tuple of ndarrays (or a single ndarray if there is only onedimension) corresponding to the derivatives of f with respectto each dimension. Each derivative has the same shape as f.'}]}]",">>> import numpy as np
>>> f = np.array([1, 2, 4, 7, 11, 16])
>>> np.gradient(f)
array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])
>>> np.gradient(f, 2)
array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])
>>> x = np.arange(f.size)
>>> np.gradient(f, x)
array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
>>> x = np.array([0., 1., 1.5, 3.5, 4., 6.])
>>> np.gradient(f, x)
array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])
>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]))
(array([[ 2.,  2., -1.],
        [ 2.,  2., -1.]]),
 array([[1. , 2.5, 4. ],
        [1. , 1. , 1. ]]))
>>> dx = 2.
>>> y = [1., 1.5, 3.5]
>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), dx, y)
(array([[ 1. ,  1. , -0.5],
        [ 1. ,  1. , -0.5]]),
 array([[2. , 2. , 2. ],
        [2. , 1.7, 0.5]]))
>>> x = np.array([0, 1, 2, 3, 4])
>>> f = x**2
>>> np.gradient(f, edge_order=1)
array([1.,  2.,  4.,  6.,  7.])
>>> np.gradient(f, edge_order=2)
array([0., 2., 4., 6., 8.])
>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), axis=0)
array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]])
>>> x = np.array([0., 2., 3., 6., 8.])
>>> y = x ** 2
>>> np.gradient(y, x, edge_order=2)
array([ 0.,  4.,  6., 12., 16.])
>>> dx = 2
>>> x = np.array([0., 2., 4., 6., 8.])
>>> y = x ** 2
>>> np.gradient(y, dx, edge_order=2)
array([ 0.,  4.,  8., 12., 16.])
>>> dx = 2
>>> dy = 3
>>> x = np.arange(0, 6, dx)
>>> y = np.arange(0, 9, dy)
>>> xs, ys = np.meshgrid(x, y)
>>> zs = xs + 2 * ys
>>> np.gradient(zs, dy, dx)  # Passing two scalars
(array([[2., 2., 2.],
        [2., 2., 2.],
        [2., 2., 2.]]),
 array([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]]))
>>> np.gradient(zs, y, dx)  # Passing one array and one scalar
(array([[2., 2., 2.],
        [2., 2., 2.],
        [2., 2., 2.]]),
 array([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]]))"
numpy.cross,Return the cross product of two (arrays of) vectors.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Components of the first vector(s).'}, {'name': 'b', 'type': 'array_like', 'description': 'Components of the second vector(s).'}, {'name': 'axisa', 'type': 'int, optional', 'description': 'Axis of a that defines the vector(s).  By default, the last axis.'}, {'name': 'axisb', 'type': 'int, optional', 'description': 'Axis of b that defines the vector(s).  By default, the last axis.'}, {'name': 'axisc', 'type': 'int, optional', 'description': 'Axis of c containing the cross product vector(s).  Ignored ifboth input vectors have dimension 2, as the return is scalar.By default, the last axis.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'If defined, the axis of a, b and c that defines the vector(s)and cross product(s).  Overrides axisa, axisb and axisc.'}]}, {'Returns': [{'name': 'c', 'type': 'ndarray', 'description': 'Vector cross product(s).'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'When the dimension of the vector(s) in a and/or b does notequal 2 or 3.'}]}]",">>> import numpy as np
>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([-3,  6, -3])
>>> x = [1, 2]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])
>>> x = [1, 2, 0]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])
>>> x = [1,2]
>>> y = [4,5]
>>> np.cross(x, y)
array(-3)
>>> x = np.array([[1,2,3], [4,5,6]])
>>> y = np.array([[4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])
>>> np.cross(x, y, axisc=0)
array([[-3,  3],
       [ 6, -6],
       [-3,  3]])
>>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
>>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[ -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6]])
>>> np.cross(x, y, axisa=0, axisb=0)
array([[-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36]])"
numpy.trapezoid,Integrate along the given axis using the composite trapezoidal rule.,"[{'Parameters': [{'name': 'y', 'type': 'array_like', 'description': 'Input array to integrate.'}, {'name': 'x', 'type': 'array_like, optional', 'description': 'The sample points corresponding to the y values. If x is None,the sample points are assumed to be evenly spaced dx apart. Thedefault is None.'}, {'name': 'dx', 'type': 'scalar, optional', 'description': 'The spacing between sample points when x is None. The default is 1.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'The axis along which to integrate.'}]}, {'Returns': [{'name': 'trapezoid', 'type': 'float or ndarray', 'description': 'Definite integral of y = n-dimensional array as approximated alonga single axis by the trapezoidal rule. If y is a 1-dimensional array,then the result is a float. If n is greater than 1, then the resultis an n-1 dimensional array.'}]}]",">>> import numpy as np
>>> np.trapezoid([1, 2, 3])
4.0
>>> np.trapezoid([1, 2, 3], x=[4, 6, 8])
8.0
>>> np.trapezoid([1, 2, 3], dx=2)
8.0
>>> np.trapezoid([1, 2, 3], x=[8, 6, 4])
-8.0
>>> x = np.linspace(0, 1, num=50)
>>> y = x**2
>>> np.trapezoid(y, x)
0.33340274885464394
>>> theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)
>>> np.trapezoid(np.cos(theta), x=np.sin(theta))
3.141571941375841
>>> a = np.arange(6).reshape(2, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.trapezoid(a, axis=0)
array([1.5, 2.5, 3.5])
>>> np.trapezoid(a, axis=1)
array([2.,  8.])"
numpy.exp,Calculate the exponential of all elements in the input array.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Output array, element-wise exponential of x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)
>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
>>> out = np.exp(xx)
>>> plt.subplot(121)
>>> plt.imshow(np.abs(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')
>>> plt.title('Magnitude of exp(x)')
>>> plt.subplot(122)
>>> plt.imshow(np.angle(out),
...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')
>>> plt.title('Phase (angle) of exp(x)')
>>> plt.show()"
numpy.expm1,Calculate exp(x) - 1 for all elements in the array.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Element-wise exponential minus one: out = exp(x) - 1.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.expm1(1e-10)
1.00000000005e-10
>>> np.exp(1e-10) - 1
1.000000082740371e-10"
numpy.exp2,Calculate 2**p for all p in the input array.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Element-wise 2 to the power x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.exp2([2, 3])
array([ 4.,  8.])"
numpy.log,"Natural logarithm, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input value.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The natural logarithm of x, element-wise.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.log([1, np.e, np.e**2, 0])
array([  0.,   1.,   2., -inf])"
numpy.log10,"Return the base 10 logarithm of the input array, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The logarithm to the base 10 of x, element-wise. NaNs arereturned where x is negative.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.log10([1e-15, -3.])
array([-15.,  nan])"
numpy.log2,Base-2 logarithm of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Base-2 logarithm of x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> x = np.array([0, 1, 2, 2**4])
>>> np.log2(x)
array([-inf,   0.,   1.,   4.])
>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])
>>> np.log2(xi)
array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])"
numpy.log1p,"Return the natural logarithm of one plus the input array, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Natural logarithm of 1 + x, element-wise.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.log1p(1e-99)
1e-99
>>> np.log(1 + 1e-99)
0.0"
numpy.logaddexp,Logarithm of the sum of exponentiations of the inputs.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input values.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray', 'description': 'Logarithm of exp(x1) + exp(x2).This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> prob1 = np.log(1e-50)
>>> prob2 = np.log(2.5e-50)
>>> prob12 = np.logaddexp(prob1, prob2)
>>> prob12
-113.87649168120691
>>> np.exp(prob12)
3.5000000000000057e-50"
numpy.logaddexp2,Logarithm of the sum of exponentiations of the inputs in base-2.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input values.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray', 'description': 'Base-2 logarithm of 2**x1 + 2**x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> prob1 = np.log2(1e-50)
>>> prob2 = np.log2(2.5e-50)
>>> prob12 = np.logaddexp2(prob1, prob2)
>>> prob1, prob2, prob12
(-166.09640474436813, -164.77447664948076, -164.28904982231052)
>>> 2**prob12
3.4999999999999914e-50"
numpy.i0,"Modified Bessel function of the first kind, order 0.","[{'Parameters': [{'name': 'x', 'type': 'array_like of float', 'description': 'Argument of the Bessel function.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray, shape = x.shape, dtype = float', 'description': 'The modified Bessel function evaluated at each of the elements of x.'}]}]",">>> import numpy as np
>>> np.i0(0.)
array(1.0)
>>> np.i0([0, 1, 2, 3])
array([1.        , 1.26606588, 2.2795853 , 4.88079259])"
numpy.sinc,Return the normalized sinc function.,"[{'Parameters': [{'name': 'x', 'type': 'ndarray', 'description': 'Array (possibly multi-dimensional) of values for which to calculatesinc(x).'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'sinc(x), which has the same shape as the input.'}]}]",">>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 41)
>>> np.sinc(x)
 array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
        -4.92362781e-02,  -3.89804309e-17])
>>> plt.plot(x, np.sinc(x))
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title(""Sinc Function"")
Text(0.5, 1.0, 'Sinc Function')
>>> plt.ylabel(""Amplitude"")
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel(""X"")
Text(0.5, 0, 'X')
>>> plt.show()"
numpy.signbit,Returns element-wise True where signbit is set (less than zero).,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The input value(s).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'result', 'type': 'ndarray of bool', 'description': 'Output array, or reference to out if that was supplied.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.signbit(-1.2)
True
>>> np.signbit(np.array([1, -2.3, 2.1]))
array([False,  True, False])"
numpy.copysign,"Change the sign of x1 to that of x2, element-wise.","[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Values to change the sign of.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The sign of x2 is copied to x1.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The values of x1 with the sign of x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.copysign(1.3, -1)
-1.3
>>> 1/np.copysign(0, 1)
inf
>>> 1/np.copysign(0, -1)
-inf
>>> np.copysign([-1, 0, 1], -1.1)
array([-1., -0., -1.])
>>> np.copysign([-1, 0, 1], np.arange(3)-1)
array([-1.,  0.,  1.])"
numpy.frexp,Decompose the elements of x into mantissa and twos exponent.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Array of numbers to be decomposed.'}, {'name': 'out1', 'type': 'ndarray, optional', 'description': 'Output array for the mantissa. Must have the same shape as x.'}, {'name': 'out2', 'type': 'ndarray, optional', 'description': 'Output array for the exponent. Must have the same shape as x.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'mantissa', 'type': 'ndarray', 'description': 'Floating values between -1 and 1.This is a scalar if x is a scalar.'}, {'name': 'exponent', 'type': 'ndarray', 'description': 'Integer exponents of 2.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> x = np.arange(9)
>>> y1, y2 = np.frexp(x)
>>> y1
array([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,
        0.5  ])
>>> y2
array([0, 1, 2, 2, 3, 3, 3, 3, 4], dtype=int32)
>>> y1 * 2**y2
array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])"
numpy.ldexp,"Returns x1 * 2**x2, element-wise.","[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Array of multipliers.'}, {'name': 'x2', 'type': 'array_like, int', 'description': 'Array of twos exponents.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The result of x1 * 2**x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.ldexp(5, np.arange(4))
array([ 5., 10., 20., 40.], dtype=float16)
>>> x = np.arange(6)
>>> np.ldexp(*np.frexp(x))
array([ 0.,  1.,  2.,  3.,  4.,  5.])"
numpy.nextafter,"Return the next floating-point value after x1 towards x2, element-wise.","[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Values to find the next representable value of.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The direction where to look for the next representable value of x1.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The next representable values of x1 in the direction of x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> eps = np.finfo(np.float64).eps
>>> np.nextafter(1, 2) == eps + 1
True
>>> np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]
array([ True,  True])"
numpy.spacing,Return the distance between x and the nearest adjacent number.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Values to find the spacing of.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The spacing of values of x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.spacing(1) == np.finfo(np.float64).eps
True"
numpy.lcm,Returns the lowest common multiple of |x1| and |x2|,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like, int', 'description': 'Arrays of values.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The lowest common multiple of the absolute value of the inputsThis is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.lcm(12, 20)
60
>>> np.lcm.reduce([3, 12, 20])
60
>>> np.lcm.reduce([40, 12, 20])
120
>>> np.lcm(np.arange(6), 20)
array([ 0, 20, 20, 60, 20, 20])"
numpy.gcd,Returns the greatest common divisor of |x1| and |x2|,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like, int', 'description': 'Arrays of values.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The greatest common divisor of the absolute value of the inputsThis is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.gcd(12, 20)
4
>>> np.gcd.reduce([15, 25, 35])
5
>>> np.gcd(np.arange(6), 20)
array([20,  1,  2,  1,  4,  5])"
numpy.add,Add arguments element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'The arrays to be added.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'add', 'type': 'ndarray or scalar', 'description': 'The sum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.add(1.0, 4.0)
5.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.add(x1, x2)
array([[  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.]])
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> x1 + x2
array([[ 0.,  2.,  4.],
       [ 3.,  5.,  7.],
       [ 6.,  8., 10.]])"
numpy.reciprocal,"Return the reciprocal of the argument, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'Return array.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.reciprocal(2.)
0.5
>>> np.reciprocal([1, 2., 3.33])
array([ 1.       ,  0.5      ,  0.3003003])"
numpy.positive,"Numerical positive, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like or scalar', 'description': 'Input array.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'Returned array or scalar: y = +x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> x1 = np.array(([1., -1.]))
>>> np.positive(x1)
array([ 1., -1.])
>>> x1 = np.array(([1., -1.]))
>>> +x1
array([ 1., -1.])"
numpy.negative,"Numerical negative, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like or scalar', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'Returned array or scalar: y = -x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.negative([1.,-1.])
array([-1.,  1.])
>>> x1 = np.array(([1., -1.]))
>>> -x1
array([-1.,  1.])"
numpy.multiply,Multiply arguments element-wise.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'Input arrays to be multiplied.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The product of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.multiply(2.0, 4.0)
8.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.multiply(x1, x2)
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> x1 * x2
array([[  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.]])"
numpy.divide,Divide arguments element-wise.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Dividend array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Divisor array.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The quotient x1/x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.divide(2.0, 4.0)
0.5
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.divide(x1, x2)
array([[nan, 1. , 1. ],
       [inf, 4. , 2.5],
       [inf, 7. , 4. ]])
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = 2 * np.ones(3)
>>> x1 / x2
array([[0. , 0.5, 1. ],
       [1.5, 2. , 2.5],
       [3. , 3.5, 4. ]])"
numpy.power,"First array elements raised to powers from second array, element-wise.","[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'The bases.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The exponents.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The bases in x1 raised to the exponents in x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> x1 = np.arange(6)
>>> x1
[0, 1, 2, 3, 4, 5]
>>> np.power(x1, 3)
array([  0,   1,   8,  27,  64, 125])
>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
>>> np.power(x1, x2)
array([  0.,   1.,   8.,  27.,  16.,   5.])
>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
>>> x2
array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])
>>> np.power(x1, x2)
array([[ 0,  1,  8, 27, 16,  5],
       [ 0,  1,  8, 27, 16,  5]])
>>> x2 = np.array([1, 2, 3, 3, 2, 1])
>>> x1 = np.arange(6)
>>> x1 ** x2
array([ 0,  1,  8, 27, 16,  5])
>>> x3 = np.array([-1.0, -4.0])
>>> with np.errstate(invalid='ignore'):
...     p = np.power(x3, 1.5)
...
>>> p
array([nan, nan])
>>> np.power(x3, 1.5, dtype=complex)
array([-1.83697020e-16-1.j, -1.46957616e-15-8.j])"
numpy.pow,"First array elements raised to powers from second array, element-wise.","[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'The bases.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The exponents.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The bases in x1 raised to the exponents in x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> x1 = np.arange(6)
>>> x1
[0, 1, 2, 3, 4, 5]
>>> np.power(x1, 3)
array([  0,   1,   8,  27,  64, 125])
>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
>>> np.power(x1, x2)
array([  0.,   1.,   8.,  27.,  16.,   5.])
>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
>>> x2
array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])
>>> np.power(x1, x2)
array([[ 0,  1,  8, 27, 16,  5],
       [ 0,  1,  8, 27, 16,  5]])
>>> x2 = np.array([1, 2, 3, 3, 2, 1])
>>> x1 = np.arange(6)
>>> x1 ** x2
array([ 0,  1,  8, 27, 16,  5])
>>> x3 = np.array([-1.0, -4.0])
>>> with np.errstate(invalid='ignore'):
...     p = np.power(x3, 1.5)
...
>>> p
array([nan, nan])
>>> np.power(x3, 1.5, dtype=complex)
array([-1.83697020e-16-1.j, -1.46957616e-15-8.j])"
numpy.subtract,"Subtract arguments, element-wise.","[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'The arrays to be subtracted from each other.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The difference of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.subtract(1.0, 4.0)
-3.0
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.subtract(x1, x2)
array([[ 0.,  0.,  0.],
       [ 3.,  3.,  3.],
       [ 6.,  6.,  6.]])
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> x1 - x2
array([[0., 0., 0.],
       [3., 3., 3.],
       [6., 6., 6.]])"
numpy.true_divide,Divide arguments element-wise.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Dividend array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Divisor array.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The quotient x1/x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.divide(2.0, 4.0)
0.5
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = np.arange(3.0)
>>> np.divide(x1, x2)
array([[nan, 1. , 1. ],
       [inf, 4. , 2.5],
       [inf, 7. , 4. ]])
>>> x1 = np.arange(9.0).reshape((3, 3))
>>> x2 = 2 * np.ones(3)
>>> x1 / x2
array([[0. , 0.5, 1. ],
       [1.5, 2. , 2.5],
       [3. , 3.5, 4. ]])"
numpy.floor_divide,"Return the largest integer smaller or equal to the division of the inputs.
It is equivalent to the Python // operator and pairs with the
Python % (remainder), function so that a = a % b + b * (a // b)
up to roundoff.","[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Numerator.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Denominator.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'y = floor(x1/x2)This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.floor_divide(7,3)
2
>>> np.floor_divide([1., 2., 3., 4.], 2.5)
array([ 0.,  0.,  1.,  1.])
>>> x1 = np.array([1., 2., 3., 4.])
>>> x1 // 2.5
array([0., 0., 1., 1.])"
numpy.float_power,"First array elements raised to powers from second array, element-wise.","[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'The bases.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The exponents.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The bases in x1 raised to the exponents in x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> x1 = range(6)
>>> x1
[0, 1, 2, 3, 4, 5]
>>> np.float_power(x1, 3)
array([   0.,    1.,    8.,   27.,   64.,  125.])
>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]
>>> np.float_power(x1, x2)
array([  0.,   1.,   8.,  27.,  16.,   5.])
>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])
>>> x2
array([[1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1]])
>>> np.float_power(x1, x2)
array([[  0.,   1.,   8.,  27.,  16.,   5.],
       [  0.,   1.,   8.,  27.,  16.,   5.]])
>>> x3 = np.array([-1, -4])
>>> with np.errstate(invalid='ignore'):
...     p = np.float_power(x3, 1.5)
...
>>> p
array([nan, nan])
>>> np.float_power(x3, 1.5, dtype=complex)
array([-1.83697020e-16-1.j, -1.46957616e-15-8.j])"
numpy.fmod,Returns the element-wise remainder of division.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Dividend.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Divisor.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'array_like', 'description': 'The remainder of the division of x1 by x2.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)
array([-1,  0, -1,  1,  0,  1])
>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)
array([1, 0, 1, 1, 0, 1])
>>> np.fmod([5, 3], [2, 2.])
array([ 1.,  1.])
>>> a = np.arange(-3, 3).reshape(3, 2)
>>> a
array([[-3, -2],
       [-1,  0],
       [ 1,  2]])
>>> np.fmod(a, [2,2])
array([[-1,  0],
       [-1,  0],
       [ 1,  0]])"
numpy.mod,Returns the element-wise remainder of division.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Dividend array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Divisor array.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The element-wise remainder of the quotient floor_divide(x1, x2).This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
>>> x1 = np.arange(7)
>>> x1 % 5
array([0, 1, 2, 3, 4, 0, 1])"
numpy.modf,"Return the fractional and integral parts of an array, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y1', 'type': 'ndarray', 'description': 'Fractional part of x.This is a scalar if x is a scalar.'}, {'name': 'y2', 'type': 'ndarray', 'description': 'Integral part of x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.modf([0, 3.5])
(array([ 0. ,  0.5]), array([ 0.,  3.]))
>>> np.modf(-0.5)
(-0.5, -0)"
numpy.remainder,Returns the element-wise remainder of division.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Dividend array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Divisor array.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The element-wise remainder of the quotient floor_divide(x1, x2).This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.remainder([4, 7], [2, 3])
array([0, 1])
>>> np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])
>>> x1 = np.arange(7)
>>> x1 % 5
array([0, 1, 2, 3, 4, 0, 1])"
numpy.divmod,Return element-wise quotient and remainder simultaneously.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Dividend array.'}, {'name': 'x2', 'type': 'array_like', 'description': 'Divisor array.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out1', 'type': 'ndarray', 'description': 'Element-wise quotient resulting from floor division.This is a scalar if both x1 and x2 are scalars.'}, {'name': 'out2', 'type': 'ndarray', 'description': 'Element-wise remainder from floor division.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.divmod(np.arange(5), 3)
(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))
>>> x = np.arange(5)
>>> divmod(x, 3)
(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))"
numpy.angle,Return the angle of the complex argument.,"[{'Parameters': [{'name': 'z', 'type': 'array_like', 'description': 'A complex number or sequence of complex numbers.'}, {'name': 'deg', 'type': 'bool, optional', 'description': 'Return angle in degrees if True, radians if False (default).'}]}, {'Returns': [{'name': 'angle', 'type': 'ndarray or scalar', 'description': 'The counterclockwise angle from the positive real axis on the complexplane in the range (-pi, pi], with dtype as numpy.float64.'}]}]",">>> import numpy as np
>>> np.angle([1.0, 1.0j, 1+1j])               # in radians
array([ 0.        ,  1.57079633,  0.78539816]) # may vary
>>> np.angle(1+1j, deg=True)                  # in degrees
45.0
>>> np.angle([0., -0., complex(0., -0.), complex(-0., -0.)])  # convention
array([ 0.        ,  3.14159265, -0.        , -3.14159265])"
numpy.real,Return the real part of the complex argument.,"[{'Parameters': [{'name': 'val', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The real component of the complex argument. If val is real, the typeof val is used for the output.  If val has complex elements, thereturned type is float.'}]}]",">>> import numpy as np
>>> a = np.array([1+2j, 3+4j, 5+6j])
>>> a.real
array([1.,  3.,  5.])
>>> a.real = 9
>>> a
array([9.+2.j,  9.+4.j,  9.+6.j])
>>> a.real = np.array([9, 8, 7])
>>> a
array([9.+2.j,  8.+4.j,  7.+6.j])
>>> np.real(1 + 1j)
1.0"
numpy.imag,Return the imaginary part of the complex argument.,"[{'Parameters': [{'name': 'val', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The imaginary component of the complex argument. If val is real,the type of val is used for the output.  If val has complexelements, the returned type is float.'}]}]",">>> import numpy as np
>>> a = np.array([1+2j, 3+4j, 5+6j])
>>> a.imag
array([2.,  4.,  6.])
>>> a.imag = np.array([8, 10, 12])
>>> a
array([1. +8.j,  3.+10.j,  5.+12.j])
>>> np.imag(1 + 1j)
1.0"
numpy.conj,"Return the complex conjugate, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input value.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The complex conjugate of x, with same dtype as y.This is a scalar if x is a scalar.'}]}]",">>> np.conj is np.conjugate
True
>>> import numpy as np
>>> np.conjugate(1+2j)
(1-2j)
>>> x = np.eye(2) + 1j * np.eye(2)
>>> np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])"
numpy.conjugate,"Return the complex conjugate, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input value.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The complex conjugate of x, with same dtype as y.This is a scalar if x is a scalar.'}]}]",">>> np.conj is np.conjugate
True
>>> import numpy as np
>>> np.conjugate(1+2j)
(1-2j)
>>> x = np.eye(2) + 1j * np.eye(2)
>>> np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j]])"
numpy.maximum,Element-wise maximum of array elements.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'The arrays holding the elements to be compared.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The maximum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.maximum([2, 3, 4], [1, 5, 2])
array([2, 5, 4])
>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])
>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.maximum(np.inf, 1)
inf"
numpy.max,Return the maximum of an array or maximum along an axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which to operate.  By default, flattened input isused. If this is a tuple of ints, the maximum is selected overmultiple axes, instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result.  Mustbe of the same shape and buffer length as the expected output.See Output type determination for more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the max method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'The minimum value of an output element. Must be present to allowcomputation on empty slice. See reduce for details.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to compare for the maximum. See reducefor details.'}]}, {'Returns': [{'name': 'max', 'type': 'ndarray or scalar', 'description': 'Maximum of a. If axis is None, the result is a scalar value.If axis is an int, the result is an array of dimensiona.ndim - 1. If axis is a tuple, the result is an array ofdimension a.ndim - len(axis).'}]}]",">>> import numpy as np
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.max(a)           # Maximum of the flattened array
3
>>> np.max(a, axis=0)   # Maxima along the first axis
array([2, 3])
>>> np.max(a, axis=1)   # Maxima along the second axis
array([1, 3])
>>> np.max(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
>>> b = np.arange(5, dtype=float)
>>> b[2] = np.nan
>>> np.max(b)
np.float64(nan)
>>> np.max(b, where=~np.isnan(b), initial=-1)
4.0
>>> np.nanmax(b)
4.0
>>> np.max([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])
>>> np.max([5], initial=6)
6
>>> max([5], default=6)
5"
numpy.amax,Return the maximum of an array or maximum along an axis.,[],
numpy.fmax,Element-wise maximum of array elements.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'The arrays holding the elements to be compared.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The maximum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.fmax([2, 3, 4], [1, 5, 2])
array([ 2,  5,  4])
>>> np.fmax(np.eye(2), [0.5, 2])
array([[ 1. ,  2. ],
       [ 0.5,  2. ]])
>>> np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([ 0.,  0., nan])"
numpy.nanmax,"Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a RuntimeWarning is
raised and NaN is returned for that slice.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose maximum is desired. If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the maximum is computed. The default is to computethe maximum of the flattened array.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  The defaultis None; if provided, it must have the same shape as theexpected output, but the type will be cast if necessary. SeeOutput type determination for more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.If the value is anything but the default, thenkeepdims will be passed through to the max methodof sub-classes of ndarray.  If the sub-classes methodsdoes not implement keepdims any exceptions will be raised.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'The minimum value of an output element. Must be present to allowcomputation on empty slice. See reduce for details.New in version 1.22.0.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to compare for the maximum. See reducefor details.New in version 1.22.0.'}]}, {'Returns': [{'name': 'nanmax', 'type': 'ndarray', 'description': 'An array with the same shape as a, with the specified axis removed.If a is a 0-d array, or if axis is None, an ndarray scalar isreturned.  The same dtype as a is returned.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nanmax(a)
3.0
>>> np.nanmax(a, axis=0)
array([3.,  2.])
>>> np.nanmax(a, axis=1)
array([2.,  3.])
>>> np.nanmax([1, 2, np.nan, -np.inf])
2.0
>>> np.nanmax([1, 2, np.nan, np.inf])
inf"
numpy.minimum,Element-wise minimum of array elements.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'The arrays holding the elements to be compared.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The minimum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.minimum([2, 3, 4], [1, 5, 2])
array([1, 3, 2])
>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting
array([[ 0.5,  0. ],
       [ 0. ,  1. ]])
>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([nan, nan, nan])
>>> np.minimum(-np.inf, 1)
-inf"
numpy.min,Return the minimum of an array or minimum along an axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'None or int or tuple of ints, optional', 'description': 'Axis or axes along which to operate.  By default, flattened input isused.If this is a tuple of ints, the minimum is selected over multiple axes,instead of a single axis or all the axes as before.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternative output array in which to place the result.  Mustbe of the same shape and buffer length as the expected output.See Output type determination for more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.If the default value is passed, then keepdims will not bepassed through to the min method of sub-classes ofndarray, however any non-default value will be.  If thesub-class’ method does not implement keepdims anyexceptions will be raised.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'The maximum value of an output element. Must be present to allowcomputation on empty slice. See reduce for details.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to compare for the minimum. See reducefor details.'}]}, {'Returns': [{'name': 'min', 'type': 'ndarray or scalar', 'description': 'Minimum of a. If axis is None, the result is a scalar value.If axis is an int, the result is an array of dimensiona.ndim - 1.  If axis is a tuple, the result is an array ofdimension a.ndim - len(axis).'}]}]",">>> import numpy as np
>>> a = np.arange(4).reshape((2,2))
>>> a
array([[0, 1],
       [2, 3]])
>>> np.min(a)           # Minimum of the flattened array
0
>>> np.min(a, axis=0)   # Minima along the first axis
array([0, 1])
>>> np.min(a, axis=1)   # Minima along the second axis
array([0, 2])
>>> np.min(a, where=[False, True], initial=10, axis=0)
array([10,  1])
>>> b = np.arange(5, dtype=float)
>>> b[2] = np.nan
>>> np.min(b)
np.float64(nan)
>>> np.min(b, where=~np.isnan(b), initial=10)
0.0
>>> np.nanmin(b)
0.0
>>> np.min([[-50], [10]], axis=-1, initial=0)
array([-50,   0])
>>> np.min([6], initial=5)
5
>>> min([6], default=5)
6"
numpy.amin,Return the minimum of an array or minimum along an axis.,[],
numpy.fmin,Element-wise minimum of array elements.,"[{'Parameters': [{'name': 'x1, x2', 'type': 'array_like', 'description': 'The arrays holding the elements to be compared.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The minimum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.fmin([2, 3, 4], [1, 5, 2])
array([1, 3, 2])
>>> np.fmin(np.eye(2), [0.5, 2])
array([[ 0.5,  0. ],
       [ 0. ,  1. ]])
>>> np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])
array([ 0.,  0., nan])"
numpy.nanmin,"Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a RuntimeWarning is raised and
Nan is returned for that slice.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing numbers whose minimum is desired. If a is not anarray, a conversion is attempted.'}, {'name': 'axis', 'type': '{int, tuple of int, None}, optional', 'description': 'Axis or axes along which the minimum is computed. The default is to computethe minimum of the flattened array.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'Alternate output array in which to place the result.  The defaultis None; if provided, it must have the same shape as theexpected output, but the type will be cast if necessary. SeeOutput type determination for more details.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the original a.If the value is anything but the default, thenkeepdims will be passed through to the min methodof sub-classes of ndarray.  If the sub-classes methodsdoes not implement keepdims any exceptions will be raised.'}, {'name': 'initial', 'type': 'scalar, optional', 'description': 'The maximum value of an output element. Must be present to allowcomputation on empty slice. See reduce for details.New in version 1.22.0.'}, {'name': 'where', 'type': 'array_like of bool, optional', 'description': 'Elements to compare for the minimum. See reducefor details.New in version 1.22.0.'}]}, {'Returns': [{'name': 'nanmin', 'type': 'ndarray', 'description': 'An array with the same shape as a, with the specified axisremoved.  If a is a 0-d array, or if axis is None, an ndarrayscalar is returned.  The same dtype as a is returned.'}]}]",">>> import numpy as np
>>> a = np.array([[1, 2], [3, np.nan]])
>>> np.nanmin(a)
1.0
>>> np.nanmin(a, axis=0)
array([1.,  2.])
>>> np.nanmin(a, axis=1)
array([1.,  3.])
>>> np.nanmin([1, 2, np.nan, np.inf])
1.0
>>> np.nanmin([1, 2, np.nan, -np.inf])
-inf"
numpy.convolve,"Returns the discrete, linear convolution of two one-dimensional sequences.","[{'Parameters': [{'name': 'a', 'type': '(N,) array_like', 'description': 'First one-dimensional input array.'}, {'name': 'v', 'type': '(M,) array_like', 'description': 'Second one-dimensional input array.'}, {'name': 'mode', 'type': '{‘full’, ‘valid’, ‘same’}, optional', 'description': '‘full’:By default, mode is ‘full’.  This returns the convolutionat each point of overlap, with an output shape of (N+M-1,). Atthe end-points of the convolution, the signals do not overlapcompletely, and boundary effects may be seen.‘same’:Mode ‘same’ returns output of length max(M, N).  Boundaryeffects are still visible.‘valid’:Mode ‘valid’ returns output of lengthmax(M, N) - min(M, N) + 1.  The convolution product is only givenfor points where the signals overlap completely.  Values outsidethe signal boundary have no effect.'}, {'name': '‘full’:', 'type': None, 'description': 'By default, mode is ‘full’.  This returns the convolutionat each point of overlap, with an output shape of (N+M-1,). Atthe end-points of the convolution, the signals do not overlapcompletely, and boundary effects may be seen.'}, {'name': '‘same’:', 'type': None, 'description': 'Mode ‘same’ returns output of length max(M, N).  Boundaryeffects are still visible.'}, {'name': '‘valid’:', 'type': None, 'description': 'Mode ‘valid’ returns output of lengthmax(M, N) - min(M, N) + 1.  The convolution product is only givenfor points where the signals overlap completely.  Values outsidethe signal boundary have no effect.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'Discrete, linear convolution of a and v.'}]}]",">>> import numpy as np
>>> np.convolve([1, 2, 3], [0, 1, 0.5])
array([0. , 1. , 2.5, 4. , 1.5])
>>> np.convolve([1,2,3],[0,1,0.5], 'same')
array([1. ,  2.5,  4. ])
>>> np.convolve([1,2,3],[0,1,0.5], 'valid')
array([2.5])"
numpy.clip,Clip (limit) the values in an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array containing elements to clip.'}, {'name': 'a_min, a_max', 'type': 'array_like or None', 'description': 'Minimum and maximum value. If None, clipping is not performed onthe corresponding edge. If both a_min and a_max are None,the elements of the returned array stay the same. Both are broadcastedagainst a.'}, {'name': 'out', 'type': 'ndarray, optional', 'description': 'The results will be placed in this array. It may be the inputarray for in-place clipping.  out must be of the right shapeto hold the output.  Its type is preserved.'}, {'name': 'min, max', 'type': 'array_like or None', 'description': 'Array API compatible alternatives for a_min and a_maxarguments. Either a_min and a_max or min and maxcan be passed at the same time. Default: None.New in version 2.1.0.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'clipped_array', 'type': 'ndarray', 'description': 'An array with the elements of a, but where values< a_min are replaced with a_min, and those > a_maxwith a_max.'}]}]",">>> import numpy as np
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
>>> np.clip(a, 8, 1)
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
>>> np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
>>> a
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])"
numpy.sqrt,"Return the non-negative square-root of an array, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The values whose square-roots are required.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'An array of the same shape as x, containing the positivesquare-root of each element in x.  If any element in x iscomplex, a complex array is returned (and the square-roots ofnegative reals are calculated).  If all of the elements in xare real, so is y, with negative elements returning nan.If out was provided, y is a reference to it.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.sqrt([1,4,9])
array([ 1.,  2.,  3.])
>>> np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])
>>> np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])"
numpy.cbrt,"Return the cube-root of an array, element-wise.","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The values whose cube-roots are required.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'An array of the same shape as x, containing thecube root of each element in x.If out was provided, y is a reference to it.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.cbrt([1,8,27])
array([ 1.,  2.,  3.])"
numpy.square,Return the element-wise square of the input.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'Element-wise x*x, of the same shape and dtype as x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.square([-1j, 1])
array([-1.-0.j,  1.+0.j])"
numpy.absolute,Calculate the absolute value element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'absolute', 'type': 'ndarray', 'description': 'An ndarray containing the absolute value ofeach element in x.  For complex input, a + ib, theabsolute value is \\(\\sqrt{ a^2 + b^2 }\\).This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> x = np.array([-1.2, 1.2])
>>> np.absolute(x)
array([ 1.2,  1.2])
>>> np.absolute(1.2 + 1j)
1.5620499351813308
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(start=-10, stop=10, num=101)
>>> plt.plot(x, np.absolute(x))
>>> plt.show()
>>> xx = x + 1j * x[:, np.newaxis]
>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
>>> plt.show()
>>> x = np.array([-1.2, 1.2])
>>> abs(x)
array([1.2, 1.2])"
numpy.fabs,Compute the absolute values element-wise.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The array of numbers for which the absolute values are required. Ifx is a scalar, the result y will also be a scalar.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray or scalar', 'description': 'The absolute values of x, the returned values are always floats.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.fabs(-1)
1.0
>>> np.fabs([-1.2, 1.2])
array([ 1.2,  1.2])"
numpy.sign,Returns an element-wise indication of the sign of a number.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The sign of x.This is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.sign([-5., 4.5])
array([-1.,  1.])
>>> np.sign(0)
0
>>> np.sign([3-4j, 8j])
array([0.6-0.8j, 0. +1.j ])"
numpy.heaviside,Compute the Heaviside step function.,"[{'Parameters': [{'name': 'x1', 'type': 'array_like', 'description': 'Input values.'}, {'name': 'x2', 'type': 'array_like', 'description': 'The value of the function when x1 is 0.If x1.shape != x2.shape, they must be broadcastable to a commonshape (which becomes the shape of the output).'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The output array, element-wise Heaviside step function of x1.This is a scalar if both x1 and x2 are scalars.'}]}]",">>> import numpy as np
>>> np.heaviside([-1.5, 0, 2.0], 0.5)
array([ 0. ,  0.5,  1. ])
>>> np.heaviside([-1.5, 0, 2.0], 1)
array([ 0.,  1.,  1.])"
numpy.nan_to_num,"Replace NaN with zero and infinity with large finite numbers (default
behaviour) or with the numbers defined by the user using the nan,
posinf and/or neginf keywords.","[{'Parameters': [{'name': 'x', 'type': 'scalar or array_like', 'description': 'Input data.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Whether to create a copy of x (True) or to replace valuesin-place (False). The in-place operation only occurs ifcasting to an array does not require a copy.Default is True.'}, {'name': 'nan', 'type': 'int, float, optional', 'description': 'Value to be used to fill NaN values. If no value is passedthen NaN values will be replaced with 0.0.'}, {'name': 'posinf', 'type': 'int, float, optional', 'description': 'Value to be used to fill positive infinity values. If no value ispassed then positive infinity values will be replaced with a verylarge number.'}, {'name': 'neginf', 'type': 'int, float, optional', 'description': 'Value to be used to fill negative infinity values. If no value ispassed then negative infinity values will be replaced with a verysmall (or negative) number.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'x, with the non-finite values replaced. If copy is False, this maybe x itself.'}]}]",">>> import numpy as np
>>> np.nan_to_num(np.inf)
1.7976931348623157e+308
>>> np.nan_to_num(-np.inf)
-1.7976931348623157e+308
>>> np.nan_to_num(np.nan)
0.0
>>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
>>> np.nan_to_num(x)
array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary
       -1.28000000e+002,  1.28000000e+002])
>>> np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)
array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03,
       -1.2800000e+02,  1.2800000e+02])
>>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary
     -1.28000000e+002,   1.28000000e+002])
>>> np.nan_to_num(y)
array([  1.79769313e+308 +0.00000000e+000j, # may vary
         0.00000000e+000 +0.00000000e+000j,
         0.00000000e+000 +1.79769313e+308j])
>>> np.nan_to_num(y, nan=111111, posinf=222222)
array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])"
Constants,NumPy includes several constants:,[],">>> import numpy as np
>>> np.inf
inf
>>> np.array([1]) / 0.
array([inf])
>>> import numpy as np
>>> np.nan
nan
>>> np.log(-1)
np.float64(nan)
>>> np.log([-1, 1, 2])
array([       nan, 0.        , 0.69314718])
>>> import numpy as np
>>> np.newaxis is None
True
>>> x = np.arange(3)
>>> x
array([0, 1, 2])
>>> x[:, np.newaxis]
array([[0],
[1],
[2]])
>>> x[:, np.newaxis, np.newaxis]
array([[[0]],
[[1]],
[[2]]])
>>> x[:, np.newaxis] * x
array([[0, 0, 0],
    [0, 1, 2],
    [0, 2, 4]])
>>> y = np.arange(3, 6)
>>> x[:, np.newaxis] * y
array([[ 0,  0,  0],
    [ 3,  4,  5],
    [ 6,  8, 10]])
>>> x[np.newaxis, :].shape
(1, 3)
>>> x[np.newaxis].shape
(1, 3)
>>> x[None].shape
(1, 3)
>>> x[:, np.newaxis].shape
(3, 1)"
numpy.real_if_close,"If input is complex with all imaginary parts close to zero, return
real parts.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'tol', 'type': 'float', 'description': 'Tolerance in machine epsilons for the complex part of the elementsin the array. If the tolerance is <=1, then the absolute toleranceis used.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'If a is real, the type of a is used for the output.  If ahas complex elements, the returned type is float.'}]}]",">>> import numpy as np
>>> np.finfo(float).eps
2.2204460492503131e-16 # may vary
>>> np.real_if_close([2.1 + 4e-14j, 5.2 + 3e-15j], tol=1000)
array([2.1, 5.2])
>>> np.real_if_close([2.1 + 4e-13j, 5.2 + 3e-15j], tol=1000)
array([2.1+4.e-13j, 5.2 + 3e-15j])"
numpy.interp,One-dimensional linear interpolation for monotonically increasing sample points.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The x-coordinates at which to evaluate the interpolated values.'}, {'name': 'xp', 'type': '1-D sequence of floats', 'description': 'The x-coordinates of the data points, must be increasing if argumentperiod is not specified. Otherwise, xp is internally sorted afternormalizing the periodic boundaries with xp = xp % period.'}, {'name': 'fp', 'type': '1-D sequence of float or complex', 'description': 'The y-coordinates of the data points, same length as xp.'}, {'name': 'left', 'type': 'optional float or complex corresponding to fp', 'description': 'Value to return for x < xp[0], default is fp[0].'}, {'name': 'right', 'type': 'optional float or complex corresponding to fp', 'description': 'Value to return for x > xp[-1], default is fp[-1].'}, {'name': 'period', 'type': 'None or float, optional', 'description': 'A period for the x-coordinates. This parameter allows the properinterpolation of angular x-coordinates. Parameters left and rightare ignored if period is specified.'}]}, {'Returns': [{'name': 'y', 'type': 'float or complex (corresponding to fp) or ndarray', 'description': 'The interpolated values, same shape as x.'}]}, {'Raises': [{'name': 'ValueError', 'type': None, 'description': 'If xp and fp have different lengthIf xp or fp are not 1-D sequencesIf period == 0'}]}]",">>> import numpy as np
>>> xp = [1, 2, 3]
>>> fp = [3, 2, 0]
>>> np.interp(2.5, xp, fp)
1.0
>>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
array([3.  , 3.  , 2.5 , 0.56, 0.  ])
>>> UNDEF = -99.0
>>> np.interp(3.14, xp, fp, right=UNDEF)
-99.0
>>> x = np.linspace(0, 2*np.pi, 10)
>>> y = np.sin(x)
>>> xvals = np.linspace(0, 2*np.pi, 50)
>>> yinterp = np.interp(xvals, x, y)
>>> import matplotlib.pyplot as plt
>>> plt.plot(x, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.plot(xvals, yinterp, '-x')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.show()
>>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
>>> xp = [190, -190, 350, -350]
>>> fp = [5, 10, 3, 4]
>>> np.interp(x, xp, fp, period=360)
array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])
>>> x = [1.5, 4.0]
>>> xp = [2,3,5]
>>> fp = [1.0j, 0, 2+3j]
>>> np.interp(x, xp, fp)
array([0.+1.j , 1.+1.5j])"
numpy.bitwise_count,"Computes the number of 1-bits in the absolute value of x.
Analogous to the builtin int.bit_count or popcount in C++.","[{'Parameters': [{'name': 'x', 'type': 'array_like, unsigned int', 'description': 'Input array.'}, {'name': 'out', 'type': 'ndarray, None, or tuple of ndarray and None, optional', 'description': 'A location into which the result is stored. If provided, it must havea shape that the inputs broadcast to. If not provided or None,a freshly-allocated array is returned. A tuple (possible only as akeyword argument) must have length equal to the number of outputs.'}, {'name': 'where', 'type': 'array_like, optional', 'description': 'This condition is broadcast over the input. At locations where thecondition is True, the out array will be set to the ufunc result.Elsewhere, the out array will retain its original value.Note that if an uninitialized out array is created via the defaultout=None, locations within it where the condition is False willremain uninitialized.'}, {'name': '**kwargs', 'type': None, 'description': 'For other keyword-only arguments, see theufunc docs.'}]}, {'Returns': [{'name': 'y', 'type': 'ndarray', 'description': 'The corresponding number of 1-bits in the input.Returns uint8 for all integer typesThis is a scalar if x is a scalar.'}]}]",">>> import numpy as np
>>> np.bitwise_count(1023)
np.uint8(10)
>>> a = np.array([2**i - 1 for i in range(16)])
>>> np.bitwise_count(a)
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15],
      dtype=uint8)"
numpy.sort,Return a sorted copy of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array to be sorted.'}, {'name': 'axis', 'type': 'int or None, optional', 'description': 'Axis along which to sort. If None, the array is flattened beforesorting. The default is -1, which sorts along the last axis.'}, {'name': 'kind', 'type': '{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional', 'description': 'Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’and ‘mergesort’ use timsort or radix sort under the covers and,in general, the actual implementation will vary with data type.The ‘mergesort’ option is retained for backwards compatibility.'}, {'name': 'order', 'type': 'str or list of str, optional', 'description': 'When a is an array with fields defined, this argument specifieswhich fields to compare first, second, etc.  A single field canbe specified as a string, and not all fields need be specified,but unspecified fields will still be used, in the order in whichthey come up in the dtype, to break ties.'}, {'name': 'stable', 'type': 'bool, optional', 'description': ""Sort stability. If True, the returned array will maintainthe relative order of a values which compare as equal.If False or None, this is not guaranteed. Internally,this option selects kind='stable'. Default: None.New in version 2.0.0.""}]}, {'Returns': [{'name': 'sorted_array', 'type': 'ndarray', 'description': 'Array of the same type and shape as a.'}]}]",">>> import numpy as np
>>> a = np.array([[1,4],[3,1]])
>>> np.sort(a)                # sort along the last axis
array([[1, 4],
       [1, 3]])
>>> np.sort(a, axis=None)     # sort the flattened array
array([1, 1, 3, 4])
>>> np.sort(a, axis=0)        # sort along the first axis
array([[1, 1],
       [3, 4]])
>>> dtype = [('name', 'S10'), ('height', float), ('age', int)]
>>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
...           ('Galahad', 1.7, 38)]
>>> a = np.array(values, dtype=dtype)       # create a structured array
>>> np.sort(a, order='height')                        
array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
       ('Lancelot', 1.8999999999999999, 38)],
      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
>>> np.sort(a, order=['age', 'height'])               
array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
       ('Arthur', 1.8, 41)],
      dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])"
numpy.lexsort,Perform an indirect stable sort using a sequence of keys.,"[{'Parameters': [{'name': 'keys', 'type': '(k, m, n, …) array-like', 'description': 'The k keys to be sorted. The last key (e.g, the lastrow if keys is a 2D array) is the primary sort key.Each element of keys along the zeroth axis must bean array-like object of the same shape.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis to be indirectly sorted. By default, sort over the last axisof each sequence. Separate slices along axis sorted overindependently; see last example.'}]}, {'Returns': [{'name': 'indices', 'type': '(m, n, …) ndarray of ints', 'description': 'Array of indices that sort the keys along the specified axis.'}]}]",">>> import numpy as np
>>> surnames =    ('Hertz',    'Galilei', 'Hertz')
>>> first_names = ('Heinrich', 'Galileo', 'Gustav')
>>> ind = np.lexsort((first_names, surnames))
>>> ind
array([1, 2, 0])
>>> [surnames[i] + "", "" + first_names[i] for i in ind]
['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']
>>> a = [1, 5, 1, 4, 3, 4, 4]  # First sequence
>>> b = [9, 4, 0, 4, 0, 2, 1]  # Second sequence
>>> ind = np.lexsort((b, a))  # Sort by `a`, then by `b`
>>> ind
array([2, 0, 4, 6, 5, 3, 1])
>>> [(a[i], b[i]) for i in ind]
[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]
>>> np.argsort((b, a), kind='stable')
array([[2, 4, 6, 5, 1, 3, 0],
       [0, 2, 4, 3, 5, 6, 1]])
>>> x = np.array([(ai, bi) for ai, bi in zip(a, b)],
...              dtype = np.dtype([('x', int), ('y', int)]))
>>> np.argsort(x)  # or np.argsort(x, order=('x', 'y'))
array([2, 0, 4, 6, 5, 3, 1])
>>> arr = np.asarray([b, a])
>>> ind2 = np.lexsort(arr)
>>> np.testing.assert_equal(ind2, ind)
>>> np.testing.assert_equal(np.lexsort(arr, axis=0),
...                         np.lexsort(arr, axis=-1))
>>> x = [[1, 2, 3, 4],
...      [4, 3, 2, 1],
...      [2, 1, 4, 3]]
>>> y = [[2, 2, 1, 1],
...      [1, 2, 1, 2],
...      [1, 1, 2, 1]]
>>> np.lexsort((x, y), axis=1)
array([[2, 3, 0, 1],
       [2, 0, 3, 1],
       [1, 0, 3, 2]])
>>> for i in range(3):
...     print(np.lexsort((x[i], y[i])))
[2 3 0 1]
[2 0 3 1]
[1 0 3 2]"
numpy.argsort,Returns the indices that would sort an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array to sort.'}, {'name': 'axis', 'type': 'int or None, optional', 'description': 'Axis along which to sort.  The default is -1 (the last axis). If None,the flattened array is used.'}, {'name': 'kind', 'type': '{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional', 'description': 'Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’and ‘mergesort’ use timsort under the covers and, in general, theactual implementation will vary with data type. The ‘mergesort’ optionis retained for backwards compatibility.'}, {'name': 'order', 'type': 'str or list of str, optional', 'description': 'When a is an array with fields defined, this argument specifieswhich fields to compare first, second, etc.  A single field canbe specified as a string, and not all fields need be specified,but unspecified fields will still be used, in the order in whichthey come up in the dtype, to break ties.'}, {'name': 'stable', 'type': 'bool, optional', 'description': ""Sort stability. If True, the returned array will maintainthe relative order of a values which compare as equal.If False or None, this is not guaranteed. Internally,this option selects kind='stable'. Default: None.New in version 2.0.0.""}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray, int', 'description': 'Array of indices that sort a along the specified axis.If a is one-dimensional, a[index_array] yields a sorted a.More generally, np.take_along_axis(a, index_array, axis=axis)always yields the sorted a, irrespective of dimensionality.'}]}]",">>> import numpy as np
>>> x = np.array([3, 1, 2])
>>> np.argsort(x)
array([1, 2, 0])
>>> x = np.array([[0, 3], [2, 2]])
>>> x
array([[0, 3],
       [2, 2]])
>>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)
>>> ind
array([[0, 1],
       [1, 0]])
>>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)
array([[0, 2],
       [2, 3]])
>>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)
>>> ind
array([[0, 1],
       [0, 1]])
>>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)
array([[0, 3],
       [2, 2]])
>>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
>>> ind
(array([0, 1, 1, 0]), array([0, 0, 1, 1]))
>>> x[ind]  # same as np.sort(x, axis=None)
array([0, 2, 2, 3])
>>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])
>>> x
array([(1, 0), (0, 1)],
      dtype=[('x', '<i4'), ('y', '<i4')])
>>> np.argsort(x, order=('x','y'))
array([1, 0])
>>> np.argsort(x, order=('y','x'))
array([0, 1])"
numpy.ndarray.sort,method,"[{'Parameters': [{'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to sort. Default is -1, which means sort along thelast axis.'}, {'name': 'kind', 'type': '{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional', 'description': 'Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’and ‘mergesort’ use timsort under the covers and, in general, theactual implementation will vary with datatype. The ‘mergesort’ optionis retained for backwards compatibility.'}, {'name': 'order', 'type': 'str or list of str, optional', 'description': 'When a is an array with fields defined, this argument specifieswhich fields to compare first, second, etc.  A single field canbe specified as a string, and not all fields need be specified,but unspecified fields will still be used, in the order in whichthey come up in the dtype, to break ties.'}]}]",">>> import numpy as np
>>> a = np.array([[1,4], [3,1]])
>>> a.sort(axis=1)
>>> a
array([[1, 4],
       [1, 3]])
>>> a.sort(axis=0)
>>> a
array([[1, 3],
       [1, 4]])
>>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
>>> a.sort(order='y')
>>> a
array([(b'c', 1), (b'a', 2)],
      dtype=[('x', 'S1'), ('y', '<i8')])"
numpy.sort_complex,"Sort a complex array using the real part first, then the imaginary part.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array'}]}, {'Returns': [{'name': 'out', 'type': 'complex ndarray', 'description': 'Always returns a sorted complex array.'}]}]",">>> import numpy as np
>>> np.sort_complex([5, 3, 6, 2, 1])
array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])
>>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])"
numpy.partition,Return a partitioned copy of an array.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array to be sorted.'}, {'name': 'kth', 'type': 'int or sequence of ints', 'description': 'Element index to partition by. The k-th value of the elementwill be in its final sorted position and all smaller elementswill be moved before it and all equal or greater elements behindit. The order of all elements in the partitions is undefined. Ifprovided with a sequence of k-th it will partition all elementsindexed by k-th  of them into their sorted position at once.Deprecated since version 1.22.0: Passing booleans as index is deprecated.'}, {'name': 'axis', 'type': 'int or None, optional', 'description': 'Axis along which to sort. If None, the array is flattened beforesorting. The default is -1, which sorts along the last axis.'}, {'name': 'kind', 'type': '{‘introselect’}, optional', 'description': 'Selection algorithm. Default is ‘introselect’.'}, {'name': 'order', 'type': 'str or list of str, optional', 'description': 'When a is an array with fields defined, this argumentspecifies which fields to compare first, second, etc.  A singlefield can be specified as a string.  Not all fields need bespecified, but unspecified fields will still be used, in theorder in which they come up in the dtype, to break ties.'}]}, {'Returns': [{'name': 'partitioned_array', 'type': 'ndarray', 'description': 'Array of the same type and shape as a.'}]}]",">>> import numpy as np
>>> a = np.array([7, 1, 7, 7, 1, 5, 7, 2, 3, 2, 6, 2, 3, 0])
>>> p = np.partition(a, 4)
>>> p
array([0, 1, 2, 1, 2, 5, 2, 3, 3, 6, 7, 7, 7, 7]) # may vary
>>> p2 = np.partition(a, (4, 8))
>>> p2
array([0, 1, 2, 1, 2, 3, 3, 2, 5, 6, 7, 7, 7, 7])"
numpy.argpartition,"Perform an indirect partition along the given axis using the
algorithm specified by the kind keyword. It returns an array of
indices of the same shape as a that index data along the given
axis in partitioned order.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Array to sort.'}, {'name': 'kth', 'type': 'int or sequence of ints', 'description': 'Element index to partition by. The k-th element will be in itsfinal sorted position and all smaller elements will be movedbefore it and all larger elements behind it. The order of allelements in the partitions is undefined. If provided with asequence of k-th it will partition all of them into their sortedposition at once.Deprecated since version 1.22.0: Passing booleans as index is deprecated.'}, {'name': 'axis', 'type': 'int or None, optional', 'description': 'Axis along which to sort. The default is -1 (the last axis). IfNone, the flattened array is used.'}, {'name': 'kind', 'type': '{‘introselect’}, optional', 'description': 'Selection algorithm. Default is ‘introselect’'}, {'name': 'order', 'type': 'str or list of str, optional', 'description': 'When a is an array with fields defined, this argumentspecifies which fields to compare first, second, etc. A singlefield can be specified as a string, and not all fields need bespecified, but unspecified fields will still be used, in theorder in which they come up in the dtype, to break ties.'}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray, int', 'description': 'Array of indices that partition a along the specified axis.If a is one-dimensional, a[index_array] yields a partitioned a.More generally, np.take_along_axis(a, index_array, axis=axis)always yields the partitioned a, irrespective of dimensionality.'}]}]",">>> import numpy as np
>>> x = np.array([3, 4, 2, 1])
>>> x[np.argpartition(x, 3)]
array([2, 1, 3, 4]) # may vary
>>> x[np.argpartition(x, (1, 3))]
array([1, 2, 3, 4]) # may vary
>>> x = [3, 4, 2, 1]
>>> np.array(x)[np.argpartition(x, 3)]
array([2, 1, 3, 4]) # may vary
>>> x = np.array([[3, 4, 2], [1, 3, 1]])
>>> index_array = np.argpartition(x, kth=1, axis=-1)
>>> # below is the same as np.partition(x, kth=1)
>>> np.take_along_axis(x, index_array, axis=-1)
array([[2, 3, 4],
       [1, 1, 3]])"
numpy.argmax,Returns the indices of the maximum values along an axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'By default, the index is into the flattened array, otherwisealong the specified axis.'}, {'name': 'out', 'type': 'array, optional', 'description': 'If provided, the result will be inserted into this array. It shouldbe of the appropriate shape and dtype.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.New in version 1.22.0.'}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray of ints', 'description': 'Array of indices into the array. It has the same shape as a.shapewith the dimension along axis removed. If keepdims is set to True,then the size of axis will be 1 with the resulting array having sameshape as a.shape.'}]}]",">>> import numpy as np
>>> a = np.arange(6).reshape(2,3) + 10
>>> a
array([[10, 11, 12],
       [13, 14, 15]])
>>> np.argmax(a)
5
>>> np.argmax(a, axis=0)
array([1, 1, 1])
>>> np.argmax(a, axis=1)
array([2, 2])
>>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)
>>> ind
(1, 2)
>>> a[ind]
15
>>> b = np.arange(6)
>>> b[1] = 5
>>> b
array([0, 5, 2, 3, 4, 5])
>>> np.argmax(b)  # Only the first occurrence is returned.
1
>>> x = np.array([[4,2,3], [1,0,3]])
>>> index_array = np.argmax(x, axis=-1)
>>> # Same as np.amax(x, axis=-1, keepdims=True)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
array([[4],
       [3]])
>>> # Same as np.amax(x, axis=-1)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1),
...     axis=-1).squeeze(axis=-1)
array([4, 3])
>>> x = np.arange(24).reshape((2, 3, 4))
>>> res = np.argmax(x, axis=1, keepdims=True)
>>> res.shape
(2, 1, 4)"
numpy.nanargmax,"Return the indices of the maximum values in the specified axis ignoring
NaNs. For all-NaN slices ValueError is raised. Warning: the
results cannot be trusted if a slice contains only NaNs and -Infs.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to operate.  By default flattened input is used.'}, {'name': 'out', 'type': 'array, optional', 'description': 'If provided, the result will be inserted into this array. It shouldbe of the appropriate shape and dtype.New in version 1.22.0.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.New in version 1.22.0.'}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray', 'description': 'An array of indices or a single index value.'}]}]",">>> import numpy as np
>>> a = np.array([[np.nan, 4], [2, 3]])
>>> np.argmax(a)
0
>>> np.nanargmax(a)
1
>>> np.nanargmax(a, axis=0)
array([1, 0])
>>> np.nanargmax(a, axis=1)
array([1, 1])"
numpy.argmin,Returns the indices of the minimum values along an axis.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'By default, the index is into the flattened array, otherwisealong the specified axis.'}, {'name': 'out', 'type': 'array, optional', 'description': 'If provided, the result will be inserted into this array. It shouldbe of the appropriate shape and dtype.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.New in version 1.22.0.'}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray of ints', 'description': 'Array of indices into the array. It has the same shape as a.shapewith the dimension along axis removed. If keepdims is set to True,then the size of axis will be 1 with the resulting array having sameshape as a.shape.'}]}]",">>> import numpy as np
>>> a = np.arange(6).reshape(2,3) + 10
>>> a
array([[10, 11, 12],
       [13, 14, 15]])
>>> np.argmin(a)
0
>>> np.argmin(a, axis=0)
array([0, 0, 0])
>>> np.argmin(a, axis=1)
array([0, 0])
>>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
>>> ind
(0, 0)
>>> a[ind]
10
>>> b = np.arange(6) + 10
>>> b[4] = 10
>>> b
array([10, 11, 12, 13, 10, 15])
>>> np.argmin(b)  # Only the first occurrence is returned.
0
>>> x = np.array([[4,2,3], [1,0,3]])
>>> index_array = np.argmin(x, axis=-1)
>>> # Same as np.amin(x, axis=-1, keepdims=True)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
array([[2],
       [0]])
>>> # Same as np.amax(x, axis=-1)
>>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1),
...     axis=-1).squeeze(axis=-1)
array([2, 0])
>>> x = np.arange(24).reshape((2, 3, 4))
>>> res = np.argmin(x, axis=1, keepdims=True)
>>> res.shape
(2, 1, 4)"
numpy.nanargmin,"Return the indices of the minimum values in the specified axis ignoring
NaNs. For all-NaN slices ValueError is raised. Warning: the results
cannot be trusted if a slice contains only NaNs and Infs.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}, {'name': 'axis', 'type': 'int, optional', 'description': 'Axis along which to operate.  By default flattened input is used.'}, {'name': 'out', 'type': 'array, optional', 'description': 'If provided, the result will be inserted into this array. It shouldbe of the appropriate shape and dtype.New in version 1.22.0.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes which are reduced are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the array.New in version 1.22.0.'}]}, {'Returns': [{'name': 'index_array', 'type': 'ndarray', 'description': 'An array of indices or a single index value.'}]}]",">>> import numpy as np
>>> a = np.array([[np.nan, 4], [2, 3]])
>>> np.argmin(a)
0
>>> np.nanargmin(a)
2
>>> np.nanargmin(a, axis=0)
array([1, 1])
>>> np.nanargmin(a, axis=1)
array([1, 0])"
numpy.argwhere,"Find the indices of array elements that are non-zero, grouped by element.","[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}]}, {'Returns': [{'name': 'index_array', 'type': '(N, a.ndim) ndarray', 'description': 'Indices of elements that are non-zero. Indices are grouped by element.This array will have shape (N, a.ndim) where N is the number ofnon-zero items.'}]}]",">>> import numpy as np
>>> x = np.arange(6).reshape(2,3)
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.argwhere(x>1)
array([[0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])"
numpy.nonzero,Return the indices of the elements that are non-zero.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input array.'}]}, {'Returns': [{'name': 'tuple_of_arrays', 'type': 'tuple', 'description': 'Indices of elements that are non-zero.'}]}]",">>> import numpy as np
>>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
>>> x
array([[3, 0, 0],
       [0, 4, 0],
       [5, 6, 0]])
>>> np.nonzero(x)
(array([0, 1, 2, 2]), array([0, 1, 0, 1]))
>>> x[np.nonzero(x)]
array([3, 4, 5, 6])
>>> np.transpose(np.nonzero(x))
array([[0, 0],
       [1, 1],
       [2, 0],
       [2, 1]])
>>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> a > 3
array([[False, False, False],
       [ True,  True,  True],
       [ True,  True,  True]])
>>> np.nonzero(a > 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
>>> a[np.nonzero(a > 3)]
array([4, 5, 6, 7, 8, 9])
>>> a[a > 3]  # prefer this spelling
array([4, 5, 6, 7, 8, 9])
>>> (a > 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))"
numpy.flatnonzero,Return indices that are non-zero in the flattened version of a.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'Input data.'}]}, {'Returns': [{'name': 'res', 'type': 'ndarray', 'description': 'Output array, containing the indices of the elements of a.ravel()that are non-zero.'}]}]",">>> import numpy as np
>>> x = np.arange(-2, 3)
>>> x
array([-2, -1,  0,  1,  2])
>>> np.flatnonzero(x)
array([0, 1, 3, 4])
>>> x.ravel()[np.flatnonzero(x)]
array([-2, -1,  1,  2])"
numpy.where,Return elements chosen from x or y depending on condition.,"[{'Parameters': [{'name': 'condition', 'type': 'array_like, bool', 'description': 'Where True, yield x, otherwise yield y.'}, {'name': 'x, y', 'type': 'array_like', 'description': 'Values from which to choose. x, y and condition need to bebroadcastable to some shape.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray', 'description': 'An array with elements from x where condition is True, and elementsfrom y elsewhere.'}]}]",">>> import numpy as np
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.where(a < 5, a, 10*a)
array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
>>> np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
       [3, 4]])
>>> x, y = np.ogrid[:3, :4]
>>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
array([[10,  0,  0,  0],
       [10, 11,  1,  1],
       [10, 11, 12,  2]])
>>> a = np.array([[0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6]])
>>> np.where(a < 4, a, -1)  # -1 is broadcast
array([[ 0,  1,  2],
       [ 0,  2, -1],
       [ 0,  3, -1]])"
numpy.searchsorted,Find indices where elements should be inserted to maintain order.,"[{'Parameters': [{'name': 'a', 'type': '1-D array_like', 'description': 'Input array. If sorter is None, then it must be sorted inascending order, otherwise sorter must be an array of indicesthat sort it.'}, {'name': 'v', 'type': 'array_like', 'description': 'Values to insert into a.'}, {'name': 'side', 'type': '{‘left’, ‘right’}, optional', 'description': 'If ‘left’, the index of the first suitable location found is given.If ‘right’, return the last such index.  If there is no suitableindex, return either 0 or N (where N is the length of a).'}, {'name': 'sorter', 'type': '1-D array_like, optional', 'description': 'Optional array of integer indices that sort array a into ascendingorder. They are typically the result of argsort.'}]}, {'Returns': [{'name': 'indices', 'type': 'int or array of ints', 'description': 'Array of insertion points with the same shape as v,or an integer if v is a scalar.'}]}]",">>> import numpy as np
>>> np.searchsorted([11,12,13,14,15], 13)
2
>>> np.searchsorted([11,12,13,14,15], 13, side='right')
3
>>> np.searchsorted([11,12,13,14,15], [-10, 20, 12, 13])
array([0, 5, 1, 2])
>>> a = np.array([40, 10, 20, 30])
>>> sorter = np.argsort(a)
>>> sorter
array([1, 2, 3, 0])  # Indices that would sort the array 'a'
>>> result = np.searchsorted(a, 25, sorter=sorter)
>>> result
2
>>> a[sorter[result]]
30  # The element at index 2 of the sorted array is 30."
numpy.extract,Return the elements of an array that satisfy some condition.,"[{'Parameters': [{'name': 'condition', 'type': 'array_like', 'description': 'An array whose nonzero or True entries indicate the elements of arrto extract.'}, {'name': 'arr', 'type': 'array_like', 'description': 'Input array of the same size as condition.'}]}, {'Returns': [{'name': 'extract', 'type': 'ndarray', 'description': 'Rank 1 array of values from arr where condition is True.'}]}]",">>> import numpy as np
>>> arr = np.arange(12).reshape((3, 4))
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> condition = np.mod(arr, 3)==0
>>> condition
array([[ True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False]])
>>> np.extract(condition, arr)
array([0, 3, 6, 9])
>>> arr[condition]
array([0, 3, 6, 9])"
numpy.count_nonzero,Counts the number of non-zero values in the array a.,"[{'Parameters': [{'name': 'a', 'type': 'array_like', 'description': 'The array for which to count non-zeros.'}, {'name': 'axis', 'type': 'int or tuple, optional', 'description': 'Axis or tuple of axes along which to count non-zeros.Default is None, meaning that non-zeros will be countedalong a flattened version of a.'}, {'name': 'keepdims', 'type': 'bool, optional', 'description': 'If this is set to True, the axes that are counted are leftin the result as dimensions with size one. With this option,the result will broadcast correctly against the input array.'}]}, {'Returns': [{'name': 'count', 'type': 'int or array of int', 'description': 'Number of non-zero values in the array along a given axis.Otherwise, the total number of non-zero values in the arrayis returned.'}]}]",">>> import numpy as np
>>> np.count_nonzero(np.eye(4))
4
>>> a = np.array([[0, 1, 7, 0],
...               [3, 0, 2, 19]])
>>> np.count_nonzero(a)
5
>>> np.count_nonzero(a, axis=0)
array([1, 1, 2, 1])
>>> np.count_nonzero(a, axis=1)
array([2, 3])
>>> np.count_nonzero(a, axis=1, keepdims=True)
array([[2],
       [3]])"
numpy.polynomial.hermite_e.HermiteE,An HermiteE series class.,"[{'Parameters': [{'name': 'coef', 'type': 'array_like', 'description': 'HermiteE coefficients in order of increasing degree, i.e,(1, 2, 3) gives 1*He_0(x) + 2*He_1(X) + 3*He_2(x).'}, {'name': 'domain', 'type': '(2,) array_like, optional', 'description': 'Domain to use. The interval [domain[0], domain[1]] is mappedto the interval [window[0], window[1]] by shifting and scaling.The default value is [-1., 1.].'}, {'name': 'window', 'type': '(2,) array_like, optional', 'description': 'Window, see domain for its use. The default value is [-1., 1.].'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol used to represent the independent variable in stringrepresentations of the polynomial expression, e.g. for printing.The symbol must be a valid Python identifier. Default value is ‘x’.New in version 1.24.'}]}, {'Attributes': [{'name': 'symbol', 'type': None, 'description': ''}]}]",
numpy.polynomial.hermite_e.HermiteE.__call__,method,[],
numpy.polynomial.hermite_e.HermiteE.basis,method,"[{'Parameters': [{'name': 'deg', 'type': 'int', 'description': 'Degree of the basis polynomial for the series. Must be >= 0.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series with the coefficient of the deg term set to one andall others zero.'}]}]",
numpy.polynomial.hermite_e.HermiteE.cast,method,"[{'Parameters': [{'name': 'series', 'type': 'series', 'description': 'The series instance to be converted.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series of the same kind as the calling class and equal toseries when evaluated.'}]}]",
numpy.polynomial.hermite_e.HermiteE.convert,method,"[{'Parameters': [{'name': 'domain', 'type': 'array_like, optional', 'description': 'The domain of the converted series. If the value is None,the default domain of kind is used.'}, {'name': 'kind', 'type': 'class, optional', 'description': 'The polynomial series type class to which the current instanceshould be converted. If kind is None, then the class of thecurrent instance is used.'}, {'name': 'window', 'type': 'array_like, optional', 'description': 'The window of the converted series. If the value is None,the default window of kind is used.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'The returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.'}]}]",
numpy.polynomial.hermite_e.HermiteE.copy,method,"[{'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Copy of self.'}]}]",
numpy.polynomial.hermite_e.HermiteE.cutdeg,method,"[{'Parameters': [{'name': 'deg', 'type': 'non-negative int', 'description': 'The series is reduced to degree deg by discarding the highorder terms. The value of deg must be a non-negative integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with reduced degree.'}]}]",
numpy.polynomial.hermite_e.HermiteE.degree,method,"[{'Returns': [{'name': 'degree', 'type': 'int', 'description': 'Degree of the series, one less than the number of coefficients.'}]}]",">>> poly = np.polynomial.Polynomial([1, 7, 4])
>>> print(poly)
1.0 + 7.0·x + 4.0·x²
>>> poly.degree()
2
>>> poly = np.polynomial.Polynomial([1, 7, 0])
>>> print(poly)
1.0 + 7.0·x + 0.0·x²
>>> poly.degree()
2
>>> poly.trim().degree()
1"
numpy.polynomial.hermite_e.HermiteE.deriv,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'Find the derivative of order m.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the derivative. The domain is the sameas the domain of the differentiated series.'}]}]",
numpy.polynomial.hermite_e.HermiteE.fit,method,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (M,)', 'description': 'x-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'y', 'type': 'array_like, shape (M,)', 'description': 'y-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'deg', 'type': 'int or 1-D array_like', 'description': 'Degree(s) of the fitting polynomials. If deg is a single integerall terms up to and including the deg’th term are included in thefit. For NumPy versions >= 1.11.0 a list of integers specifying thedegrees of the terms to include may be used instead.'}, {'name': 'domain', 'type': '{None, [beg, end], []}, optional', 'description': 'Domain to use for the returned series. If None,then a minimal domain that covers the points x is chosen.  If[] the class domain is used. The default value was theclass domain in NumPy 1.4 and None in later versions.The [] option was added in numpy 1.5.0.'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Relative condition number of the fit. Singular values smallerthan this relative to the largest singular value will beignored. The default value is len(x)*eps, where eps is therelative precision of the float type, about 2e-16 in mostcases.'}, {'name': 'full', 'type': 'bool, optional', 'description': 'Switch determining nature of return value. When it is False(the default) just the coefficients are returned, when Truediagnostic information from the singular value decomposition isalso returned.'}, {'name': 'w', 'type': 'array_like, shape (M,), optional', 'description': 'Weights. If not None, the weight w[i] applies to the unsquaredresidual y[i] - y_hat[i] at x[i]. Ideally the weights arechosen so that the errors of the products w[i]*y[i] all havethe same variance.  When using inverse-variance weighting, usew[i] = 1/sigma(y[i]).  The default value is None.'}, {'name': 'window', 'type': '{[beg, end]}, optional', 'description': 'Window to use for the returned series. The defaultvalue is the default class domain'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.'}, {'name': '[resid, rank, sv, rcond]', 'type': 'list', 'description': 'These values are only returned if full == Trueresid – sum of squared residuals of the least squares fitrank – the numerical rank of the scaled Vandermonde matrixsv – singular values of the scaled Vandermonde matrixrcond – value of rcond.For more details, see linalg.lstsq.'}]}]",
numpy.polynomial.hermite_e.HermiteE.fromroots,method,"[{'Parameters': [{'name': 'roots', 'type': 'array_like', 'description': 'List of roots.'}, {'name': 'domain', 'type': '{[], None, array_like}, optional', 'description': 'Domain for the resulting series. If None the domain is theinterval from the smallest root to the largest. If [] thedomain is the class domain. The default is [].'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'Window for the returned series. If None the class window isused. The default is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series with the specified roots.'}]}]",
numpy.polynomial.hermite_e.HermiteE.has_samecoef,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the coef attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the coefficients are the same, False otherwise.'}]}]",
numpy.polynomial.hermite_e.HermiteE.has_samedomain,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the domain attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the domains are the same, False otherwise.'}]}]",
numpy.polynomial.hermite_e.HermiteE.has_sametype,method,"[{'Parameters': [{'name': 'other', 'type': 'object', 'description': 'Class instance.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if other is same class as self'}]}]",
numpy.polynomial.hermite_e.HermiteE.has_samewindow,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the window attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the windows are the same, False otherwise.'}]}]",
numpy.polynomial.hermite_e.HermiteE.identity,method,"[{'Parameters': [{'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series of representing the identity.'}]}]",
numpy.polynomial.hermite_e.HermiteE.integ,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'The number of integrations to perform.'}, {'name': 'k', 'type': 'array_like', 'description': 'Integration constants. The first constant is applied to thefirst integration, the second to the second, and so on. Thelist of values must less than or equal to m in length and anymissing values are set to zero.'}, {'name': 'lbnd', 'type': 'Scalar', 'description': 'The lower bound of the definite integral.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the integral. The domain is the sameas the domain of the integrated series.'}]}]",
numpy.polynomial.hermite_e.HermiteE.linspace,method,"[{'Parameters': [{'name': 'n', 'type': 'int, optional', 'description': 'Number of point pairs to return. The default value is 100.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If not None, the specified domain is used instead of that ofthe calling instance. It should be of the form [beg,end].The default is None which case the class domain is used.'}]}, {'Returns': [{'name': 'x, y', 'type': 'ndarray', 'description': 'x is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.'}]}]",
numpy.polynomial.hermite_e.HermiteE.mapparms,method,"[{'Returns': [{'name': 'off, scl', 'type': 'float or complex', 'description': 'The mapping function is defined by off + scl*x.'}]}]",
numpy.polynomial.hermite_e.HermiteE.roots,method,"[{'Returns': [{'name': 'roots', 'type': 'ndarray', 'description': 'Array containing the roots of the series.'}]}]",
numpy.polynomial.hermite_e.HermiteE.trim,method,"[{'Parameters': [{'name': 'tol', 'type': 'non-negative number.', 'description': 'All trailing coefficients less than tol will be removed.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with trimmed coefficients.'}]}]",
numpy.polynomial.hermite_e.HermiteE.truncate,method,"[{'Parameters': [{'name': 'size', 'type': 'positive int', 'description': 'The series is reduced to length size by discarding the highdegree terms. The value of size must be a positive integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with truncated coefficients.'}]}]",
class numpy.random.PCG64DXSM(seed=None),BitGenerator for the PCG-64 DXSM pseudo-random number generator.,"[{'Parameters': [{'name': 'seed', 'type': '{None, int, array_like[ints], SeedSequence}, optional', 'description': 'A seed to initialize the BitGenerator. If None, then fresh,unpredictable entropy will be pulled from the OS. If an int orarray_like[ints] is passed, then it will be passed toSeedSequence to derive the initial BitGenerator state. One may alsopass in a SeedSequence instance.'}]}]",">>> from numpy.random import Generator, PCG64DXSM, SeedSequence
>>> sg = SeedSequence(1234)
>>> rg = [Generator(PCG64DXSM(s)) for s in sg.spawn(10)]"
numpy.random.PCG64DXSM.state,attribute,"[{'Returns': [{'name': 'state', 'type': 'dict', 'description': 'Dictionary containing the information required to describe thestate of the PRNG'}]}]",
numpy.random.PCG64DXSM.advance,method,"[{'Parameters': [{'name': 'delta', 'type': 'integer, positive', 'description': 'Number of draws to advance the RNG. Must be less than thesize state variable in the underlying RNG.'}]}, {'Returns': [{'name': 'self', 'type': 'PCG64', 'description': 'RNG advanced delta steps'}]}]",
numpy.random.PCG64DXSM.jumped,method,"[{'Parameters': [{'name': 'jumps', 'type': 'integer, positive', 'description': 'Number of times to jump the state of the bit generator returned'}]}, {'Returns': [{'name': 'bit_generator', 'type': 'PCG64DXSM', 'description': 'New instance of generator jumped iter times'}]}]",
numpy.random.PCG64DXSM.cffi,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.random.PCG64DXSM.ctypes,attribute,"[{'Returns': [{'name': 'interface', 'type': 'namedtuple', 'description': 'Named tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct'}]}]",
numpy.can_cast,"Returns True if cast between data types can occur according to the
casting rule.","[{'Parameters': [{'name': 'from_', 'type': 'dtype, dtype specifier, NumPy scalar, or array', 'description': 'Data type, NumPy scalar, or array to cast from.'}, {'name': 'to', 'type': 'dtype or dtype specifier', 'description': 'Data type to cast to.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional', 'description': 'Controls what kind of data casting may occur.‘no’ means the data types should not be cast at all.‘equiv’ means only byte-order changes are allowed.‘safe’ means only casts which can preserve values are allowed.‘same_kind’ means only safe casts or casts within a kind,like float64 to float32, are allowed.‘unsafe’ means any data conversions may be done.'}]}, {'Returns': [{'name': 'out', 'type': 'bool', 'description': 'True if cast can occur according to the casting rule.'}]}]",">>> import numpy as np
>>> np.can_cast(np.int32, np.int64)
True
>>> np.can_cast(np.float64, complex)
True
>>> np.can_cast(complex, float)
False
>>> np.can_cast('i8', 'f8')
True
>>> np.can_cast('i8', 'f4')
False
>>> np.can_cast('i4', 'S4')
False"
numpy.promote_types,"Returns the data type with the smallest size and smallest scalar
kind to which both type1 and type2 may be safely cast.
The returned data type is always considered “canonical”, this mainly
means that the promoted dtype will always be in native byte order.","[{'Parameters': [{'name': 'type1', 'type': 'dtype or dtype specifier', 'description': 'First data type.'}, {'name': 'type2', 'type': 'dtype or dtype specifier', 'description': 'Second data type.'}]}, {'Returns': [{'name': 'out', 'type': 'dtype', 'description': 'The promoted data type.'}]}]",">>> import numpy as np
>>> np.promote_types('f4', 'f8')
dtype('float64')
>>> np.promote_types('i8', 'f4')
dtype('float64')
>>> np.promote_types('>i8', '<c8')
dtype('complex128')
>>> np.promote_types('i4', 'S8')
dtype('S11')
>>> p = np.promote_types
>>> p('S', p('i1', 'u1'))
dtype('S6')
>>> p(p('S', 'i1'), 'u1')
dtype('S4')"
numpy.min_scalar_type,"For scalar a, returns the data type with the smallest size
and smallest scalar kind which can hold its value.  For non-scalar
array a, returns the vector’s dtype unmodified.","[{'Parameters': [{'name': 'a', 'type': 'scalar or array_like', 'description': 'The value whose minimal data type is to be found.'}]}, {'Returns': [{'name': 'out', 'type': 'dtype', 'description': 'The minimal data type.'}]}]",">>> import numpy as np
>>> np.min_scalar_type(10)
dtype('uint8')
>>> np.min_scalar_type(-260)
dtype('int16')
>>> np.min_scalar_type(3.1)
dtype('float16')
>>> np.min_scalar_type(1e50)
dtype('float64')
>>> np.min_scalar_type(np.arange(4,dtype='f8'))
dtype('float64')"
numpy.result_type,"Returns the type that results from applying the NumPy
type promotion rules to the arguments.","[{'Parameters': [{'name': 'arrays_and_dtypes', 'type': 'list of arrays and dtypes', 'description': 'The operands of some operation whose result type is needed.'}]}, {'Returns': [{'name': 'out', 'type': 'dtype', 'description': 'The result type.'}]}]",">>> import numpy as np
>>> np.result_type(3, np.arange(7, dtype='i1'))
dtype('int8')
>>> np.result_type('i4', 'c8')
dtype('complex128')
>>> np.result_type(3.0, -2)
dtype('float64')"
numpy.common_type,Return a scalar type which is common to the input arrays.,"[{'Parameters': [{'name': 'array1, array2, …', 'type': 'ndarrays', 'description': 'Input arrays.'}]}, {'Returns': [{'name': 'out', 'type': 'data type code', 'description': 'Data type code.'}]}]",">>> np.common_type(np.arange(2, dtype=np.float32))
<class 'numpy.float32'>
>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))
<class 'numpy.float64'>
>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))
<class 'numpy.complex128'>"
numpy.dtype,Create a data type object.,"[{'Parameters': [{'name': 'dtype', 'type': None, 'description': 'Object to be converted to a data type object.'}, {'name': 'align', 'type': 'bool, optional', 'description': 'Add padding to the fields to match what a C compiler would outputfor a similar C-struct. Can be True only if obj is a dictionaryor a comma-separated string. If a struct dtype is being created,this also sets a sticky alignment flag isalignedstruct.'}, {'name': 'copy', 'type': 'bool, optional', 'description': 'Make a new copy of the data-type object. If False, the resultmay just be a reference to a built-in data-type object.'}, {'name': 'metadata', 'type': 'dict, optional', 'description': 'An optional dictionary with dtype metadata.'}]}, {'Attributes': [{'name': 'alignment', 'type': None, 'description': 'The required alignment (bytes) of this data-type according to the compiler.'}, {'name': 'base', 'type': None, 'description': 'Returns dtype for the base element of the subarrays, regardless of their dimension or shape.'}, {'name': 'byteorder', 'type': None, 'description': 'A character indicating the byte-order of this data-type object.'}, {'name': 'char', 'type': None, 'description': 'A unique character code for each of the 21 different built-in types.'}, {'name': 'descr', 'type': None, 'description': '__array_interface__ description of the data-type.'}, {'name': 'fields', 'type': None, 'description': 'Dictionary of named fields defined for this data type, or None.'}, {'name': 'flags', 'type': None, 'description': 'Bit-flags describing how this data type is to be interpreted.'}, {'name': 'hasobject', 'type': None, 'description': 'Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.'}, {'name': 'isalignedstruct', 'type': None, 'description': 'Boolean indicating whether the dtype is a struct which maintains field alignment.'}, {'name': 'isbuiltin', 'type': None, 'description': 'Integer indicating how this dtype relates to the built-in dtypes.'}, {'name': 'isnative', 'type': None, 'description': 'Boolean indicating whether the byte order of this dtype is native to the platform.'}, {'name': 'itemsize', 'type': None, 'description': 'The element size of this data-type object.'}, {'name': 'kind', 'type': None, 'description': 'A character code (one of ‘biufcmMOSUV’) identifying the general kind of data.'}, {'name': 'metadata', 'type': None, 'description': 'Either None or a readonly dictionary of metadata (mappingproxy).'}, {'name': 'name', 'type': None, 'description': 'A bit-width name for this data-type.'}, {'name': 'names', 'type': None, 'description': 'Ordered list of field names, or None if there are no fields.'}, {'name': 'ndim', 'type': None, 'description': 'Number of dimensions of the sub-array if this data type describes a sub-array, and 0 otherwise.'}, {'name': 'num', 'type': None, 'description': 'A unique number for each of the 21 different built-in types.'}, {'name': 'shape', 'type': None, 'description': 'Shape tuple of the sub-array if this data type describes a sub-array, and () otherwise.'}, {'name': 'str', 'type': None, 'description': 'The array-protocol typestring of this data-type object.'}, {'name': 'subdtype', 'type': None, 'description': 'Tuple (item_dtype, shape) if this dtype describes a sub-array, and None otherwise.'}, {'name': 'type', 'type': None, 'description': ''}]}]",">>> import numpy as np
>>> np.dtype(np.int16)
dtype('int16')
>>> np.dtype([('f1', np.int16)])
dtype([('f1', '<i2')])
>>> np.dtype([('f1', [('f1', np.int16)])])
dtype([('f1', [('f1', '<i2')])])
>>> np.dtype([('f1', np.uint64), ('f2', np.int32)])
dtype([('f1', '<u8'), ('f2', '<i4')])
>>> np.dtype([('a','f8'),('b','S10')])
dtype([('a', '<f8'), ('b', 'S10')])
>>> np.dtype(""i4, (2,3)f8"")
dtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])
>>> np.dtype([('hello',(np.int64,3)),('world',np.void,10)])
dtype([('hello', '<i8', (3,)), ('world', 'V10')])
>>> np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))
dtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))
>>> np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})
dtype([('gender', 'S1'), ('age', 'u1')])
>>> np.dtype({'surname':('S25',0),'age':(np.uint8,25)})
dtype([('surname', 'S25'), ('age', 'u1')])"
numpy.rec.format_parser,"Class to convert formats, names, titles description to a dtype.","[{'Parameters': [{'name': 'formats', 'type': 'str or list of str', 'description': ""The format description, either specified as a string withcomma-separated format descriptions in the form 'f8, i4, S5', ora list of format description strings  in the form['f8', 'i4', 'S5'].""}, {'name': 'names', 'type': 'str or list/tuple of str', 'description': ""The field names, either specified as a comma-separated string in theform 'col1, col2, col3', or as a list or tuple of strings in theform ['col1', 'col2', 'col3'].An empty list can be used, in that case default field names(‘f0’, ‘f1’, …) are used.""}, {'name': 'titles', 'type': 'sequence', 'description': 'Sequence of title strings. An empty list can be used to leave titlesout.'}, {'name': 'aligned', 'type': 'bool, optional', 'description': 'If True, align the fields by padding as the C-compiler would.Default is False.'}, {'name': 'byteorder', 'type': 'str, optional', 'description': 'If specified, all the fields will be changed to theprovided byte-order.  Otherwise, the default byte-order isused. For all available string specifiers, see dtype.newbyteorder.'}]}, {'Attributes': [{'name': 'dtype', 'type': 'dtype', 'description': 'The converted data-type.'}]}]",">>> import numpy as np
>>> np.rec.format_parser(['<f8', '<i4'], ['col1', 'col2'],
...                      ['T1', 'T2']).dtype
dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4')])
>>> np.rec.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],
...                      []).dtype
dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '<S5')])
>>> np.rec.format_parser(['<f8', '<i4', '<a5'], [], []).dtype
dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', 'S5')])"
numpy.finfo,Machine limits for floating point types.,"[{'Parameters': [{'name': 'dtype', 'type': 'float, dtype, or instance', 'description': 'Kind of floating point or complex floating pointdata-type about which to get information.'}]}, {'Attributes': [{'name': 'bits', 'type': 'int', 'description': 'The number of bits occupied by the type.'}, {'name': 'dtype', 'type': 'dtype', 'description': 'Returns the dtype for which finfo returns information. For complexinput, the returned dtype is the associated float* dtype for itsreal and complex components.'}, {'name': 'eps', 'type': 'float', 'description': 'The difference between 1.0 and the next smallest representable floatlarger than 1.0. For example, for 64-bit binary floats in the IEEE-754standard, eps = 2**-52, approximately 2.22e-16.'}, {'name': 'epsneg', 'type': 'float', 'description': 'The difference between 1.0 and the next smallest representable floatless than 1.0. For example, for 64-bit binary floats in the IEEE-754standard, epsneg = 2**-53, approximately 1.11e-16.'}, {'name': 'iexp', 'type': 'int', 'description': 'The number of bits in the exponent portion of the floating pointrepresentation.'}, {'name': 'machep', 'type': 'int', 'description': 'The exponent that yields eps.'}, {'name': 'max', 'type': 'floating point number of the appropriate type', 'description': 'The largest representable number.'}, {'name': 'maxexp', 'type': 'int', 'description': 'The smallest positive power of the base (2) that causes overflow.'}, {'name': 'min', 'type': 'floating point number of the appropriate type', 'description': 'The smallest representable number, typically -max.'}, {'name': 'minexp', 'type': 'int', 'description': 'The most negative power of the base (2) consistent with therebeing no leading 0’s in the mantissa.'}, {'name': 'negep', 'type': 'int', 'description': 'The exponent that yields epsneg.'}, {'name': 'nexp', 'type': 'int', 'description': 'The number of bits in the exponent including its sign and bias.'}, {'name': 'nmant', 'type': 'int', 'description': 'The number of bits in the mantissa.'}, {'name': 'precision', 'type': 'int', 'description': 'The approximate number of decimal digits to which this kind offloat is precise.'}, {'name': 'resolution', 'type': 'floating point number of the appropriate type', 'description': 'The approximate decimal resolution of this type, i.e.,10**-precision.'}, {'name': 'tinyfloat', 'type': 'float', 'description': 'Return the value for tiny, alias of smallest_normal.'}, {'name': 'smallest_normalfloat', 'type': 'float', 'description': 'Return the value for the smallest normal.'}, {'name': 'smallest_subnormal', 'type': 'float', 'description': 'The smallest positive floating point number with 0 as leading bit inthe mantissa following IEEE-754.'}]}]",">>> import numpy as np
>>> np.finfo(np.float64).dtype
dtype('float64')
>>> np.finfo(np.complex64).dtype
dtype('float32')"
numpy.iinfo,Machine limits for integer types.,"[{'Parameters': [{'name': 'int_type', 'type': 'integer type, dtype, or instance', 'description': 'The kind of integer data type to get information about.'}]}, {'Attributes': [{'name': 'bits', 'type': 'int', 'description': 'The number of bits occupied by the type.'}, {'name': 'dtype', 'type': 'dtype', 'description': 'Returns the dtype for which iinfo returns information.'}, {'name': 'minint', 'type': 'int', 'description': 'Minimum value of given dtype.'}, {'name': 'maxint', 'type': 'int', 'description': 'Maximum value of given dtype.'}]}]",">>> import numpy as np
>>> ii16 = np.iinfo(np.int16)
>>> ii16.min
-32768
>>> ii16.max
32767
>>> ii32 = np.iinfo(np.int32)
>>> ii32.min
-2147483648
>>> ii32.max
2147483647
>>> ii32 = np.iinfo(np.int32(10))
>>> ii32.min
-2147483648
>>> ii32.max
2147483647"
numpy.isdtype,Determine if a provided dtype is of a specified data type kind.,"[{'Parameters': [{'name': 'dtype', 'type': 'dtype', 'description': 'The input dtype.'}, {'name': 'kind', 'type': 'dtype or str or tuple of dtypes/strs.', 'description': ""dtype or dtype kind. Allowed dtype kinds are:* 'bool' : boolean kind* 'signed integer' : signed integer data types* 'unsigned integer' : unsigned integer data types* 'integral' : integer data types* 'real floating' : real-valued floating-point data types* 'complex floating' : complex floating-point data types* 'numeric' : numeric data types""}]}, {'Returns': [{'name': 'out', 'type': 'bool', 'description': ''}]}]",">>> import numpy as np
>>> np.isdtype(np.float32, np.float64)
False
>>> np.isdtype(np.float32, ""real floating"")
True
>>> np.isdtype(np.complex128, (""real floating"", ""complex floating""))
True"
numpy.issubdtype,Returns True if first argument is a typecode lower/equal in type hierarchy.,"[{'Parameters': [{'name': 'arg1, arg2', 'type': 'dtype_like', 'description': 'dtype or object coercible to one'}]}, {'Returns': [{'name': 'out', 'type': 'bool', 'description': ''}]}]",">>> ints = np.array([1, 2, 3], dtype=np.int32)
>>> np.issubdtype(ints.dtype, np.integer)
True
>>> np.issubdtype(ints.dtype, np.floating)
False
>>> floats = np.array([1, 2, 3], dtype=np.float32)
>>> np.issubdtype(floats.dtype, np.integer)
False
>>> np.issubdtype(floats.dtype, np.floating)
True
>>> np.issubdtype(np.float64, np.float32)
False
>>> np.issubdtype(np.float32, np.float64)
False
>>> np.issubdtype(np.float64, np.floating)
True
>>> np.issubdtype(np.float32, np.floating)
True
>>> np.issubdtype('S1', np.bytes_)
True
>>> np.issubdtype('i4', np.signedinteger)
True"
numpy.typename,Return a description for the given data type code.,"[{'Parameters': [{'name': 'char', 'type': 'str', 'description': 'Data type code.'}]}, {'Returns': [{'name': 'out', 'type': 'str', 'description': 'Description of the input data type code.'}]}]",">>> import numpy as np
>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
>>> for typechar in typechars:
...     print(typechar, ' : ', np.typename(typechar))
...
S1  :  character
?  :  bool
B  :  unsigned char
D  :  complex double precision
G  :  complex long double precision
F  :  complex single precision
I  :  unsigned integer
H  :  unsigned short
L  :  unsigned long integer
O  :  object
Q  :  unsigned long long integer
S  :  string
U  :  unicode
V  :  void
b  :  signed char
d  :  double precision
g  :  long precision
f  :  single precision
i  :  integer
h  :  short
l  :  long integer
q  :  long long integer"
numpy.mintypecode,"Return the character for the minimum-size type to which given types can
be safely cast.","[{'Parameters': [{'name': 'typechars', 'type': 'list of str or array_like', 'description': 'If a list of strings, each string should represent a dtype.If array_like, the character representation of the array dtype is used.'}, {'name': 'typeset', 'type': 'str or list of str, optional', 'description': 'The set of characters that the returned character is chosen from.The default set is ‘GDFgdf’.'}, {'name': 'default', 'type': 'str, optional', 'description': 'The default character, this is returned if none of the characters intypechars matches a character in typeset.'}]}, {'Returns': [{'name': 'typechar', 'type': 'str', 'description': 'The character representing the minimum-size type that was found.'}]}]",">>> import numpy as np
>>> np.mintypecode(['d', 'f', 'S'])
'd'
>>> x = np.array([1.1, 2-3.j])
>>> np.mintypecode(x)
'D'
>>> np.mintypecode('abceh', default='G')
'G'"
numpy.datetime_as_string,Convert an array of datetimes into an array of strings.,"[{'Parameters': [{'name': 'arr', 'type': 'array_like of datetime64', 'description': 'The array of UTC timestamps to format.'}, {'name': 'unit', 'type': 'str', 'description': 'One of None, ‘auto’, ora datetime unit.'}, {'name': 'timezone', 'type': '{‘naive’, ‘UTC’, ‘local’} or tzinfo', 'description': 'Timezone information to use when displaying the datetime. If ‘UTC’,end with a Z to indicate UTC time. If ‘local’, convert to the localtimezone first, and suffix with a +-#### timezone offset. If a tzinfoobject, then do as with ‘local’, but use the specified timezone.'}, {'name': 'casting', 'type': '{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}', 'description': 'Casting to allow when changing between datetime units.'}]}, {'Returns': [{'name': 'str_arr', 'type': 'ndarray', 'description': 'An array of strings the same shape as arr.'}]}]",">>> import numpy as np
>>> import pytz
>>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
>>> d
array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
       '2002-10-27T07:30'], dtype='datetime64[m]')
>>> np.datetime_as_string(d, timezone='UTC')
array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
       '2002-10-27T07:30Z'], dtype='<U35')
>>> np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')
>>> np.datetime_as_string(d, unit='h')
array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
      dtype='<U32')
>>> np.datetime_as_string(d, unit='s')
array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
       '2002-10-27T07:30:00'], dtype='<U38')
>>> np.datetime_as_string(d, unit='h', casting='safe')
Traceback (most recent call last):
    ...
TypeError: Cannot create a datetime string as units 'h' from a NumPy
datetime with units 'm' according to the rule 'safe'"
numpy.datetime_data,Get information about the step size of a date or time type.,"[{'Parameters': [{'name': 'dtype', 'type': 'dtype', 'description': 'The dtype object, which must be a datetime64 or timedelta64 type.'}]}, {'Returns': [{'name': 'unit', 'type': 'str', 'description': 'The datetime unit on which this dtypeis based.'}, {'name': 'count', 'type': 'int', 'description': 'The number of base units in a step.'}]}]",">>> import numpy as np
>>> dt_25s = np.dtype('timedelta64[25s]')
>>> np.datetime_data(dt_25s)
('s', 25)
>>> np.array(10, dt_25s).astype('timedelta64[s]')
array(250, dtype='timedelta64[s]')
>>> np.datetime64('2010', np.datetime_data(dt_25s))
np.datetime64('2010-01-01T00:00:00','25s')"
numpy.busdaycalendar,"A business day calendar object that efficiently stores information
defining valid days for the busday family of functions.","[{'Parameters': [{'name': 'weekmask', 'type': 'str or array_like of bool, optional', 'description': 'A seven-element array indicating which of Monday through Sunday arevalid days. May be specified as a length-seven list or array, like[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a stringlike “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations forweekdays, optionally separated by white space. Valid abbreviationsare: Mon Tue Wed Thu Fri Sat Sun'}, {'name': 'holidays', 'type': 'array_like of datetime64[D], optional', 'description': 'An array of dates to consider as invalid dates, no matter whichweekday they fall upon.  Holiday dates may be specified in anyorder, and NaT (not-a-time) dates are ignored.  This list issaved in a normalized form that is suited for fast calculationsof valid days.'}]}, {'Returns': [{'name': 'out', 'type': 'busdaycalendar', 'description': 'A business day calendar object containing the specifiedweekmask and holidays values.'}]}, {'Attributes': [{'name': 'weekmask(copy) seven-element array of bool', 'type': '(copy) seven-element array of bool', 'description': 'A copy of the seven-element boolean mask indicating valid days.'}, {'name': 'holidays(copy) sorted array of datetime64[D]', 'type': '(copy) sorted array of datetime64[D]', 'description': 'A copy of the holiday array indicating additional invalid days.'}]}]",">>> import numpy as np
>>> # Some important days in July
... bdd = np.busdaycalendar(
...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
>>> # Default is Monday to Friday weekdays
... bdd.weekmask
array([ True,  True,  True,  True,  True, False, False])
>>> # Any holidays already on the weekend are removed
... bdd.holidays
array(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')"
numpy.is_busday,"Calculates which of the given dates are valid days, and which are not.","[{'Parameters': [{'name': 'dates', 'type': 'array_like of datetime64[D]', 'description': 'The array of dates to process.'}, {'name': 'weekmask', 'type': 'str or array_like of bool, optional', 'description': 'A seven-element array indicating which of Monday through Sunday arevalid days. May be specified as a length-seven list or array, like[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a stringlike “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations forweekdays, optionally separated by white space. Valid abbreviationsare: Mon Tue Wed Thu Fri Sat Sun'}, {'name': 'holidays', 'type': 'array_like of datetime64[D], optional', 'description': 'An array of dates to consider as invalid dates.  They may bespecified in any order, and NaT (not-a-time) dates are ignored.This list is saved in a normalized form that is suited forfast calculations of valid days.'}, {'name': 'busdaycal', 'type': 'busdaycalendar, optional', 'description': 'A busdaycalendar object which specifies the valid days. If thisparameter is provided, neither weekmask nor holidays may beprovided.'}, {'name': 'out', 'type': 'array of bool, optional', 'description': 'If provided, this array is filled with the result.'}]}, {'Returns': [{'name': 'out', 'type': 'array of bool', 'description': 'An array with the same shape as dates, containing True foreach valid day, and False for each invalid day.'}]}]",">>> import numpy as np
>>> # The weekdays are Friday, Saturday, and Monday
... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
array([False, False,  True])"
numpy.busday_offset,"First adjusts the date to fall on a valid day according to
the roll rule, then applies offsets to the given dates
counted in valid days.","[{'Parameters': [{'name': 'dates', 'type': 'array_like of datetime64[D]', 'description': 'The array of dates to process.'}, {'name': 'offsets', 'type': 'array_like of int', 'description': 'The array of offsets, which is broadcast with dates.'}, {'name': 'roll', 'type': '{‘raise’, ‘nat’, ‘forward’, ‘following’, ‘backward’, ‘preceding’,         ‘modifiedfollowing’, ‘modifiedpreceding’}, optional', 'description': 'How to treat dates that do not fall on a valid day. The defaultis ‘raise’.‘raise’ means to raise an exception for an invalid day.‘nat’ means to return a NaT (not-a-time) for an invalid day.‘forward’ and ‘following’ mean to take the first valid daylater in time.‘backward’ and ‘preceding’ mean to take the first valid dayearlier in time.‘modifiedfollowing’ means to take the first valid daylater in time unless it is across a Month boundary, in whichcase to take the first valid day earlier in time.‘modifiedpreceding’ means to take the first valid dayearlier in time unless it is across a Month boundary, in whichcase to take the first valid day later in time.'}, {'name': 'weekmask', 'type': 'str or array_like of bool, optional', 'description': 'A seven-element array indicating which of Monday through Sunday arevalid days. May be specified as a length-seven list or array, like[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a stringlike “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations forweekdays, optionally separated by white space. Valid abbreviationsare: Mon Tue Wed Thu Fri Sat Sun'}, {'name': 'holidays', 'type': 'array_like of datetime64[D], optional', 'description': 'An array of dates to consider as invalid dates.  They may bespecified in any order, and NaT (not-a-time) dates are ignored.This list is saved in a normalized form that is suited forfast calculations of valid days.'}, {'name': 'busdaycal', 'type': 'busdaycalendar, optional', 'description': 'A busdaycalendar object which specifies the valid days. If thisparameter is provided, neither weekmask nor holidays may beprovided.'}, {'name': 'out', 'type': 'array of datetime64[D], optional', 'description': 'If provided, this array is filled with the result.'}]}, {'Returns': [{'name': 'out', 'type': 'array of datetime64[D]', 'description': 'An array with a shape from broadcasting dates and offsetstogether, containing the dates with offsets applied.'}]}]",">>> import numpy as np
>>> # First business day in October 2011 (not accounting for holidays)
... np.busday_offset('2011-10', 0, roll='forward')
np.datetime64('2011-10-03')
>>> # Last business day in February 2012 (not accounting for holidays)
... np.busday_offset('2012-03', -1, roll='forward')
np.datetime64('2012-02-29')
>>> # Third Wednesday in January 2011
... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
np.datetime64('2011-01-19')
>>> # 2012 Mother's Day in Canada and the U.S.
... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
np.datetime64('2012-05-13')
>>> # First business day on or after a date
... np.busday_offset('2011-03-20', 0, roll='forward')
np.datetime64('2011-03-21')
>>> np.busday_offset('2011-03-22', 0, roll='forward')
np.datetime64('2011-03-22')
>>> # First business day after a date
... np.busday_offset('2011-03-20', 1, roll='backward')
np.datetime64('2011-03-21')
>>> np.busday_offset('2011-03-22', 1, roll='backward')
np.datetime64('2011-03-23')"
numpy.busday_count,"Counts the number of valid days between begindates and
enddates, not including the day of enddates.","[{'Parameters': [{'name': 'begindates', 'type': 'array_like of datetime64[D]', 'description': 'The array of the first dates for counting.'}, {'name': 'enddates', 'type': 'array_like of datetime64[D]', 'description': 'The array of the end dates for counting, which are excludedfrom the count themselves.'}, {'name': 'weekmask', 'type': 'str or array_like of bool, optional', 'description': 'A seven-element array indicating which of Monday through Sunday arevalid days. May be specified as a length-seven list or array, like[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a stringlike “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations forweekdays, optionally separated by white space. Valid abbreviationsare: Mon Tue Wed Thu Fri Sat Sun'}, {'name': 'holidays', 'type': 'array_like of datetime64[D], optional', 'description': 'An array of dates to consider as invalid dates.  They may bespecified in any order, and NaT (not-a-time) dates are ignored.This list is saved in a normalized form that is suited forfast calculations of valid days.'}, {'name': 'busdaycal', 'type': 'busdaycalendar, optional', 'description': 'A busdaycalendar object which specifies the valid days. If thisparameter is provided, neither weekmask nor holidays may beprovided.'}, {'name': 'out', 'type': 'array of int, optional', 'description': 'If provided, this array is filled with the result.'}]}, {'Returns': [{'name': 'out', 'type': 'array of int', 'description': 'An array with a shape from broadcasting begindates and enddatestogether, containing the number of valid days betweenthe begin and end dates.'}]}]",">>> import numpy as np
>>> # Number of weekdays in January 2011
... np.busday_count('2011-01', '2011-02')
21
>>> # Number of weekdays in 2011
>>> np.busday_count('2011', '2012')
260
>>> # Number of Saturdays in 2011
... np.busday_count('2011', '2012', weekmask='Sat')
53"
numpy.polynomial.laguerre.Laguerre,A Laguerre series class.,"[{'Parameters': [{'name': 'coef', 'type': 'array_like', 'description': 'Laguerre coefficients in order of increasing degree, i.e,(1, 2, 3) gives 1*L_0(x) + 2*L_1(X) + 3*L_2(x).'}, {'name': 'domain', 'type': '(2,) array_like, optional', 'description': 'Domain to use. The interval [domain[0], domain[1]] is mappedto the interval [window[0], window[1]] by shifting and scaling.The default value is [0., 1.].'}, {'name': 'window', 'type': '(2,) array_like, optional', 'description': 'Window, see domain for its use. The default value is [0., 1.].'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol used to represent the independent variable in stringrepresentations of the polynomial expression, e.g. for printing.The symbol must be a valid Python identifier. Default value is ‘x’.New in version 1.24.'}]}, {'Attributes': [{'name': 'symbol', 'type': None, 'description': ''}]}]",
numpy.polynomial.laguerre.Laguerre.__call__,method,[],
numpy.polynomial.laguerre.Laguerre.basis,method,"[{'Parameters': [{'name': 'deg', 'type': 'int', 'description': 'Degree of the basis polynomial for the series. Must be >= 0.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series with the coefficient of the deg term set to one andall others zero.'}]}]",
numpy.polynomial.laguerre.Laguerre.cast,method,"[{'Parameters': [{'name': 'series', 'type': 'series', 'description': 'The series instance to be converted.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series of the same kind as the calling class and equal toseries when evaluated.'}]}]",
numpy.polynomial.laguerre.Laguerre.convert,method,"[{'Parameters': [{'name': 'domain', 'type': 'array_like, optional', 'description': 'The domain of the converted series. If the value is None,the default domain of kind is used.'}, {'name': 'kind', 'type': 'class, optional', 'description': 'The polynomial series type class to which the current instanceshould be converted. If kind is None, then the class of thecurrent instance is used.'}, {'name': 'window', 'type': 'array_like, optional', 'description': 'The window of the converted series. If the value is None,the default window of kind is used.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'The returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.'}]}]",
numpy.polynomial.laguerre.Laguerre.copy,method,"[{'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Copy of self.'}]}]",
numpy.polynomial.laguerre.Laguerre.cutdeg,method,"[{'Parameters': [{'name': 'deg', 'type': 'non-negative int', 'description': 'The series is reduced to degree deg by discarding the highorder terms. The value of deg must be a non-negative integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with reduced degree.'}]}]",
numpy.polynomial.laguerre.Laguerre.degree,method,"[{'Returns': [{'name': 'degree', 'type': 'int', 'description': 'Degree of the series, one less than the number of coefficients.'}]}]",">>> poly = np.polynomial.Polynomial([1, 7, 4])
>>> print(poly)
1.0 + 7.0·x + 4.0·x²
>>> poly.degree()
2
>>> poly = np.polynomial.Polynomial([1, 7, 0])
>>> print(poly)
1.0 + 7.0·x + 0.0·x²
>>> poly.degree()
2
>>> poly.trim().degree()
1"
numpy.polynomial.laguerre.Laguerre.deriv,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'Find the derivative of order m.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the derivative. The domain is the sameas the domain of the differentiated series.'}]}]",
numpy.polynomial.laguerre.Laguerre.fit,method,"[{'Parameters': [{'name': 'x', 'type': 'array_like, shape (M,)', 'description': 'x-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'y', 'type': 'array_like, shape (M,)', 'description': 'y-coordinates of the M sample points (x[i], y[i]).'}, {'name': 'deg', 'type': 'int or 1-D array_like', 'description': 'Degree(s) of the fitting polynomials. If deg is a single integerall terms up to and including the deg’th term are included in thefit. For NumPy versions >= 1.11.0 a list of integers specifying thedegrees of the terms to include may be used instead.'}, {'name': 'domain', 'type': '{None, [beg, end], []}, optional', 'description': 'Domain to use for the returned series. If None,then a minimal domain that covers the points x is chosen.  If[] the class domain is used. The default value was theclass domain in NumPy 1.4 and None in later versions.The [] option was added in numpy 1.5.0.'}, {'name': 'rcond', 'type': 'float, optional', 'description': 'Relative condition number of the fit. Singular values smallerthan this relative to the largest singular value will beignored. The default value is len(x)*eps, where eps is therelative precision of the float type, about 2e-16 in mostcases.'}, {'name': 'full', 'type': 'bool, optional', 'description': 'Switch determining nature of return value. When it is False(the default) just the coefficients are returned, when Truediagnostic information from the singular value decomposition isalso returned.'}, {'name': 'w', 'type': 'array_like, shape (M,), optional', 'description': 'Weights. If not None, the weight w[i] applies to the unsquaredresidual y[i] - y_hat[i] at x[i]. Ideally the weights arechosen so that the errors of the products w[i]*y[i] all havethe same variance.  When using inverse-variance weighting, usew[i] = 1/sigma(y[i]).  The default value is None.'}, {'name': 'window', 'type': '{[beg, end]}, optional', 'description': 'Window to use for the returned series. The defaultvalue is the default class domain'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.'}, {'name': '[resid, rank, sv, rcond]', 'type': 'list', 'description': 'These values are only returned if full == Trueresid – sum of squared residuals of the least squares fitrank – the numerical rank of the scaled Vandermonde matrixsv – singular values of the scaled Vandermonde matrixrcond – value of rcond.For more details, see linalg.lstsq.'}]}]",
numpy.polynomial.laguerre.Laguerre.fromroots,method,"[{'Parameters': [{'name': 'roots', 'type': 'array_like', 'description': 'List of roots.'}, {'name': 'domain', 'type': '{[], None, array_like}, optional', 'description': 'Domain for the resulting series. If None the domain is theinterval from the smallest root to the largest. If [] thedomain is the class domain. The default is [].'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'Window for the returned series. If None the class window isused. The default is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series with the specified roots.'}]}]",
numpy.polynomial.laguerre.Laguerre.has_samecoef,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the coef attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the coefficients are the same, False otherwise.'}]}]",
numpy.polynomial.laguerre.Laguerre.has_samedomain,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the domain attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the domains are the same, False otherwise.'}]}]",
numpy.polynomial.laguerre.Laguerre.has_sametype,method,"[{'Parameters': [{'name': 'other', 'type': 'object', 'description': 'Class instance.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if other is same class as self'}]}]",
numpy.polynomial.laguerre.Laguerre.has_samewindow,method,"[{'Parameters': [{'name': 'other', 'type': 'class instance', 'description': 'The other class must have the window attribute.'}]}, {'Returns': [{'name': 'bool', 'type': 'boolean', 'description': 'True if the windows are the same, False otherwise.'}]}]",
numpy.polynomial.laguerre.Laguerre.identity,method,"[{'Parameters': [{'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If given, the array must be of the form [beg, end], wherebeg and end are the endpoints of the domain. If None isgiven then the class domain is used. The default is None.'}, {'name': 'window', 'type': '{None, array_like}, optional', 'description': 'If given, the resulting array must be if the form[beg, end], where beg and end are the endpoints ofthe window. If None is given then the class window is used. Thedefault is None.'}, {'name': 'symbol', 'type': 'str, optional', 'description': 'Symbol representing the independent variable. Default is ‘x’.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'Series of representing the identity.'}]}]",
numpy.polynomial.laguerre.Laguerre.integ,method,"[{'Parameters': [{'name': 'm', 'type': 'non-negative int', 'description': 'The number of integrations to perform.'}, {'name': 'k', 'type': 'array_like', 'description': 'Integration constants. The first constant is applied to thefirst integration, the second to the second, and so on. Thelist of values must less than or equal to m in length and anymissing values are set to zero.'}, {'name': 'lbnd', 'type': 'Scalar', 'description': 'The lower bound of the definite integral.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'A new series representing the integral. The domain is the sameas the domain of the integrated series.'}]}]",
numpy.polynomial.laguerre.Laguerre.linspace,method,"[{'Parameters': [{'name': 'n', 'type': 'int, optional', 'description': 'Number of point pairs to return. The default value is 100.'}, {'name': 'domain', 'type': '{None, array_like}, optional', 'description': 'If not None, the specified domain is used instead of that ofthe calling instance. It should be of the form [beg,end].The default is None which case the class domain is used.'}]}, {'Returns': [{'name': 'x, y', 'type': 'ndarray', 'description': 'x is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.'}]}]",
numpy.polynomial.laguerre.Laguerre.mapparms,method,"[{'Returns': [{'name': 'off, scl', 'type': 'float or complex', 'description': 'The mapping function is defined by off + scl*x.'}]}]",
numpy.polynomial.laguerre.Laguerre.roots,method,"[{'Returns': [{'name': 'roots', 'type': 'ndarray', 'description': 'Array containing the roots of the series.'}]}]",
numpy.polynomial.laguerre.Laguerre.trim,method,"[{'Parameters': [{'name': 'tol', 'type': 'non-negative number.', 'description': 'All trailing coefficients less than tol will be removed.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with trimmed coefficients.'}]}]",
numpy.polynomial.laguerre.Laguerre.truncate,method,"[{'Parameters': [{'name': 'size', 'type': 'positive int', 'description': 'The series is reduced to length size by discarding the highdegree terms. The value of size must be a positive integer.'}]}, {'Returns': [{'name': 'new_series', 'type': 'series', 'description': 'New instance of series with truncated coefficients.'}]}]",
numpy.emath.arccos,Compute the inverse cosine of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like or scalar', 'description': 'The value(s) whose arccos is (are) required.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The inverse cosine(s) of the x value(s). If x was a scalar, sois out, otherwise an array object is returned.'}]}]",">>> import numpy as np
>>> np.set_printoptions(precision=4)
>>> np.emath.arccos(1) # a scalar is returned
0.0
>>> np.emath.arccos([1,2])
array([0.-0.j   , 0.-1.317j])"
numpy.emath.arcsin,Compute the inverse sine of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like or scalar', 'description': 'The value(s) whose arcsin is (are) required.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The inverse sine(s) of the x value(s). If x was a scalar, sois out, otherwise an array object is returned.'}]}]",">>> import numpy as np
>>> np.set_printoptions(precision=4)
>>> np.emath.arcsin(0)
0.0
>>> np.emath.arcsin([0,1])
array([0.    , 1.5708])"
numpy.emath.arctanh,Compute the inverse hyperbolic tangent of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The value(s) whose arctanh is (are) required.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The inverse hyperbolic tangent(s) of the x value(s). If x wasa scalar so is out, otherwise an array is returned.'}]}]",">>> import numpy as np
>>> np.set_printoptions(precision=4)
>>> np.emath.arctanh(0.5)
0.5493061443340549
>>> from numpy.testing import suppress_warnings
>>> with suppress_warnings() as sup:
...     sup.filter(RuntimeWarning)
...     np.emath.arctanh(np.eye(2))
array([[inf,  0.],
       [ 0., inf]])
>>> np.emath.arctanh([1j])
array([0.+0.7854j])"
numpy.emath.log,Compute the natural logarithm of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The value(s) whose log is (are) required.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The log of the x value(s). If x was a scalar, so is out,otherwise an array is returned.'}]}]",">>> import numpy as np
>>> np.emath.log(np.exp(1))
1.0
>>> np.emath.log(-np.exp(1)) == (1 + np.pi * 1j)
True"
numpy.emath.log2,Compute the logarithm base 2 of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The value(s) whose log base 2 is (are) required.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The log base 2 of the x value(s). If x was a scalar, so is out,otherwise an array is returned.'}]}]",">>> np.set_printoptions(precision=4)
>>> np.emath.log2(8)
3.0
>>> np.emath.log2([-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])"
numpy.emath.logn,Take log base n of x.,"[{'Parameters': [{'name': 'n', 'type': 'array_like', 'description': 'The integer base(s) in which the log is taken.'}, {'name': 'x', 'type': 'array_like', 'description': 'The value(s) whose log base n is (are) required.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The log base n of the x value(s). If x was a scalar, so isout, otherwise an array is returned.'}]}]",">>> import numpy as np
>>> np.set_printoptions(precision=4)
>>> np.emath.logn(2, [4, 8])
array([2., 3.])
>>> np.emath.logn(2, [-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])"
numpy.emath.log10,Compute the logarithm base 10 of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like or scalar', 'description': 'The value(s) whose log base 10 is (are) required.'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The log base 10 of the x value(s). If x was a scalar, so is out,otherwise an array object is returned.'}]}]",">>> import numpy as np
>>> np.set_printoptions(precision=4)
>>> np.emath.log10(10**1)
1.0
>>> np.emath.log10([-10**1, -10**2, 10**2])
array([1.+1.3644j, 2.+1.3644j, 2.+0.j    ])"
numpy.emath.power,"Return x to the power p, (x**p).","[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The input value(s).'}, {'name': 'p', 'type': 'array_like of ints', 'description': 'The power(s) to which x is raised. If x contains multiple values,p has to either be a scalar, or contain the same number of valuesas x. In the latter case, the result isx[0]**p[0], x[1]**p[1], ....'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The result of x**p. If x and p are scalars, so is out,otherwise an array is returned.'}]}]",">>> import numpy as np
>>> np.set_printoptions(precision=4)
>>> np.emath.power(2, 2)
4
>>> np.emath.power([2, 4], 2)
array([ 4, 16])
>>> np.emath.power([2, 4], -2)
array([0.25  ,  0.0625])
>>> np.emath.power([-2, 4], 2)
array([ 4.-0.j, 16.+0.j])
>>> np.emath.power([2, 4], [2, 4])
array([ 4, 256])"
numpy.emath.sqrt,Compute the square root of x.,"[{'Parameters': [{'name': 'x', 'type': 'array_like', 'description': 'The input value(s).'}]}, {'Returns': [{'name': 'out', 'type': 'ndarray or scalar', 'description': 'The square root of x. If x was a scalar, so is out,otherwise an array is returned.'}]}]",">>> import numpy as np
>>> np.emath.sqrt(1)
1.0
>>> np.emath.sqrt([1, 4])
array([1.,  2.])
>>> np.emath.sqrt(-1)
1j
>>> np.emath.sqrt([-1,4])
array([0.+1.j, 2.+0.j])
>>> np.emath.sqrt(complex(-4.0, 0.0))
2j
>>> np.emath.sqrt(complex(-4.0, -0.0))
-2j"
